#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Bio/Cigar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BIO_CIGAR';
  package Bio::Cigar;

  use strict;
  use warnings;
  use 5.014;

  =encoding utf-8

  =head1 NAME

  Bio::Cigar - Parse CIGAR strings and translate coordinates to/from reference/query

  =head1 SYNOPSIS

      use 5.014;
      use Bio::Cigar;
      my $cigar = Bio::Cigar->new("2M1D1M1I4M");
      say "Query length is ", $cigar->query_length;
      say "Reference length is ", $cigar->reference_length;

      my ($qpos, $op) = $cigar->rpos_to_qpos(3);
      say "Alignment operation at reference position 3 is $op";

  =head1 DESCRIPTION

  Bio::Cigar is a small library to parse CIGAR strings ("Compact Idiosyncratic
  Gapped Alignment Report"), such as those used in the SAM file format.  CIGAR
  strings are a run-length encoding which minimally describes the alignment of a
  query sequence to an (often longer) reference sequence.

  Parsing follows the L<SAM v1 spec|http://samtools.github.io/hts-specs/SAMv1.pdf>
  for the C<CIGAR> column.

  Parsed strings are represented by an object that provides a few utility
  methods.

  =head1 ATTRIBUTES

  All attributes are read-only.

  =head2 string

  The CIGAR string for this object.

  =head2 reference_length

  The length of the reference sequence segment aligned with the query sequence
  described by the CIGAR string.

  =head2 query_length

  The length of the query sequence described by the CIGAR string.

  =head2 ops

  An arrayref of C<[length, operation]> tuples describing the CIGAR string.
  Lengths are integers, L<possible operations are below|/"CIGAR operations">.

  =cut

  our $VERSION = '1.01';

  use Moo;
  use Types::Standard qw< ArrayRef Tuple Int Enum StrMatch >;
  use List::Util qw< sum >;
  use Carp qw< croak >;
  use namespace::clean;

  =head3 CIGAR operations

  The CIGAR operations are given in the following table, taken from the SAM v1
  spec:

      Op  Description
      ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
      M   alignment match (can be a sequence match or mismatch)
      I   insertion to the reference
      D   deletion from the reference
      N   skipped region from the reference
      S   soft clipping (clipped sequences present in SEQ)
      H   hard clipping (clipped sequences NOT present in SEQ)
      P   padding (silent deletion from padded reference)
      =   sequence match
      X   sequence mismatch

      • H can only be present as the first and/or last operation.
      • S may only have H operations between them and the ends of the string.
      • For mRNA-to-genome alignment, an N operation represents an intron.
        For other types of alignments, the interpretation of N is not defined.
      • Sum of the lengths of the M/I/S/=/X operations shall equal the length of SEQ.

  =cut

  our $CIGAR_REGEX = qr/^
      (\d*H)?(\d*S)?
      (?<OP>\d*[MIDNP=X])*
      (\d*S)?(\d*H)?
  $/xa;

  has 'string',
      is       => 'ro',
      isa      => StrMatch[ $CIGAR_REGEX ],
      required => 1;

  has 'query_length',
      lazy    => 1,
      is      => 'ro',
      isa     => Int,
      default => sub { sum(map { $_ || 1 } $_[0]->string =~ /(\d*)[MIS=X]/ga) || 0 };

  has 'reference_length',
      lazy    => 1,
      is      => 'ro',
      isa     => Int,
      default => sub { sum(map { $_ || 1 } $_[0]->string =~ /(\d*)[MDN=X]/ga) || 0 };

  has 'ops',
      lazy    => 1,
      is      => 'ro',
      isa     => ArrayRef[ Tuple[ Int, Enum[split '', 'MIDNSHP=X'] ] ],
      builder => '_parse';

  sub BUILDARGS {
      my $class = shift;
      if (@_ == 1 and not ref $_[0]) {
          return { string => $_[0] };
      } else {
          croak sprintf "%s->new must be called with a string as the sole argument", __PACKAGE__;
      }
  }

  sub _parse {
      my $self  = shift;
      my $cigar = $self->string;
      my @ops;
      for my $op (grep defined, $cigar =~ /(\d*[MIDNSHP=X])/g) {
          my ($len, $type) = $op =~ /(\d*)(\D*)/a;
          push @ops, [ $len || 1, uc $type ];
      }
      return \@ops;
  }

  =head1 CONSTRUCTOR

  =head2 new

  Takes a CIGAR string as the sole argument and returns a new Bio::Cigar object.

  =head1 METHODS

  =head2 rpos_to_qpos

  Takes a reference position (origin 1, base-numbered) and returns the
  corresponding position (origin 1, base-numbered) on the query sequence.  Indels
  affect how the numbering maps from reference to query.

  In list context returns a tuple of C<[query position, operation at position]>.
  Operation is a single-character string.  See the
  L<table of CIGAR operations|/"CIGAR operations">.

  If the reference position does not map to the query sequence (as with a
  deletion, for example), returns C<undef> or C<[undef, operation]>.

  =head2 qpos_to_rpos

  Takes a query position (origin 1, base-numbered) and returns the corresponding
  position (origin 1, base-numbered) on the reference sequence.  Indels affect
  how the numbering maps from query to reference.

  In list context returns a tuple of C<[references position, operation at position]>.
  Operation is a single-character string.  See the
  L<table of CIGAR operations|/"CIGAR operations">.

  If the query position does not map to the reference sequence (as with an
  insertion, for example), returns C<undef> or C<[undef, operation]>.

  =head2 op_at_rpos

  Takes a reference position and returns the operation at that position.  Simply
  a shortcut for calling L</rpos_to_qpos> in list context and discarding the
  first return value.

  =head2 op_at_qpos

  Takes a query position and returns the operation at that position.  Simply
  a shortcut for calling L</qpos_to_rpos> in list context and discarding the
  first return value.

  =cut

  # Consumption table based on
  # https://github.com/samtools/htslib/blob/develop/htslib/sam.h#L81-L100
  my %op_consumes = (
      # op => [query, reference]
      'M' => [1, 1],
      'I' => [1, 0],
      'D' => [0, 1],
      'N' => [0, 1],
      'S' => [1, 0],
      'H' => [0, 0],
      'P' => [0, 0],
      '=' => [1, 1],
      'X' => [1, 1],
  );

  sub rpos_to_qpos {
      my $self = shift;
      return $self->_map_position( rpos => @_ );
  }

  sub qpos_to_rpos {
      my $self = shift;
      return $self->_map_position( qpos => @_ );
  }

  sub _map_position {
      my $self   = shift;
      my $from   = shift;
      my $target = shift;
      my $target_len = $from eq "rpos" ? "reference_length" : "query_length";

      my $rpos   = 0;
      my $qpos   = 0;

      croak sprintf "$from = %d is < 1 or > $target_len (%d)", $target, $self->$target_len
          if $target < 1 or $target > $self->$target_len;

      # Each cigar operation consumes the reference, query, or both.  We keep
      # track of both positions until the query/reference position hits the
      # target.  Then we return the equivalent other position.

      for my $op (@{ $self->ops }) {
          my ($len, $type) = @$op;
          my $consumes = $op_consumes{$type};
          next unless $consumes->[0] or $consumes->[1];

          $qpos += $len if $consumes->[0];
          $rpos += $len if $consumes->[1];

          # The logic could be written with more variables to reduce the
          # duplication in this if/else, but I think the clarity of the logic is
          # enhanced by the similarity of the if/else branches.  Adding more
          # varibles to make the logic generic muddies the simplicity.
          if ($from eq "rpos") {
              if ($rpos > $target) {
                  my $overshoot = $rpos - $target;
                  $rpos -= $overshoot;
                  $qpos -= $overshoot;
              }
              if ($rpos == $target) {
                  if ($consumes->[1] and not $consumes->[0]) {
                      # Reference positions which are missing in the query sequence
                      # don't have a corresponding query position.
                      return wantarray ? (undef, $type) : undef;
                  } else {
                      $qpos <= $self->query_length
                          or croak sprintf "Bug! Assertion failed: qpos <= qlen"
                                         . " (target = %d, rpos = %d, qpos = %d, qlen = %d, cigar = %s)",
                              $target, $rpos, $qpos, $self->query_length, $self->string;
                      return wantarray ? ($qpos, $type) : $qpos;
                  }
              }
          } else {
              if ($qpos > $target) {
                  my $overshoot = $qpos - $target;
                  $rpos -= $overshoot;
                  $qpos -= $overshoot;
              }
              if ($qpos == $target) {
                  if ($consumes->[0] and not $consumes->[1]) {
                      # Query positions which are insertions in the reference sequence
                      # don't have a corresponding reference position.
                      return wantarray ? (undef, $type) : undef;
                  } else {
                      $rpos <= $self->reference_length
                          or croak sprintf "Bug! Assertion failed: rpos <= rlen"
                                         . " (target = %d, qpos = %d, rpos = %d, rlen = %d, cigar = %s)",
                              $target, $qpos, $rpos, $self->reference_length, $self->string;
                      return wantarray ? ($rpos, $type) : $rpos;
                  }
              }
          }
      }
      croak sprintf "Bug! Ran out of ops but couldn't map %s %d"
                  . " (rpos = %d, qpos = %d, cigar = %s)",
          $from, $target, $rpos, $qpos, $self->string;
  }

  sub op_at_rpos {
      my $self = shift;
      my ($qpos, $type) = $self->rpos_to_qpos(@_);
      return $type;
  }

  sub op_at_qpos {
      my $self = shift;
      my ($rpos, $type) = $self->qpos_to_rpos(@_);
      return $type;
  }

  =head1 AUTHOR

  Thomas Sibley E<lt>trsibley@uw.eduE<gt>

  =head1 COPYRIGHT

  Copyright 2014- Mullins Lab, Department of Microbiology, University of Washington.

  =head1 LICENSE

  This library is free software; you can redistribute it and/or modify it under
  the GNU General Public License, version 2.

  =head1 SEE ALSO

  L<SAMv1 spec|http://samtools.github.io/hts-specs/SAMv1.pdf>

  =cut

  1;
BIO_CIGAR

$fatpacked{"Devel/TypeTiny/Perl56Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL56COMPAT';
  package Devel::TypeTiny::Perl56Compat;

  use 5.006;
  use strict;
  use warnings;

  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';

  #### B doesn't provide perlstring() in 5.6. Monkey patch it.

  use B ();

  unless (exists &B::perlstring)
  {
  	my $d;
  	*B::perlstring = sub {
  		no warnings 'uninitialized';
  		require Data::Dumper;
  		$d ||= 'Data::Dumper'->new([])->Indent(0)->Purity(0)->Pad('')->Useqq(1)->Terse(1)->Freezer('')->Toaster('');
  		my $perlstring = $d->Values([''.shift])->Dump;
  		($perlstring =~ /^"/) ? $perlstring : qq["$perlstring"];
  	};
  }

  push @B::EXPORT_OK, 'perlstring';

  #### Done!

  5.6;

  __END__

  =pod

  =encoding utf-8

  =for stopwords pragmas

  =head1 NAME

  Devel::TypeTiny::Perl56Compat - shims to allow Type::Tiny to run on Perl 5.6.x

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This is not considered part of Type::Tiny's public API.

  Currently this module just has one job: it patches L<B> to export a
  C<perlstring> function, as this was only added in Perl 5.8.0.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

DEVEL_TYPETINY_PERL56COMPAT

$fatpacked{"Devel/TypeTiny/Perl58Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL58COMPAT';
  package Devel::TypeTiny::Perl58Compat;

  use 5.006;
  use strict;
  use warnings;

  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';

  #### re doesn't provide is_regexp in Perl < 5.10

  eval 'require re';

  unless (exists &re::is_regexp)
  {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object($_[0])->MAGIC->TYPE eq 'r' };
  	};
  }

  #### Done!

  5.6;

  __END__

  =pod

  =encoding utf-8

  =for stopwords pragmas

  =head1 NAME

  Devel::TypeTiny::Perl58Compat - shims to allow Type::Tiny to run on Perl 5.8.x

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This is not considered part of Type::Tiny's public API.

  Currently this module just has one job: it patches L<re> to provide a
  C<is_regexp> function, as this was only added in Perl 5.9.5.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

DEVEL_TYPETINY_PERL58COMPAT

$fatpacked{"Error/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY';
  package Error::TypeTiny;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Error::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::VERSION   = '1.000005';
  }

  use overload
  	q[""]    => sub { $_[0]->to_string },
  	q[bool]  => sub { 1 },
  	fallback => 1,
  ;

  our %CarpInternal;
  $CarpInternal{$_}++ for qw(
  	Eval::TypeTiny
  	Eval::TypeTiny::Sandbox
  	Exporter::Tiny
  	Test::TypeTiny
  	Type::Coercion
  	Type::Coercion::Union
  	Error::TypeTiny
  	Type::Library
  	Type::Params
  	Type::Registry
  	Types::Standard
  	Types::Standard::_Stringable
  	Types::TypeTiny
  	Type::Tiny
  	Type::Tiny::Class
  	Type::Tiny::Duck
  	Type::Tiny::Enum
  	Type::Tiny::Intersection
  	Type::Tiny::Role
  	Type::Tiny::Union
  	Type::Utils
  );

  sub new
  {
  	my $class = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	return bless \%params, $class;
  }

  sub throw
  {
  	my $class = shift;

  	my ($level, @caller, %ctxt) = 0;
  	while (
  		defined scalar caller($level) and $CarpInternal{scalar caller($level)}
  	) { $level++ };
  	if ( ((caller($level - 1))[1]||"") =~ /^parameter validation for '(.+?)'$/ )
  	{
  		my ($pkg, $func) = ($1 =~ m{^(.+)::(\w+)$});
  		$level++ if caller($level) eq ($pkg||"");
  	}
  	@ctxt{qw/ package file line /} = caller($level);

  	my $stack = undef;
  	if (our $StackTrace)
  	{
  		require Devel::StackTrace;
  		$stack = "Devel::StackTrace"->new(
  			ignore_package => [ keys %CarpInternal ],
  		);
  	}

  	die(
  		our $LastError = $class->new(
  			context     => \%ctxt,
  			stack_trace => $stack,
  			@_,
  		)
  	);
  }

  sub message     { $_[0]{message} ||= $_[0]->_build_message };
  sub context     { $_[0]{context} };
  sub stack_trace { $_[0]{stack_trace} };

  sub to_string
  {
  	my $e = shift;
  	my $c = $e->context;
  	my $m = $e->message;

  	$m =~ /\n\z/s ? $m :
  	$c            ? sprintf("%s at %s line %s.\n", $m, $c->{file}||'file?', $c->{line}||'NaN') :
  	sprintf("%s\n", $m);
  }

  sub _build_message
  {
  	return 'An exception has occurred';
  }

  sub croak
  {
  	my ($fmt, @args) = @_;
  	@_ = (
  		__PACKAGE__,
  		message => sprintf($fmt, @args),
  	);
  	goto \&throw;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Error::TypeTiny - exceptions for Type::Tiny and friends

  =head1 SYNOPSIS

     use Data::Dumper;
     use Try::Tiny;
     use Types::Standard qw(Str);

     try {
        Str->assert_valid(undef);
     }
     catch {
        my $exception = shift;
        warn "Encountered Error: $exception";
        warn Dumper($exception->explain)
           if $exception->isa("Error::TypeTiny::Assertion");
     };

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  When Type::Tiny and its related modules encounter an error, they throw an
  exception object. These exception objects inherit from Error::TypeTiny.

  =head2 Constructors

  =over

  =item C<< new(%attributes) >>

  Moose-style constructor function.

  =item C<< throw(%attributes) >>

  Constructs an exception and passes it to C<die>.

  Automatically populates C<context> and C<stack_trace> if appropriate.

  =back

  =head2 Attributes

  =over

  =item C<message>

  The error message.

  =item C<context>

  Hashref containing the package, file and line that generated the error.

  =item C<stack_trace>

  A more complete stack trace. This feature requires L<Devel::StackTrace>;
  use the C<< $StackTrace >> package variable to switch it on.

  =back

  =head2 Methods

  =over

  =item C<to_string>

  Returns the message, followed by the context if it is set.

  =back

  =head2 Functions

  =over

  =item C<< Error::TypeTiny::croak($format, @args) >>

  Functional-style shortcut to C<throw> method. Takes an C<sprintf>-style
  format string and optional arguments to construct the C<message>.

  =back

  =head2 Overloading

  =over

  =item *

  Stringification is overloaded to call C<to_string>.

  =back

  =head2 Package Variables

  =over

  =item C<< %Error::TypeTiny::CarpInternal >>

  Serves a similar purpose to C<< %Carp::CarpInternal >>.

  =item C<< $Error::TypeTiny::StackTrace >>

  Boolean to toggle stack trace generation.

  =item C<< $Error::TypeTiny::LastError >>

  A reference to the last exception object thrown.

  =back

  =head1 CAVEATS

  Although Error::TypeTiny objects are thrown for errors produced by
  Type::Tiny, that doesn't mean every time you use Type::Tiny you'll get
  Error::TypeTinys whenever you want.

  For example, if you use a Type::Tiny type constraint in a Moose attribute,
  Moose will not call the constraint's C<assert_valid> method (which throws
  an exception). Instead it will call C<check> and C<get_message> (which do
  not), and will C<confess> an error message of its own. (The C<< $LastError >>
  package variable may save your bacon.)

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Error::TypeTiny::Assertion>,
  L<Error::TypeTiny::WrongNumberOfParameters>.

  L<Try::Tiny>, L<Try::Tiny::ByClass>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

ERROR_TYPETINY

$fatpacked{"Error/TypeTiny/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_ASSERTION';
  package Error::TypeTiny::Assertion;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }

  BEGIN {
  	$Error::TypeTiny::Assertion::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Assertion::VERSION   = '1.000005';
  }

  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';

  sub type               { $_[0]{type} };
  sub value              { $_[0]{value} };
  sub varname            { $_[0]{varname} ||= '$_' };
  sub attribute_step     { $_[0]{attribute_step} };
  sub attribute_name     { $_[0]{attribute_name} };

  sub has_type           { defined $_[0]{type} }; # sic
  sub has_attribute_step { exists $_[0]{attribute_step} };
  sub has_attribute_name { exists $_[0]{attribute_name} };

  sub new
  {
  	my $class = shift;
  	my $self  = $class->SUPER::new(@_);

  	if (ref $Method::Generate::Accessor::CurrentAttribute)
  	{
  		require B;
  		my %d = %{$Method::Generate::Accessor::CurrentAttribute};
  		$self->{attribute_name} = $d{name} if defined $d{name};
  		$self->{attribute_step} = $d{step} if defined $d{step};

  		if (defined $d{init_arg})
  		{
  			$self->{varname} = sprintf('$args->{%s}', B::perlstring($d{init_arg}));
  		}
  		elsif (defined $d{name})
  		{
  			$self->{varname} = sprintf('$self->{%s}', B::perlstring($d{name}));
  		}
  	}

  	return $self;
  }

  sub message
  {
  	my $e = shift;
  	$e->varname eq '$_'
  		? $e->SUPER::message
  		: sprintf('%s (in %s)', $e->SUPER::message, $e->varname);
  }

  sub _build_message
  {
  	my $e = shift;
  	$e->has_type
  		? sprintf('%s did not pass type constraint "%s"', Type::Tiny::_dd($e->value), $e->type)
  		: sprintf('%s did not pass type constraint', Type::Tiny::_dd($e->value))
  }

  *to_string = sub
  {
  	my $e = shift;
  	my $msg = $e->message;

  	my $c = $e->context;
  	$msg .= sprintf(" at %s line %s", $c->{file}||'file?', $c->{line}||'NaN') if $c;

  	my $explain = $e->explain;
  	return $msg unless @{ $explain || [] };

  	$msg .= "\n";
  	for my $line (@$explain) {
  		$msg .= "    $line\n";
  	}

  	return $msg;
  } if $] >= 5.008;

  sub explain
  {
  	my $e = shift;
  	return undef unless $e->has_type;
  	$e->type->validate_explain($e->value, $e->varname);
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Error::TypeTiny::Assertion - exception when a value fails a type constraint

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This exception is thrown when a value fails a type constraint assertion.

  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:

  =head2 Attributes

  =over

  =item C<type>

  The type constraint that was checked against. Weakened links are involved,
  so this may end up being C<undef>.

  =item C<value>

  The value that was tested.

  =item C<varname>

  The name of the variable that was checked, if known. Defaults to C<< '$_' >>.

  =item C<attribute_name>

  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will tell you which attribute (if
  your Moo is new enough).

  (Hopefully one day this will support other OO frameworks.)

  =item C<attribute_step>

  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will contain either C<< "isa check" >>
  or C<< "coercion" >> to indicate which went wrong (if your Moo is new enough).

  (Hopefully one day this will support other OO frameworks.)

  =back

  =head2 Methods

  =over

  =item C<has_type>, C<has_attribute_name>, C<has_attribute_step>

  Predicate methods.

  =item C<message>

  Overridden to add C<varname> to the message if defined.

  =item C<explain>

  Attempts to explain why the value did not pass the type constraint. Returns
  an arrayref of strings providing step-by-step reasoning; or returns undef if
  no explanation is possible.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Error::TypeTiny>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

ERROR_TYPETINY_ASSERTION

$fatpacked{"Error/TypeTiny/Compilation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_COMPILATION';
  package Error::TypeTiny::Compilation;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Error::TypeTiny::Compilation::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Compilation::VERSION   = '1.000005';
  }

  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';

  sub code        { $_[0]{code} };
  sub environment { $_[0]{environment} ||= {} };
  sub errstr      { $_[0]{errstr} };

  sub _build_message
  {
  	my $self = shift;
  	sprintf("Failed to compile source because: %s", $self->errstr);
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Error::TypeTiny::Compilation - exception for Eval::TypeTiny

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Thrown when compiling a closure fails. Common causes are problems with
  inlined type constraints, and syntax errors when coercions are given as
  strings of Perl code.

  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:

  =head2 Attributes

  =over

  =item C<code>

  The Perl source code being compiled.

  =item C<environment>

  Hashref of variables being closed over.

  =item C<errstr>

  Error message from Perl compiler.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Error::TypeTiny>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

ERROR_TYPETINY_COMPILATION

$fatpacked{"Error/TypeTiny/WrongNumberOfParameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS';
  package Error::TypeTiny::WrongNumberOfParameters;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Error::TypeTiny::WrongNumberOfParameters::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::WrongNumberOfParameters::VERSION   = '1.000005';
  }

  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';

  sub minimum    { $_[0]{minimum} };
  sub maximum    { $_[0]{maximum} };
  sub got        { $_[0]{got} };

  sub has_minimum { exists $_[0]{minimum} };
  sub has_maximum { exists $_[0]{maximum} };

  sub _build_message
  {
  	my $e = shift;
  	if ($e->has_minimum and $e->has_maximum and $e->minimum == $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	elsif ($e->has_minimum and $e->has_maximum and $e->minimum < $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d to %d",
  			$e->got,
  			$e->minimum,
  			$e->maximum,
  		);
  	}
  	elsif ($e->has_minimum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected at least %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	else
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d",
  			$e->got,
  		);
  	}
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Error::TypeTiny::WrongNumberOfParameters - exception for Type::Params

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Thrown when a Type::Params compiled check is called with the wrong number
  of parameters.

  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:

  =head2 Attributes

  =over

  =item C<minimum>

  The minimum expected number of parameters.

  =item C<maximum>

  The maximum expected number of parameters.

  =item C<got>

  The number of parameters actually passed to the compiled check.

  =back

  =head2 Methods

  =over

  =item C<has_minimum>, C<has_maximum>

  Predicate methods.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Error::TypeTiny>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS

$fatpacked{"Eval/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_TYPETINY';
  package Eval::TypeTiny;

  use strict;

  BEGIN {
  	*HAS_LEXICAL_SUBS = ($] >= 5.018) ? sub(){!!1} : sub(){!!0};
  };

  {
  	my $hlv;
  	sub HAS_LEXICAL_VARS () {
  		$hlv = !! eval {
  			require Devel::LexAlias;
  			exists(&Devel::LexAlias::lexalias);
  		} unless defined $hlv;
  		$hlv;
  	}
  }

  sub _clean_eval
  {
  	local $@;
  	local $SIG{__DIE__};
  	my $r = eval $_[0];
  	my $e = $@;
  	return ($r, $e);
  }

  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';
  our @EXPORT    = qw( eval_closure );
  our @EXPORT_OK = qw( HAS_LEXICAL_SUBS HAS_LEXICAL_VARS );

  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }

  use warnings;

  sub eval_closure
  {
  	my (%args) = @_;
  	my $src    = ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source};

  	$args{alias}  = 0 unless defined $args{alias};
  	$args{line}   = 1 unless defined $args{line};
  	$args{description} =~ s/[^\w .:-\[\]\(\)\{\}\']//g if defined $args{description};
  	$src = qq{#line $args{line} "$args{description}"\n$src} if defined $args{description} && !($^P & 0x10);
  	$args{environment} ||= {};

  #	for my $k (sort keys %{$args{environment}})
  #	{
  #		next if $k =~ /^\$/ && ref($args{environment}{$k}) =~ /^(SCALAR|REF)$/;
  #		next if $k =~ /^\@/ && ref($args{environment}{$k}) eq q(ARRAY);
  #		next if $k =~ /^\%/ && ref($args{environment}{$k}) eq q(HASH);
  #
  #		require Error::TypeTiny;
  #		Error::TypeTiny::croak("Expected a variable name and ref; got %s => %s", $k, $args{environment}{$k});
  #	}

  	my $sandpkg   = 'Eval::TypeTiny::Sandbox';
  	my $alias     = exists($args{alias}) ? $args{alias} : 0;
  	my @keys      = sort keys %{$args{environment}};
  	my $i         = 0;
  	my $source    = join "\n" => (
  		"package $sandpkg;",
  		"sub {",
  		map(_make_lexical_assignment($_, $i++, $alias), @keys),
  		$src,
  		"}",
  	);

  	_manufacture_ties() if $alias && !HAS_LEXICAL_VARS;

  	my ($compiler, $e) = _clean_eval($source);
  	if ($e)
  	{
  		chomp $e;
  		require Error::TypeTiny::Compilation;
  		"Error::TypeTiny::Compilation"->throw(
  			code        => (ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source}),
  			errstr      => $e,
  			environment => $args{environment},
  		);
  	}

  	my $code = $compiler->(@{$args{environment}}{@keys});
  	undef($compiler);

  	if ($alias && HAS_LEXICAL_VARS) {
  		Devel::LexAlias::lexalias($code, $_, $args{environment}{$_}) for grep !/^\&/, @keys;
  	}

  	return $code;
  }

  my $tmp;
  sub _make_lexical_assignment
  {
  	my ($key, $index, $alias) = @_;
  	my $name = substr($key, 1);

  	if (HAS_LEXICAL_SUBS and $key =~ /^\&/) {
  		$tmp++;
  		my $tmpname = '$__LEXICAL_SUB__'.$tmp;
  		return
  			"no warnings 'experimental::lexical_subs';".
  			"use feature 'lexical_subs';".
  			"my $tmpname = \$_[$index];".
  			"my sub $name { goto $tmpname };";
  	}

  	if (!$alias) {
  		my $sigil = substr($key, 0, 1);
  		return "my $key = $sigil\{ \$_[$index] };";
  	}
  	elsif (HAS_LEXICAL_VARS) {
  		return "my $key;";
  	}
  	else {
  		my $tieclass = {
  			'@' => 'Eval::TypeTiny::_TieArray',
  			'%' => 'Eval::TypeTiny::_TieHash',
  			'$' => 'Eval::TypeTiny::_TieScalar',
  		}->{ substr($key, 0, 1) };

  		return sprintf(
  			'tie(my(%s), "%s", $_[%d]);',
  			$key,
  			$tieclass,
  			$index,
  		);
  	}
  }

  { my $tie; sub _manufacture_ties { $tie ||= eval <<'FALLBACK'; } }
  no warnings qw(void once uninitialized numeric);

  {
  	package #
  		Eval::TypeTiny::_TieArray;
  	require Tie::Array;
  	our @ISA = qw( Tie::StdArray );
  	sub TIEARRAY {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(@$self) and return tied(@$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(@$self) and tied(@$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied @{$_[0]} },
  		q[""]    => sub { '' . tied @{$_[0]} },
  		q[0+]    => sub { 0  + tied @{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieHash;
  	require Tie::Hash;
  	our @ISA = qw( Tie::StdHash );
  	sub TIEHASH {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(%$self) and return tied(%$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(%$self) and tied(%$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied %{$_[0]} },
  		q[""]    => sub { '' . tied %{$_[0]} },
  		q[0+]    => sub { 0  + tied %{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieScalar;
  	require Tie::Scalar;
  	our @ISA = qw( Tie::StdScalar );
  	sub TIESCALAR {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied($$self) and return tied($$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied($$self) and tied($$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied ${$_[0]} },
  		q[""]    => sub { '' . tied ${$_[0]} },
  		q[0+]    => sub { 0  + tied ${$_[0]} },
  		fallback => 1,
  	;
  }

  1;
  FALLBACK

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords pragmas coderefs

  =head1 NAME

  Eval::TypeTiny - utility to evaluate a string of Perl code in a clean environment

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This module is used by Type::Tiny to compile coderefs from strings of
  Perl code, and hashrefs of variables to close over.

  =head2 Functions

  This module exports one function, which works much like the similarly named
  function from L<Eval::Closure>:

  =over

  =item C<< eval_closure(source => $source, environment => \%env, %opt) >>

  =back

  =head2 Constants

  The following constants may be exported, but are not by default.

  =over

  =item C<< HAS_LEXICAL_SUBS >>

  Boolean indicating whether Eval::TypeTiny has support for lexical subs.
  (This feature requires Perl 5.18.)

  =item C<< HAS_LEXICAL_VARS >>

  Don't worry; closing over lexical variables in the closures is always
  supported! However, if this constant is true, it means that
  L<Devel::LexAlias> is available, which makes them slightly faster than
  the fallback solution which uses tied variables. (This only makes any
  difference when the C<< alias => 1 >> option is used.)

  =back

  =head1 EVALUATION ENVIRONMENT

  The evaluation is performed in the presence of L<strict>, but the absence of
  L<warnings>. (This is different to L<Eval::Closure> which enables warnings for
  compiled closures.)

  The L<feature> pragma is not active in the evaluation environment, so the
  following will not work:

     use feature qw(say);
     use Eval::TypeTiny qw(eval_closure);

     my $say_all = eval_closure(
        source => 'sub { say for @_ }',
     );
     $say_all->("Hello", "World");

  The L<feature> pragma does not "carry over" into the stringy eval. It is
  of course possible to import pragmas into the evaluated string as part of the
  string itself:

     use Eval::TypeTiny qw(eval_closure);

     my $say_all = eval_closure(
        source => 'sub { use feature qw(say); say for @_ }',
     );
     $say_all->("Hello", "World");

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Eval::Closure>, L<Error::TypeTiny::Compilation>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

EVAL_TYPETINY

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;

  use 5.006001;
  use strict;
  use warnings;

  use Exporter::Tiny ();

  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.042';

  sub import {
  	my $me     = shift;
  	my $caller = caller;

  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;

  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };

  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}

  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;

  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Exporter::Shiny - shortcut for Exporter::Tiny

  =head1 SYNOPSIS

     use Exporter::Shiny qw( foo bar );

  Is a shortcut for:

     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );

  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:

     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };

  =head1 DESCRIPTION

  This is a very small wrapper to simplify using L<Exporter::Tiny>.

  It does the following:

  =over

  =item * Marks your package as loaded in C<< %INC >>;

  =item * Pushes any function names in the import list onto your C<< @EXPORT_OK >>; and

  =item * Pushes C<< "Exporter::Tiny" >> onto your C<< @ISA >>.

  =back

  It doesn't set up C<< %EXPORT_TAGS >> or C<< @EXPORT >>, but there's
  nothing stopping you doing that yourself.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.

  =head1 SEE ALSO

  L<Exporter::Tiny>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;

  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);

  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.042';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;

  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }

  my $_process_optlist = sub
  {
  	my $class = shift;
  	my ($global_opts, $opts, $want, $not_want) = @_;

  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;

  		($name =~ m{\A\!(/.+/[msixpodual]+)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_regexp($1, $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\!(.+)\z}) ?
  			(++$not_want->{$1}) :
  		($name =~ m{\A[:-](.+)\z}) ?
  			push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts)) :
  		($name =~ m{\A/.+/[msixpodual]+\z}) ?
  			push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
  		# else ?
  			push(@$want, $opt);
  	}
  };

  sub import
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};

  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);

  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_opts($global_opts);

  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};

  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }

  sub unimport
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	$global_opts->{is_unimport} = 1;

  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);

  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_unimport_opts($global_opts);

  	my $expando = $class->can('_exporter_expand_sub');
  	$expando = undef if $expando == \&_exporter_expand_sub;

  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};

  		if ($wanted->[1])
  		{
  			_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
  				unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
  		}

  		my %symbols = defined($expando)
  			? $class->$expando(@$wanted, $global_opts, $permitted)
  			: ($wanted->[0] => sub { "dummy" });
  		$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
  			for keys %symbols;
  	}
  }

  # Called once per import/unimport, passed the "global" import options.
  # Expected to validate the options and carp or croak if there are problems.
  # Can also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts          { 1 }
  sub _exporter_validate_unimport_opts { 1 }

  # Called after expanding a tag or regexp to merge the tag's options with
  # any sub-specific options.
  #
  sub _exporter_merge_opts
  {
  	my $class = shift;
  	my ($tag_opts, $global_opts, @stuff) = @_;

  	$tag_opts = {} unless ref($tag_opts) eq q(HASH);
  	_croak('Cannot provide an -as option for tags')
  		if exists $tag_opts->{-as};

  	my $optlist = mkopt(\@stuff);
  	for my $export (@$optlist)
  	{
  		next if defined($export->[1]) && ref($export->[1]) ne q(HASH);

  		my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
  		$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
  			if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
  		$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
  			if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
  		$export->[1] = \%sub_opts;
  	}
  	return @$optlist;
  }

  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  #
  sub _exporter_expand_tag
  {
  	no strict qw(refs);

  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};

  	return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
  		if ref($tags->{$name}) eq q(CODE);

  	return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
  		if exists $tags->{$name};

  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
  		if $name eq 'all';

  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
  		if $name eq 'default';

  	$globals->{$name} = $value || 1;
  	return;
  }

  # Given a regexp-like string, looks it up in @EXPORT_OK and returns the
  # list of matching functions.
  #
  sub _exporter_expand_regexp
  {
  	no strict qw(refs);
  	our %TRACKED;

  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $compiled = eval("qr$name");

  	my @possible = $globals->{is_unimport}
  		? keys( %{$TRACKED{$class}{$globals->{into}}} )
  		: @{"$class\::EXPORT_OK"};

  	$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
  }

  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }

  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);

  	no strict qw(refs);

  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;

  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}

  	$class->_exporter_fail(@_);
  }

  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	return if $globals->{is_unimport};
  	_croak("Could not find sub '%s' exported by %s", $name, $class);
  }

  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;

  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};

  	$name = $value->{-as} || $name;
  	unless (ref($name) eq q(SCALAR))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}

  	return ($$name = $sym)                       if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym)               if ref($into) eq q(HASH);

  	no strict qw(refs);

  	if (exists &{"$into\::$name"} and \&{"$into\::$name"} != $sym)
  	{
  		my ($level) = grep defined, $value->{-replace}, $globals->{replace}, q(0);
  		my $action = {
  			carp     => \&_carp,
  			0        => \&_carp,
  			''       => \&_carp,
  			warn     => \&_carp,
  			nonfatal => \&_carp,
  			croak    => \&_croak,
  			fatal    => \&_croak,
  			die      => \&_croak,
  		}->{$level} || sub {};

  		$action->(
  			$action == \&_croak
  				? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s"
  				: "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",
  			$into,
  			$name,
  			$_[0],
  			$class,
  		);
  	}

  	our %TRACKED;
  	$TRACKED{$class}{$into}{$name} = $sym;

  	no warnings qw(prototype);
  	$installer
  		? $installer->($globals, [$name, $sym])
  		: (*{"$into\::$name"} = $sym);
  }

  sub _exporter_uninstall_sub
  {
  	our %TRACKED;
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $into = $globals->{into};
  	ref $into and return;

  	no strict qw(refs);

  	# Cowardly refuse to uninstall a sub that differs from the one
  	# we installed!
  	my $our_coderef = $TRACKED{$class}{$into}{$name};
  	my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
  	return unless $our_coderef == $cur_coderef;

  	my $stash     = \%{"$into\::"};
  	my $old       = delete $stash->{$name};
  	my $full_name = join('::', $into, $name);
  	foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
  	{
  		next unless defined(*{$old}{$type});
  		*$full_name = *{$old}{$type};
  	}

  	delete $TRACKED{$class}{$into}{$name};
  }

  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;

  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);

  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;

  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);

  		push @out, [ $k => $v ];
  	}

  	\@out;
  }

  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords frobnicate greps regexps

  =head1 NAME

  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies

  =head1 SYNOPSIS

     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { my $n = shift; ... }
     1;

     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;

  =head1 DESCRIPTION

  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installler >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.

  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.

  Exporter::Tiny performs most of its internal duties (including resolution
  of tag names to sub names, resolution of sub names to coderefs, and
  installation of coderefs into the target package) as method calls, which
  means they can be overridden to provide interesting behaviour.

  =head2 Utility Functions

  These are really for internal use, but can be exported if you need them.

  =over

  =item C<< mkopt(\@array) >>

  Similar to C<mkopt> from L<Data::OptList>. It doesn't support all the
  fancy options that Data::OptList does (C<moniker>, C<require_unique>,
  C<must_be> and C<name_test>) but runs about 50% faster.

  =item C<< mkopt_hash(\@array) >>

  Similar to C<mkopt_hash> from L<Data::OptList>. See also C<mkopt>.

  =back

  =head1 TIPS AND TRICKS IMPORTING FROM EXPORTER::TINY

  For the purposes of this discussion we'll assume we have a module called
  C<< MyUtils >> which exports one function, C<< frobnicate >>. C<< MyUtils >>
  inherits from Exporter::Tiny.

  Many of these tricks may seem familiar from L<Sub::Exporter>. That is
  intentional. Exporter::Tiny doesn't attempt to provide every feature of
  Sub::Exporter, but where it does it usually uses a fairly similar API.

  =head2 Basic importing

     # import "frobnicate" function
     use MyUtils "frobnicate";

     # import all functions that MyUtils offers
     use MyUtils -all;

  =head2 Renaming imported functions

     # call it "frob"
     use MyUtils "frobnicate" => { -as => "frob" };

     # call it "my_frobnicate"
     use MyUtils "frobnicate" => { -prefix => "my_" };

     # can set a prefix for *all* functions imported from MyUtils
     # by placing the options hashref *first*.
     use MyUtils { prefix => "my_" }, "frobnicate";
     # (note the lack of hyphen before `prefix`.)

     # call it "frobnicate_util"
     use MyUtils "frobnicate" => { -suffix => "_util" };
     use MyUtils { suffix => "_util" }, "frobnicate";

     # import it twice with two different names
     use MyUtils
        "frobnicate" => { -as => "frob" },
        "frobnicate" => { -as => "frbnct" };

  =head2 Lexical subs

     {
        use Sub::Exporter::Lexical lexical_installer => { -as => "lex" };
        use MyUtils { installer => lex }, "frobnicate";

        frobnicate(...);  # ok
     }

     frobnicate(...);  # not ok

  =head2 Import functions into another package

     use MyUtils { into => "OtherPkg" }, "frobnicate";

     OtherPkg::frobincate(...);

  =head2 Import functions into a scalar

     my $func;
     use MyUtils "frobnicate" => { -as => \$func };

     $func->(...);

  =head2 Import functions into a hash

  OK, Sub::Exporter doesn't do this...

     my %funcs;
     use MyUtils { into => \%funcs }, "frobnicate";

     $funcs{frobnicate}->(...);

  =head2 DO NOT WANT!

  This imports everything except "frobnicate":

     use MyUtils qw( -all !frobnicate );

  Negated imports always "win", so the following will not import
  "frobnicate", no matter how many times you repeat it...

     use MyUtils qw( !frobnicate frobnicate frobnicate frobnicate );

  =head2 Importing by regexp

  Here's how you could import all functions beginning with an "f":

     use MyUtils qw( /^F/i );

  Or import everything except functions beginning with a "z":

     use MyUtils qw( -all !/^Z/i );

  Note that regexps are always supplied as I<strings> starting with
  C<< "/" >>, and not as quoted regexp references (C<< qr/.../ >>).

  =head2 Unimporting

  You can unimport the functions that MyUtils added to your namespace:

     no MyUtils;

  Or just specific ones:

     no MyUtils qw(frobnicate);

  If you renamed a function when you imported it, you should unimport by
  the new name:

     use MyUtils frobnicate => { -as => "frob" };
     ...;
     no MyUtils "frob";

  Unimporting using tags and regexps should mostly do what you want.

  =head1 TIPS AND TRICKS EXPORTING USING EXPORTER::TINY

  Simple configuration works the same as L<Exporter>; inherit from this module,
  and use the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables to list subs to export.

  =head2 Generators

  Exporter::Tiny has always allowed exported subs to be generated (like
  L<Sub::Exporter>), but until version 0.025 did not have an especially nice
  API for it.

  Now, it's easy. If you want to generate a sub C<foo> to export, list it in
  C<< @EXPORT >> or C<< @EXPORT_OK >> as usual, and then simply give your
  exporter module a class method called C<< _generate_foo >>.

     push @EXPORT_OK, 'foo';

     sub _generate_foo {
        my $class = shift;
        my ($name, $args, $globals) = @_;

        return sub {
           ...;
        }
     }

  You can also generate tags:

     my %constants;
     BEGIN {
        %constants = (FOO => 1, BAR => 2);
     }
     use constant \%constants;

     $EXPORT_TAGS{constants} = sub {
        my $class = shift;
        my ($name, $args, $globals) = @_;

        return keys(%constants);
     };

  =head2 Overriding Internals

  An important difference between L<Exporter> and Exporter::Tiny is that
  the latter calls all its internal functions as I<< class methods >>. This
  means that your subclass can I<< override them >> to alter their behaviour.

  The following methods are available to be overridden. Despite being named
  with a leading underscore, they are considered public methods. (The underscore
  is there to avoid accidentally colliding with any of your own function names.)

  =over

  =item C<< _exporter_validate_opts($globals) >>

  This method is called once each time C<import> is called. It is passed a
  reference to the global options hash. (That is, the optional leading hashref
  in the C<use> statement, where the C<into> and C<installer> options can be
  provided.)

  You may use this method to munge the global options, or validate them,
  throwing an exception or printing a warning.

  The default implementation does nothing interesting.

  =item C<< _exporter_validate_unimport_opts($globals) >>

  Like C<_exporter_validate_opts>, but called for C<unimport>.

  =item C<< _exporter_merge_opts($tag_opts, $globals, @exports) >>

  Called to merge options which have been provided for a tag into the
  options provided for the exports that the tag expanded to.

  =item C<< _exporter_expand_tag($name, $args, $globals) >>

  This method is called to expand an import tag (e.g. C<< ":constants" >>).
  It is passed the tag name (minus the leading ":"), an optional hashref
  of options (like C<< { -prefix => "foo_" } >>), and the global options
  hashref.

  It is expected to return a list of ($name, $args) arrayref pairs. These
  names can be sub names to export, or further tag names (which must have
  their ":"). If returning tag names, be careful to avoid creating a tag
  expansion loop!

  The default implementation uses C<< %EXPORT_TAGS >> to expand tags, and
  provides fallbacks for the C<< :default >> and C<< :all >> tags.

  =item C<< _exporter_expand_regexp($regexp, $args, $globals) >>

  Like C<_exporter_expand_regexp>, but given a regexp-like string instead
  of a tag name.

  The default implementation greps through C<< @EXPORT_OK >> for imports,
  and the list of already-imported functions for exports.

  =item C<< _exporter_expand_sub($name, $args, $globals) >>

  This method is called to translate a sub name to a hash of name => coderef
  pairs for exporting to the caller. In general, this would just be a hash with
  one key and one value, but, for example, L<Type::Library> overrides this
  method so that C<< "+Foo" >> gets expanded to:

     (
        Foo         => sub { $type },
        is_Foo      => sub { $type->check(@_) },
        to_Foo      => sub { $type->assert_coerce(@_) },
        assert_Foo  => sub { $type->assert_return(@_) },
     )

  The default implementation checks that the name is allowed to be exported
  (using the C<_exporter_permitted_regexp> method), gets the coderef using
  the generator if there is one (or by calling C<< can >> on your exporter
  otherwise) and calls C<_exporter_fail> if it's unable to generate or
  retrieve a coderef.

  =item C<< _exporter_permitted_regexp($globals) >>

  This method is called to retrieve a regexp for validating the names of
  exportable subs. If a sub doesn't match the regexp, then the default
  implementation of C<_exporter_expand_sub> will refuse to export it. (Of
  course, you may override the default C<_exporter_expand_sub>.)

  The default implementation of this method assembles the regexp from
  C<< @EXPORT >> and C<< @EXPORT_OK >>.

  =item C<< _exporter_fail($name, $args, $globals) >>

  Called by C<_exporter_expand_sub> if it can't find a coderef to export.

  The default implementation just throws an exception. But you could emit
  a warning instead, or just ignore the failed export.

  If you don't throw an exception then you should be aware that this
  method is called in list context, and any list it returns will be treated
  as an C<_exporter_expand_sub>-style hash of names and coderefs for
  export.

  =item C<< _exporter_install_sub($name, $args, $globals, $coderef) >>

  This method actually installs the exported sub into its new destination.
  Its return value is ignored.

  The default implementation handles sub renaming (i.e. the C<< -as >>,
  C<< -prefix >> and C<< -suffix >> functions. This method does a lot of
  stuff; if you need to override it, it's probably a good idea to just
  pre-process the arguments and then call the super method rather than
  trying to handle all of it yourself.

  =item C<< _exporter_uninstall_sub($name, $args, $globals) >>

  The opposite of C<_exporter_install_sub>.

  =back

  =head1 DIAGNOSTICS

  =over

  =item B<< Overwriting existing sub '%s::%s' with sub '%s' exported by %s >>

  A warning issued if Exporter::Tiny is asked to export a symbol which
  will result in an existing sub being overwritten. This warning can be
  suppressed using either of the following:

     use MyUtils { replace => 1 }, "frobnicate";
     use MyUtils "frobnicate" => { -replace => 1 };

  Or can be upgraded to a fatal error:

     use MyUtils { replace => "die" }, "frobnicate";
     use MyUtils "frobnicate" => { -replace => "die" };

  =item B<< Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s >>

  The fatal version of the above warning.

  =item B<< Could not find sub '%s' exported by %s >>

  You requested to import a sub which the package does not provide.

  =item B<< Cannot provide an -as option for tags >>

  Because a tag may provide more than one function, it does not make sense
  to request a single name for it. Instead use C<< -prefix >> or C<< -suffix >>.

  =item B<< Passing options to unimport '%s' makes no sense >>

  When you import a sub, it occasionally makes sense to pass some options
  for it. However, when unimporting, options do nothing, so this warning
  is issued.

  =back

  =head1 HISTORY

  L<Type::Library> had a bunch of custom exporting code which poked coderefs
  into its caller's stash. It needed this to be something more powerful than
  most exporters so that it could switch between exporting Moose, Mouse and
  Moo-compatible objects on request. L<Sub::Exporter> would have been capable,
  but had too many dependencies for the Type::Tiny project.

  Meanwhile L<Type::Utils>, L<Types::TypeTiny> and L<Test::TypeTiny> each
  used the venerable L<Exporter.pm|Exporter>. However, this meant they were
  unable to use the features like L<Sub::Exporter>-style function renaming
  which I'd built into Type::Library:

     ## import "Str" but rename it to "String".
     use Types::Standard "Str" => { -as => "String" };

  And so I decided to factor out code that could be shared by all Type-Tiny's
  exporters into a single place: Exporter::TypeTiny.

  As of version 0.026, Exporter::TypeTiny was also made available as
  L<Exporter::Tiny>, distributed independently on CPAN. CHOCOLATEBOY had
  convinced me that it was mature enough to live a life of its own.

  As of version 0.030, Type-Tiny depends on Exporter::Tiny and
  Exporter::TypeTiny is being phased out.

  =head1 OBLIGATORY EXPORTER COMPARISON

  Exporting is unlikely to be your application's performance bottleneck, but
  nonetheless here are some comparisons.

  B<< Comparative sizes according to L<Devel::SizeMe>: >>

     Exporter                     217.1Kb
     Sub::Exporter::Progressive   263.2Kb
     Exporter::Tiny               267.7Kb
     Exporter + Exporter::Heavy   281.5Kb
     Exporter::Renaming           406.2Kb
     Sub::Exporter                701.0Kb

  B<< Performance exporting a single sub: >>

                Rate     SubExp    ExpTiny SubExpProg      ExpPM
  SubExp      2489/s         --       -56%       -85%       -88%
  ExpTiny     5635/s       126%         --       -67%       -72%
  SubExpProg 16905/s       579%       200%         --       -16%
  ExpPM      20097/s       707%       257%        19%         --

  (Exporter::Renaming globally changes the behaviour of Exporter.pm, so could
  not be included in the same benchmarks.)

  B<< (Non-Core) Dependencies: >>

     Exporter                    -1
     Exporter::Renaming           0
     Exporter::Tiny               0
     Sub::Exporter::Progressive   0
     Sub::Exporter                3

  B<< Features: >>

                                        ExpPM   ExpTiny SubExp  SubExpProg
   Can export code symbols............. Yes     Yes     Yes     Yes
   Can export non-code symbols......... Yes
   Groups/tags......................... Yes     Yes     Yes     Yes
   Export by regexp.................... Yes     Yes
   Bang prefix......................... Yes     Yes
   Allows renaming of subs.............         Yes     Yes     Maybe
   Install code into scalar refs.......         Yes     Yes     Maybe
   Can be passed an "into" parameter...         Yes     Yes     Maybe
   Can be passed an "installer" sub....         Yes     Yes     Maybe
   Config avoids package variables.....                 Yes
   Supports generators.................         Yes     Yes
   Sane API for generators.............         Yes     Yes
   Unimport............................         Yes

  (Certain Sub::Exporter::Progressive features are only available if
  Sub::Exporter is installed.)

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.

  =head1 SUPPORT

  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.

  =head1 SEE ALSO

  L<Exporter::Shiny>,
  L<Sub::Exporter>,
  L<Exporter>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

EXPORTER_TINY

$fatpacked{"Reply/Plugin/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REPLY_PLUGIN_TYPETINY';
  package Reply::Plugin::TypeTiny;

  use strict;
  use warnings;

  BEGIN {
  	$Reply::Plugin::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Reply::Plugin::TypeTiny::VERSION   = '1.000005';
  };

  require Reply::Plugin;
  our @ISA = 'Reply::Plugin';

  use Scalar::Util qw(blessed);
  use Term::ANSIColor;

  sub mangle_error {
  	my $self  = shift;
  	my ($err) = @_;

  	if (blessed $err and $err->isa("Error::TypeTiny::Assertion"))
  	{
  		my $explain = $err->explain;
  		if ($explain)
  		{
  			print color("cyan");
  			print "Error::TypeTiny::Assertion explain:\n";
  			$self->_explanation($explain, "");
  			local $| = 1;
  			print "\n";
  			print color("reset");
  		}
  	}

  	return @_;
  }

  sub _explanation
  {
  	my $self = shift;
  	my ($ex, $indent)  = @_;

  	for my $line (@$ex)
  	{
  		if (ref($line) eq q(ARRAY))
  		{
  			print "$indent * Explain:\n";
  			$self->_explanation($line, "$indent   ");
  		}
  		else
  		{
  			print "$indent * $line\n";
  		}
  	}
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Reply::Plugin::TypeTiny - improved type constraint exceptions in Reply

  =head1 STATUS

  This module is not covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This is a small plugin to improve error messages in L<Reply>.
  Not massively tested.

  =begin trustme

  =item mangle_error

  =end trustme

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Error::TypeTiny::Assertion>, L<Reply>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

REPLY_PLUGIN_TYPETINY

$fatpacked{"Test/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TYPETINY';
  package Test::TypeTiny;

  use strict;
  use warnings;

  use Test::More qw();
  use Scalar::Util qw(blessed);
  use Types::TypeTiny qw(to_TypeTiny);

  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';

  BEGIN {
  	*EXTENDED_TESTING = $ENV{EXTENDED_TESTING} ? sub(){!!1} : sub(){!!0};
  };

  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';
  our @EXPORT    = qw( should_pass should_fail ok_subtype );
  our @EXPORT_OK = qw( EXTENDED_TESTING matchfor );

  sub matchfor
  {
  	my @matchers = @_;
  	bless \@matchers, do {
  		package #
  		Test::TypeTiny::Internal::MATCHFOR;
  		use overload
  			q[==] => 'match',
  			q[eq] => 'match',
  			q[""] => 'to_string',
  			fallback => 1;
  		sub to_string {
  			$_[0][0]
  		}
  		sub match {
  			my ($self, $e) = @_;
  			my $does = Scalar::Util::blessed($e) ? ($e->can('DOES') || $e->can('isa')) : undef;
  			for my $s (@$self) {
  				return 1 if  ref($s) && $e =~ $s;
  				return 1 if !ref($s) && $does && $e->$does($s);
  			}
  			return;
  		}
  		__PACKAGE__;
  	};
  }

  sub _mk_message
  {
  	require Type::Tiny;
  	my ($template, $value) = @_;
  	sprintf($template, Type::Tiny::_dd($value));
  }

  sub ok_subtype
  {
  	my ($type, @s) = @_;
  	@_ = (
  		not(scalar grep !$_->is_subtype_of($type), @s),
  		sprintf("%s subtype: %s", $type, join q[, ], @s),
  	);
  	goto \&Test::More::ok;
  }

  eval(EXTENDED_TESTING ? <<'SLOW' : <<'FAST');

  sub should_pass
  {
  	my ($value, $type, $message) = @_;

  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");

  	my $strictures = $type->can("_strict_check");

  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!!$type->check($value), '->check');
  	$test->ok(!!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }

  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");

  	local $Test::Builder::Level = $Test::Builder::Level + 1;

  	my $strictures = $type->can("_strict_check");

  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!$type->check($value), '->check');
  	$test->ok(!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }

  SLOW

  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!!$type->check($value),
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }

  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!$type->check($value),
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }

  FAST

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Test::TypeTiny - useful functions for testing the efficacy of type constraints

  =head1 SYNOPSIS

  =for test_synopsis
  BEGIN { die "SKIP: uses a module that doesn't exist as an example" };

     use strict;
     use warnings;
     use Test::More;
     use Test::TypeTiny;

     use Types::Mine qw(Integer Number);

     should_pass(1, Integer);
     should_pass(-1, Integer);
     should_pass(0, Integer);
     should_fail(2.5, Integer);

     ok_subtype(Number, Integer);

     done_testing;

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  L<Test::TypeTiny> provides a few handy functions for testing type constraints.

  =head2 Functions

  =over

  =item C<< should_pass($value, $type, $test_name) >>

  =item C<< should_pass($value, $type) >>

  Test that passes iff C<< $value >> passes C<< $type->check >>.

  =item C<< should_fail($value, $type, $test_name) >>

  =item C<< should_fail($value, $type) >>

  Test that passes iff C<< $value >> fails C<< $type->check >>.

  =item C<< ok_subtype($type, @subtypes) >>

  Test that passes iff all C<< @subtypes >> are subtypes of C<< $type >>.

  =item C<< EXTENDED_TESTING >>

  Exportable boolean constant.

  =item C<< matchfor(@things) >>

  Assistant for matching exceptions. Not exported by default.
  See also L<Test::Fatal::matchfor>.

  =back

  =head1 ENVIRONMENT

  If the C<EXTENDED_TESTING> environment variable is set to true, this
  module will promote each C<should_pass> or C<should_fail> test into a
  subtest block and test the type constraint in both an inlined and
  non-inlined manner.

  This variable must be set at compile time (i.e. before this module is
  loaded).

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny>.

  For an alternative to C<should_pass>, see L<Test::Deep::Type> which will
  happily accept a Type::Tiny type constraint instead of a MooseX::Types one.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TEST_TYPETINY

$fatpacked{"Type/Coercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION';
  package Type::Coercion;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Coercion::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::VERSION   = '1.000005';
  }

  use Eval::TypeTiny qw<>;
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny qw<>;

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	fallback   => 1,
  ;

  BEGIN {
  	require Type::Tiny;
  	overload->import(
  		q(~~)    => sub { $_[0]->has_coercion_for_value($_[1]) },
  		fallback => 1, # 5.10 loses the fallback otherwise
  	) if Type::Tiny::SUPPORT_SMARTMATCH();
  }

  sub _overload_coderef
  {
  	my $self = shift;

  	if ("Sub::Quote"->can("quote_sub") && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_coercion('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->coerce(@_) };
  	}

  	$self->{_overload_coderef};
  }

  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;

  	$params{name} = '__ANON__' unless exists($params{name});
  	my $C = delete($params{type_coercion_map}) || [];
  	my $F = delete($params{frozen});

  	my $self = bless \%params, $class;
  	$self->add_type_coercions(@$C) if @$C;
  	$self->_preserve_type_constraint;
  	Scalar::Util::weaken($self->{type_constraint}); # break ref cycle
  	$self->{frozen} = $F if $F;

  	unless ($self->is_anon)
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$self->name =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $self->name =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid coercion name', $self->name;
  	}

  	return $self;
  }

  sub name                   { $_[0]{name} }
  sub display_name           { $_[0]{display_name}      ||= $_[0]->_build_display_name }
  sub library                { $_[0]{library} }
  sub type_constraint        { $_[0]{type_constraint}   ||= $_[0]->_maybe_restore_type_constraint }
  sub type_coercion_map      { $_[0]{type_coercion_map} ||= [] }
  sub moose_coercion         { $_[0]{moose_coercion}    ||= $_[0]->_build_moose_coercion }
  sub compiled_coercion      { $_[0]{compiled_coercion} ||= $_[0]->_build_compiled_coercion }
  sub frozen                 { $_[0]{frozen}            ||= 0 }
  sub coercion_generator     { $_[0]{coercion_generator} }
  sub parameters             { $_[0]{parameters} }
  sub parameterized_from     { $_[0]{parameterized_from} }

  sub has_library            { exists $_[0]{library} }
  sub has_type_constraint    { defined $_[0]->type_constraint } # sic
  sub has_coercion_generator { exists $_[0]{coercion_generator} }
  sub has_parameters         { exists $_[0]{parameters} }

  sub _preserve_type_constraint
  {
  	my $self = shift;
  	$self->{_compiled_type_constraint_check} = $self->{type_constraint}->compiled_check
  		if $self->{type_constraint};
  }

  sub _maybe_restore_type_constraint
  {
  	my $self = shift;
  	if ( my $check = $self->{_compiled_type_constraint_check} )
  	{
  		return Type::Tiny->new(constraint => $check);
  	}
  	return;
  }

  sub add
  {
  	my $class = shift;
  	my ($x, $y, $swap) = @_;

  	Types::TypeTiny::TypeTiny->check($x) and return $x->plus_fallback_coercions($y);
  	Types::TypeTiny::TypeTiny->check($y) and return $y->plus_coercions($x);

  	_croak "Attempt to add $class to something that is not a $class"
  		unless blessed($x) && blessed($y) && $x->isa($class) && $y->isa($class);

  	($y, $x) = ($x, $y) if $swap;

  	my %opts;
  	if ($x->has_type_constraint and $y->has_type_constraint and $x->type_constraint == $y->type_constraint)
  	{
  		$opts{type_constraint} = $x->type_constraint;
  	}
  	elsif ($x->has_type_constraint and $y->has_type_constraint)
  	{
  #		require Type::Tiny::Union;
  #		$opts{type_constraint} = "Type::Tiny::Union"->new(
  #			type_constraints => [ $x->type_constraint, $y->type_constraint ],
  #		);
  	}
  	$opts{display_name} ||= "$x+$y";
  	delete $opts{display_name} if $opts{display_name} eq '__ANON__+__ANON__';

  	my $new = $class->new(%opts);
  	$new->add_type_coercions( @{$x->type_coercion_map} );
  	$new->add_type_coercions( @{$y->type_coercion_map} );
  	return $new;
  }

  sub _build_display_name
  {
  	shift->name;
  }

  sub qualified_name
  {
  	my $self = shift;

  	if ($self->has_library and not $self->is_anon)
  	{
  		return sprintf("%s::%s", $self->library, $self->name);
  	}

  	return $self->name;
  }

  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }

  sub _clear_compiled_coercion
  {
  	delete $_[0]{_overload_coderef};
  	delete $_[0]{compiled_coercion};
  }

  sub freeze                    { $_[0]{frozen} = 1; $_[0] }
  sub i_really_want_to_unfreeze { $_[0]{frozen} = 0; $_[0] }

  sub coerce
  {
  	my $self = shift;
  	return $self->compiled_coercion->(@_);
  }

  sub assert_coerce
  {
  	my $self = shift;
  	my $r = $self->coerce(@_);
  	$self->type_constraint->assert_valid($r)
  		if $self->has_type_constraint;
  	return $r;
  }

  sub has_coercion_for_type
  {
  	my $self = shift;
  	my $type = Types::TypeTiny::to_TypeTiny($_[0]);

  	return "0 but true"
  		if $self->has_type_constraint && $type->is_a_type_of($self->type_constraint);

  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $type->is_a_type_of($c->[$i]);
  	}
  	return;
  }

  sub has_coercion_for_value
  {
  	my $self = shift;
  	local $_ = $_[0];

  	return "0 but true"
  		if $self->has_type_constraint && $self->type_constraint->check(@_);

  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $c->[$i]->check(@_);
  	}
  	return;
  }

  sub add_type_coercions
  {
  	my $self = shift;
  	my @args = @_;

  	_croak "Attempt to add coercion code to a Type::Coercion which has been frozen" if $self->frozen;

  	while (@args)
  	{
  		my $type     = Types::TypeTiny::to_TypeTiny(shift @args);
  		my $coercion = shift @args;

  		_croak "Types must be blessed Type::Tiny objects"
  			unless Types::TypeTiny::TypeTiny->check($type);
  		_croak "Coercions must be code references or strings"
  			unless Types::TypeTiny::StringLike->check($coercion) || Types::TypeTiny::CodeLike->check($coercion);

  		push @{$self->type_coercion_map}, $type, $coercion;
  	}

  	$self->_clear_compiled_coercion;
  	return $self;
  }

  sub _build_compiled_coercion
  {
  	my $self = shift;

  	my @mishmash = @{$self->type_coercion_map};
  	return sub { $_[0] } unless @mishmash;

  	if ($self->can_be_inlined)
  	{
  		return Eval::TypeTiny::eval_closure(
  			source      => sprintf('sub ($) { %s }', $self->inline_coercion('$_[0]')),
  			description => sprintf("compiled coercion '%s'", $self),
  		);
  	}

  	# These arrays will be closed over.
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}

  	my @sub;

  	for my $i (0..$#types)
  	{
  		push @sub,
  			$types[$i]->can_be_inlined ? sprintf('if (%s)', $types[$i]->inline_check('$_[0]')) :
  			sprintf('if ($checks[%d]->(@_))', $i);
  		push @sub,
  			!defined($codes[$i])
  				? sprintf('  { return $_[0] }') :
  			Types::TypeTiny::StringLike->check($codes[$i])
  				? sprintf('  { local $_ = $_[0]; return scalar(%s); }', $codes[$i]) :
  			sprintf('  { local $_ = $_[0]; return scalar($codes[%d]->(@_)) }', $i);
  	}

  	push @sub, 'return $_[0];';

  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', join qq[\n], @sub),
  		description => sprintf("compiled coercion '%s'", $self),
  		environment => {
  			'@checks' => [ map $_->compiled_check, @types ],
  			'@codes'  => \@codes,
  		},
  	);
  }

  sub can_be_inlined
  {
  	my $self = shift;

  	return unless $self->frozen;

  	return
  		if $self->has_type_constraint
  		&& !$self->type_constraint->can_be_inlined;

  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type, $converter) = splice(@mishmash, 0, 2);
  		return unless $type->can_be_inlined;
  		return unless Types::TypeTiny::StringLike->check($converter);
  	}
  	return !!1;
  }

  sub _source_type_union
  {
  	my $self = shift;

  	my @r;
  	push @r, $self->type_constraint if $self->has_type_constraint;

  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type) = splice(@mishmash, 0, 2);
  		push @r, $type;
  	}

  	require Type::Tiny::Union;
  	return "Type::Tiny::Union"->new(type_constraints => \@r, tmp => 1);
  }

  sub inline_coercion
  {
  	my $self = shift;
  	my $varname = $_[0];

  	_croak "This coercion cannot be inlined" unless $self->can_be_inlined;

  	my @mishmash = @{$self->type_coercion_map};
  	return "($varname)" unless @mishmash;

  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}

  	my @sub;

  	for my $i (0..$#types)
  	{
  		push @sub, sprintf('(%s) ?', $types[$i]->inline_check($varname));
  		push @sub,
  			(defined($codes[$i]) && ($varname eq '$_'))
  				? sprintf('scalar(do { %s }) :', $codes[$i]) :
  			defined($codes[$i])
  				? sprintf('scalar(do { local $_ = %s; %s }) :', $varname, $codes[$i]) :
  			sprintf('%s :', $varname);
  	}

  	push @sub, "$varname";

  	"@sub";
  }

  sub _build_moose_coercion
  {
  	my $self = shift;

  	my %options = ();
  	$options{type_coercion_map} = [ $self->freeze->_codelike_type_coercion_map('moose_type') ];
  	$options{type_constraint}   = $self->type_constraint if $self->has_type_constraint;

  	require Moose::Meta::TypeCoercion;
  	my $r = "Moose::Meta::TypeCoercion"->new(%options);

  	return $r;
  }

  sub _codelike_type_coercion_map
  {
  	my $self = shift;
  	my $modifier = $_[0];

  	my @orig = @{ $self->type_coercion_map };
  	my @new;

  	while (@orig)
  	{
  		my ($type, $converter) = splice(@orig, 0, 2);

  		push @new, $modifier ? $type->$modifier : $type;

  		if (Types::TypeTiny::CodeLike->check($converter))
  		{
  			push @new, $converter;
  		}
  		else
  		{
  			push @new, Eval::TypeTiny::eval_closure(
  				source      => sprintf('sub { local $_ = $_[0]; %s }', $converter),
  				description => sprintf("temporary compiled converter from '%s'", $type),
  			);
  		}
  	}

  	return @new;
  }

  sub is_parameterizable
  {
  	shift->has_coercion_generator;
  }

  sub is_parameterized
  {
  	shift->has_parameters;
  }

  sub parameterize
  {
  	my $self = shift;
  	return $self unless @_;
  	$self->is_parameterizable
  		or _croak "Constraint '%s' does not accept parameters", "$self";

  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;

  	return ref($self)->new(
  		type_constraint    => $self->type_constraint,
  		type_coercion_map  => [ $self->coercion_generator->($self, $self->type_constraint, @_) ],
  		parameters         => \@_,
  		frozen             => 1,
  		parameterized_from => $self,
  	);
  }

  sub _reparameterize
  {
  	my $self = shift;
  	my ($target_type) = @_;

  	$self->is_parameterized or return $self;
  	my $parent = $self->parameterized_from;

  	return ref($self)->new(
  		type_constraint    => $target_type,
  		type_coercion_map  => [ $parent->coercion_generator->($parent, $target_type, @{$self->parameters}) ],
  		parameters         => \@_,
  		frozen             => 1,
  		parameterized_from => $parent,
  	);
  }

  sub isa
  {
  	my $self = shift;

  	if ($INC{"Moose.pm"} and blessed($self) and $_[0] eq 'Moose::Meta::TypeCoercion')
  	{
  		return !!1;
  	}

  	if ($INC{"Moose.pm"}
  	and blessed($self)
  	and $_[0] =~ /^(Class::MOP|MooseX?)::/)
  	{
  		my $r = $self->moose_coercion->isa(@_);
  		return $r if $r;
  	}

  	$self->SUPER::isa(@_);
  }

  sub can
  {
  	my $self = shift;

  	my $can = $self->SUPER::can(@_);
  	return $can if $can;

  	if ($INC{"Moose.pm"}
  	and blessed($self)
  	and my $method = $self->moose_coercion->can(@_))
  	{
  		return sub { $method->(shift->moose_coercion, @_) };
  	}

  	return;
  }

  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';

  	if ($INC{"Moose.pm"} and blessed($self) and my $method = $self->moose_coercion->can($m))
  	{
  		return $method->($self->moose_coercion, @_);
  	}

  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }

  # Private Moose method, but Moo uses this...
  sub _compiled_type_coercion
  {
  	my $self = shift;
  	if (@_)
  	{
  		my $thing = $_[0];
  		if (blessed($thing) and $thing->isa("Type::Coercion"))
  		{
  			$self->add_type_coercions(@{$thing->type_coercion_map});
  		}
  		elsif (Types::TypeTiny::CodeLike->check($thing))
  		{
  			require Types::Standard;
  			$self->add_type_coercions(Types::Standard::Any(), $thing);
  		}
  	}
  	$self->compiled_coercion;
  }

  *compile_type_coercion = \&compiled_coercion;
  sub meta { _croak("Not really a Moose::Meta::TypeCoercion. Sorry!") }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Type::Coercion - a set of coercions to a particular target type constraint

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  =head2 Constructors

  =over

  =item C<< new(%attributes) >>

  Moose-style constructor function.

  =item C<< add($c1, $c2) >>

  Create a Type::Coercion from two existing Type::Coercion objects.

  =back

  =head2 Attributes

  Attributes are named values that may be passed to the constructor. For
  each attribute, there is a corresponding reader method. For example:

     my $c = Type::Coercion->new( type_constraint => Int );
     my $t = $c->type_constraint;  # Int

  =head3 Important attributes

  These are the attributes you are likely to be most interested in
  providing when creating your own type coercions, and most interested
  in reading when dealing with coercion objects.

  =over

  =item C<type_constraint>

  Weak reference to the target type constraint (i.e. the type constraint which
  the output of coercion coderefs is expected to conform to).

  =item C<type_coercion_map>

  Arrayref of source-type/code pairs.

  =item C<frozen>

  Boolean; default false. A frozen coercion cannot have C<add_type_coercions>
  called upon it.

  =item C<name>

  A name for the coercion. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).

  Optional; if not supplied will be an anonymous coercion.

  =item C<display_name>

  A name to display for the coercion when stringified. These don't have
  to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.

  =item C<library>

  The package name of the type library this coercion is associated with.
  Optional. Informational only: setting this attribute does not install
  the coercion into the package.

  =back

  =head3 Attributes related to parameterizable and parameterized coercions

  The following attributes are used for parameterized coercions, but are not
  fully documented because they may change in the near future:

  =over

  =item C<< coercion_generator >>

  =item C<< parameters >>

  =item C<< parameterized_from >>

  =back

  =head3 Lazy generated attributes

  The following attributes should not be usually passed to the constructor;
  unless you're doing something especially unusual, you should rely on the
  default lazily-built return values.

  =over

  =item C<< compiled_coercion >>

  Coderef to coerce a value (C<< $_[0] >>).

  The general point of this attribute is that you should not set it, but
  rely on the lazily-built default. Type::Coerce will usually generate a
  pretty fast coderef, inlining all type constraint checks, etc.

  =item C<moose_coercion>

  A L<Moose::Meta::TypeCoercion> object equivalent to this one. Don't set this
  manually; rely on the default built one.

  =back

  =head2 Methods

  =head3 Predicate methods

  These methods return booleans indicating information about the coercion.
  They are each tightly associated with a particular attribute.
  (See L</"Attributes">.)

  =over

  =item C<has_type_constraint>, C<has_library>

  Simple Moose-style predicate methods indicating the presence or
  absence of an attribute.

  =item C<is_anon>

  Returns true iff the coercion does not have a C<name>.

  =back

  The following predicates are used for parameterized coercions, but are not
  fully documented because they may change in the near future:

  =over

  =item C<< has_coercion_generator >>

  =item C<< has_parameters >>

  =item C<< is_parameterizable >>

  =item C<< is_parameterized >>

  =back

  =head3 Coercion

  The following methods are used for coercing values to a type constraint:

  =over

  =item C<< coerce($value) >>

  Coerce the value to the target type.

  Returns the coerced value, or the original value if no coercion was
  possible.

  =item C<< assert_coerce($value) >>

  Coerce the value to the target type, and throw an exception if the result
  does not validate against the target type constraint.

  Returns the coerced value.

  =back

  =head3 Coercion code definition methods

  These methods all return C<< $self >> so are suitable for chaining.

  =over

  =item C<< add_type_coercions($type1, $code1, ...) >>

  Takes one or more pairs of L<Type::Tiny> constraints and coercion code,
  creating an ordered list of source types and coercion codes.

  Coercion codes can be expressed as either a string of Perl code (this
  includes objects which overload stringification), or a coderef (or object
  that overloads coderefification). In either case, the value to be coerced
  is C<< $_ >>.

  C<< add_type_coercions($coercion_object) >> also works, and can be used
  to copy coercions from another type constraint:

     $type->coercion->add_type_coercions($othertype->coercion)->freeze;

  =item C<< freeze >>

  Sets the C<frozen> attribute to true. Called automatically by L<Type::Tiny>
  sometimes.

  =item C<< i_really_want_to_unfreeze >>

  If you really want to unfreeze a coercion, call this method.

  Don't call this method. It will potentially lead to subtle bugs.

  This method is considered unstable; future versions of Type::Tiny may
  alter its behaviour (e.g. to throw an exception if it has been detected
  that unfreezing this particular coercion will cause bugs).

  =back

  =head3 Parameterization

  The following method is used for parameterized coercions, but is not
  fully documented because it may change in the near future:

  =over

  =item C<< parameterize(@params) >>

  =back

  =head3 Type coercion introspection methods

  These methods allow you to determine a coercion's relationship to type
  constraints:

  =over

  =item C<< has_coercion_for_type($source_type) >>

  Returns true iff this coercion has a coercion from the source type.

  Returns the special string C<< "0 but true" >> if no coercion should
  actually be necessary for this type. (For example, if a coercion coerces
  to a theoretical "Number" type, there is probably no coercion necessary
  for values that already conform to the "Integer" type.)

  =item C<< has_coercion_for_value($value) >>

  Returns true iff the value could be coerced by this coercion.

  Returns the special string C<< "0 but true" >> if no coercion would be
  actually be necessary for this value (due to it already meeting the target
  type constraint).

  =back

  The C<type_constraint> attribute provides a type constraint object for the
  target type constraint of the coercion. See L</"Attributes">.

  =head3 Inlining methods

  =for stopwords uated

  The following methods are used to generate strings of Perl code which
  may be pasted into stringy C<eval>uated subs to perform type coercions:

  =over

  =item C<< can_be_inlined >>

  Returns true iff the coercion can be inlined.

  =item C<< inline_coercion($varname) >>

  Much like C<inline_coerce> from L<Type::Tiny>.

  =back

  =head3 Other methods

  =over

  =item C<< qualified_name >>

  For non-anonymous coercions that have a library, returns a qualified
  C<< "MyLib::MyCoercion" >> sort of name. Otherwise, returns the same
  as C<name>.

  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>

  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeCoercion.

  =back

  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.

  =over

  =item C<< compile_type_coercion >>

  =item C<< meta >>

  =back

  =head2 Overloading

  =over

  =item *

  Boolification is overloaded to always return true.

  =item *

  Coderefification is overloaded to call C<coerce>.

  =item *

  On Perl 5.10.1 and above, smart match is overloaded to call C<has_coercion_for_value>.

  =back

  Previous versions of Type::Coercion would overload the C<< + >> operator
  to call C<add>. Support for this was dropped after 0.040.

  =head1 DIAGNOSTICS

  =over

  =item B<< Attempt to add coercion code to a Type::Coercion which has been frozen >>

  Type::Tiny type constraints are designed as immutable objects. Once you've
  created a constraint, rather than modifying it you generally create child
  constraints to do what you need.

  Type::Coercion objects, on the other hand, are mutable. Coercion routines
  can be added at any time during the object's lifetime.

  Sometimes Type::Tiny needs to freeze a Type::Coercion object to prevent this.
  In L<Moose> and L<Mouse> code this is likely to happen as soon as you use a
  type constraint in an attribute.

  Workarounds:

  =over

  =item *

  Define as many of your coercions as possible within type libraries, not
  within the code that uses the type libraries. The type library will be
  evaluated relatively early, likely before there is any reason to freeze
  a coercion.

  =item *

  If you do need to add coercions to a type within application code outside
  the type library, instead create a subtype and add coercions to that. The
  C<plus_coercions> method provided by L<Type::Tiny> should make this simple.

  =back

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Types::Standard>.

  L<Type::Coercion::Union>.

  L<Moose::Meta::TypeCoercion>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.


TYPE_COERCION

$fatpacked{"Type/Coercion/FromMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_FROMMOOSE';
  package Type::Coercion::FromMoose;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Coercion::FromMoose::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::FromMoose::VERSION   = '1.000005';
  }

  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  require Type::Coercion;
  our @ISA = 'Type::Coercion';

  sub type_coercion_map
  {
  	my $self = shift;

  	my @from;
  	if ($self->type_constraint)
  	{
  		my $moose = $self->type_constraint->{moose_type};
  		@from = @{ $moose->coercion->type_coercion_map } if $moose && $moose->has_coercion;
  	}
  	else
  	{
  		_croak "The type constraint attached to this coercion has been garbage collected... PANIC";
  	}

  	my @return;
  	while (@from)
  	{
  		my ($type, $code) = splice(@from, 0, 2);
  		$type = Moose::Util::TypeConstraints::find_type_constraint($type)
  			unless ref $type;
  		push @return, Types::TypeTiny::to_TypeTiny($type), $code;
  	}

  	return \@return;
  }

  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::FromMoose not currently supported" if @_;
  }

  sub _build_moose_coercion
  {
  	my $self = shift;

  	if ($self->type_constraint)
  	{
  		my $moose = $self->type_constraint->{moose_type};
  		return $moose->coercion if $moose && $moose->has_coercion;
  	}

  	$self->SUPER::_build_moose_coercion(@_);
  }

  sub can_be_inlined
  {
  	0;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Type::Coercion::FromMoose - a set of coercions borrowed from Moose

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  Moose.

  This is mostly for internal purposes.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Coercion>.

  L<Moose::Meta::TypeCoercion>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_COERCION_FROMMOOSE

$fatpacked{"Type/Coercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_UNION';
  package Type::Coercion::Union;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Coercion::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::Union::VERSION   = '1.000005';
  }

  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  require Type::Coercion;
  our @ISA = 'Type::Coercion';

  sub _preserve_type_constraint
  {
  	my $self = shift;
  	$self->{_union_of} = $self->{type_constraint}->type_constraints
  		if $self->{type_constraint};
  }

  sub _maybe_restore_type_constraint
  {
  	my $self = shift;
  	if ( my $union = $self->{_union_of} )
  	{
  		return Type::Tiny::Union->new(type_constraints => $union);
  	}
  	return;
  }

  sub type_coercion_map
  {
  	my $self = shift;

  	Types::TypeTiny::TypeTiny->assert_valid(my $type = $self->type_constraint);
  	$type->isa('Type::Tiny::Union')
  		or _croak "Type::Coercion::Union must be used in conjunction with Type::Tiny::Union";

  	my @c;
  	for my $tc (@$type)
  	{
  		next unless $tc->has_coercion;
  		push @c, @{$tc->coercion->type_coercion_map};
  	}
  	return \@c;
  }

  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::Union not currently supported" if @_;
  }

  sub _build_moose_coercion
  {
  	my $self = shift;

  	my %options = ();
  	$options{type_constraint} = $self->type_constraint if $self->has_type_constraint;

  	require Moose::Meta::TypeCoercion::Union;
  	my $r = "Moose::Meta::TypeCoercion::Union"->new(%options);

  	return $r;
  }

  sub can_be_inlined
  {
  	my $self = shift;

  	Types::TypeTiny::TypeTiny->assert_valid(my $type = $self->type_constraint);

  	for my $tc (@$type)
  	{
  		next unless $tc->has_coercion;
  		return !!0 unless $tc->coercion->can_be_inlined;
  	}

  	!!1;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Type::Coercion::Union - a set of coercions to a union type constraint

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  the child constraints of the union type constraint.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Coercion>.

  L<Moose::Meta::TypeCoercion::Union>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_COERCION_UNION

$fatpacked{"Type/Library.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_LIBRARY';
  package Type::Library;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Library::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Library::VERSION   = '1.000005';
  }

  use Eval::TypeTiny qw< eval_closure >;
  use Scalar::Util qw< blessed refaddr >;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny >;

  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';

  BEGIN { *NICE_PROTOTYPES = ($] >= 5.014) ? sub () { !!1 } : sub () { !!0 } };

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  {
  	my $got_subname;
  	my %already; # prevent renaming established functions
  	sub _subname ($$)
  	{
  		($got_subname or eval "require Sub::Name")
  			and ($got_subname = 1)
  			and !$already{refaddr($_[1])}++
  			and return(Sub::Name::subname(@_));
  		return $_[1];
  	}
  }

  sub _exporter_validate_opts
  {
  	my $class = shift;

  	no strict "refs";
  	my $into  = $_[0]{into};
  	push @{"$into\::ISA"}, $class if $_[0]{base};

  	return $class->SUPER::_exporter_validate_opts(@_);
  }

  sub _exporter_expand_tag
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;

  	$name eq 'types'     and return map [ "$_"        => $value ], $class->type_names;
  	$name eq 'is'        and return map [ "is_$_"     => $value ], $class->type_names;
  	$name eq 'assert'    and return map [ "assert_$_" => $value ], $class->type_names;
  	$name eq 'to'        and return map [ "to_$_"     => $value ], $class->type_names;
  	$name eq 'coercions' and return map [ "$_"        => $value ], $class->coercion_names;

  	if ($name eq 'all')
  	{
  		no strict "refs";
  		return (
  			map(
  				[ "+$_" => $value ],
  				$class->type_names,
  			),
  			map(
  				[ $_ => $value ],
  				$class->coercion_names,
  				@{"$class\::EXPORT"},
  				@{"$class\::EXPORT_OK"},
  			),
  		);
  	}

  	return $class->SUPER::_exporter_expand_tag(@_);
  }

  sub _mksub
  {
  	my $class = shift;
  	my ($type, $post_method) = @_;
  	$post_method ||= q();

  	my $source = $type->is_parameterizable
  		? sprintf(
  			q{
  				sub (%s) {
  					return $_[0]->complete($type) if ref($_[0]) eq 'Type::Tiny::_HalfOp';
  					my $params; $params = shift if ref($_[0]) eq q(ARRAY);
  					my $t = $params ? $type->parameterize(@$params) : $type;
  					@_ && wantarray ? return($t%s, @_) : return $t%s;
  				}
  			},
  			NICE_PROTOTYPES ? q(;$) : q(;@),
  			$post_method,
  			$post_method,
  		)
  		: sprintf(
  			q{ sub () { $type%s if $] } },
  			$post_method,
  		);

  	return _subname(
  		$type->qualified_name,
  		eval_closure(
  			source      => $source,
  			description => sprintf("exportable function '%s'", $type),
  			environment => {'$type' => \$type},
  		),
  	);
  }

  sub _exporter_permitted_regexp
  {
  	my $class = shift;

  	my $inherited = $class->SUPER::_exporter_permitted_regexp(@_);
  	my $types = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->type_names;
  	my $coercions = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->coercion_names;

  	qr{^(?:
  		$inherited
  		| (?: (?:is_|to_|assert_)? (?:$types) )
  		| (?:$coercions)
  	)$}xms;
  }

  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;

  	if ($name =~ /^\+(.+)/ and $class->has_type($1))
  	{
  		my $type   = $1;
  		my $value2 = +{%{$value||{}}};

  		return map $class->_exporter_expand_sub($_, $value2, $globals),
  			$type, "is_$type", "assert_$type", "to_$type";
  	}

  	if (my $type = $class->get_type($name))
  	{
  		my $post_method = q();
  		$post_method = '->mouse_type' if $globals->{mouse};
  		$post_method = '->moose_type' if $globals->{moose};
  		return ($name => $class->_mksub($type, $post_method)) if $post_method;
  	}

  	return $class->SUPER::_exporter_expand_sub(@_);
  }

  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;

  	my $package = $globals->{into};

  	if (!ref $package and my $type = $class->get_type($name))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		my $as = $prefix . ($value->{-as} || $name) . $suffix;

  		$INC{'Type/Registry.pm'}
  			? 'Type::Registry'->for_class($package)->add_type($type, $as)
  			: ($Type::Registry::DELAYED{$package}{$as} = $type);
  	}

  	$class->SUPER::_exporter_install_sub(@_);
  }

  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;

  	my $into = $globals->{into}
  		or _croak("Parameter 'into' not supplied");

  	if ($globals->{declare})
  	{
  		my $declared = sub (;$)
  		{
  			my $params; $params = shift if ref($_[0]) eq "ARRAY";
  			my $type = $into->get_type($name);
  			unless ($type)
  			{
  				_croak "Cannot parameterize a non-existant type" if $params;
  				$type = $name;
  			}

  			my $t = $params ? $type->parameterize(@$params) : $type;
  			@_ && wantarray ? return($t, @_) : return $t;
  		};

  		return(
  			$name,
  			_subname(
  				"$class\::$name",
  				NICE_PROTOTYPES ? sub (;$) { goto $declared } : sub (;@) { goto $declared },
  			),
  		);
  	}

  	return $class->SUPER::_exporter_fail(@_);
  }

  sub meta
  {
  	no strict "refs";
  	no warnings "once";
  	return $_[0] if blessed $_[0];
  	${"$_[0]\::META"} ||= bless {}, $_[0];
  }

  sub add_type
  {
  	my $meta  = shift->meta;
  	my $class = blessed($meta);

  	my $type =
  		ref($_[0]) =~ /^Type::Tiny\b/  ? $_[0] :
  		blessed($_[0])                 ? to_TypeTiny($_[0]) :
  		ref($_[0]) eq q(HASH)          ? "Type::Tiny"->new(library => $class, %{$_[0]}) :
  		"Type::Tiny"->new(library => $class, @_);
  	my $name = $type->{name};

  	$meta->{types} ||= {};
  	_croak 'Type %s already exists in this library', $name if $meta->has_type($name);
  	_croak 'Type %s conflicts with coercion of same name', $name if $meta->has_coercion($name);
  	_croak 'Cannot add anonymous type to a library' if $type->is_anon;
  	$meta->{types}{$name} = $type;

  	no strict "refs";
  	no warnings "redefine", "prototype";

  	my $to_type = $type->has_coercion && $type->coercion->frozen
  		? $type->coercion->compiled_coercion
  		: sub ($) { $type->coerce($_[0]) };

  	*{"$class\::$name"}        = $class->_mksub($type);
  	*{"$class\::is_$name"}     = _subname "$class\::is_$name", $type->compiled_check;
  	*{"$class\::to_$name"}     = _subname "$class\::to_$name", $to_type;
  	*{"$class\::assert_$name"} = _subname "$class\::assert_$name", $type->_overload_coderef;

  	return $type;
  }

  sub get_type
  {
  	my $meta = shift->meta;
  	$meta->{types}{$_[0]};
  }

  sub has_type
  {
  	my $meta = shift->meta;
  	exists $meta->{types}{$_[0]};
  }

  sub type_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{types} };
  }

  sub add_coercion
  {
  	require Type::Coercion;
  	my $meta = shift->meta;
  	my $c    = blessed($_[0]) ? $_[0] : "Type::Coercion"->new(@_);
  	my $name = $c->name;

  	$meta->{coercions} ||= {};
  	_croak 'Coercion %s already exists in this library', $name if $meta->has_coercion($name);
  	_croak 'Coercion %s conflicts with type of same name', $name if $meta->has_type($name);
  	_croak 'Cannot add anonymous type to a library' if $c->is_anon;
  	$meta->{coercions}{$name} = $c;

  	no strict "refs";
  	no warnings "redefine", "prototype";

  	my $class = blessed($meta);
  	*{"$class\::$name"} = $class->_mksub($c);

  	return $c;
  }

  sub get_coercion
  {
  	my $meta = shift->meta;
  	$meta->{coercions}{$_[0]};
  }

  sub has_coercion
  {
  	my $meta = shift->meta;
  	exists $meta->{coercions}{$_[0]};
  }

  sub coercion_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{coercions} };
  }

  sub make_immutable
  {
  	my $meta  = shift->meta;
  	my $class = ref($meta);

  	for my $type (values %{$meta->{types}})
  	{
  		$type->coercion->freeze;

  		no strict "refs";
  		no warnings "redefine", "prototype";

  		my $to_type = $type->has_coercion && $type->coercion->frozen
  			? $type->coercion->compiled_coercion
  			: sub ($) { $type->coerce($_[0]) };
  		my $name = $type->name;

  		*{"$class\::to_$name"} = _subname "$class\::to_$name", $to_type;
  	}

  	1;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords Moo(se)-compatible MooseX::Types-like

  =head1 NAME

  Type::Library - tiny, yet Moo(se)-compatible type libraries

  =head1 SYNOPSIS

  =for test_synopsis
  BEGIN { die "SKIP: crams multiple modules into single example" };

     package Types::Mine {
        use Scalar::Util qw(looks_like_number);
        use Type::Library -base;
        use Type::Tiny;

        my $NUM = "Type::Tiny"->new(
           name       => "Number",
           constraint => sub { looks_like_number($_) },
           message    => sub { "$_ ain't a number" },
        );

        __PACKAGE__->meta->add_type($NUM);

        __PACKAGE__->meta->make_immutable;
     }

     package Ermintrude {
        use Moo;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }

     package Bullwinkle {
        use Moose;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }

     package Maisy {
        use Mouse;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  L<Type::Library> is a tiny class for creating MooseX::Types-like type
  libraries which are compatible with Moo, Moose and Mouse.

  If you're reading this because you want to create a type library, then
  you're probably better off reading L<Type::Tiny::Manual::Libraries>.

  =head2 Methods

  A type library is a singleton class. Use the C<meta> method to get a blessed
  object which other methods can get called on. For example:

     Types::Mine->meta->add_type($foo);

  =begin trustme

  =item meta

  =end trustme

  =over

  =item C<< add_type($type) >> or C<< add_type(%opts) >>

  Add a type to the library. If C<< %opts >> is given, then this method calls
  C<< Type::Tiny->new(%opts) >> first, and adds the resultant type.

  Adding a type named "Foo" to the library will automatically define four
  functions in the library's namespace:

  =over

  =item C<< Foo >>

  Returns the Type::Tiny object.

  =item C<< is_Foo($value) >>

  Returns true iff $value passes the type constraint.

  =item C<< assert_Foo($value) >>

  Returns $value iff $value passes the type constraint. Dies otherwise.

  =item C<< to_Foo($value) >>

  Coerces the value to the type.

  =back

  =item C<< get_type($name) >>

  Gets the C<Type::Tiny> object corresponding to the name.

  =item C<< has_type($name) >>

  Boolean; returns true if the type exists in the library.

  =item C<< type_names >>

  List all types defined by the library.

  =item C<< add_coercion($c) >> or C<< add_coercion(%opts) >>

  Add a standalone coercion to the library. If C<< %opts >> is given, then
  this method calls C<< Type::Coercion->new(%opts) >> first, and adds the
  resultant coercion.

  Adding a coercion named "FooFromBar" to the library will automatically
  define a function in the library's namespace:

  =over

  =item C<< FooFromBar >>

  Returns the Type::Coercion object.

  =back

  =item C<< get_coercion($name) >>

  Gets the C<Type::Coercion> object corresponding to the name.

  =item C<< has_coercion($name) >>

  Boolean; returns true if the coercion exists in the library.

  =item C<< coercion_names >>

  List all standalone coercions defined by the library.

  =item C<< import(@args) >>

  Type::Library-based libraries are exporters.

  =item C<< make_immutable >>

  A shortcut for calling C<< $type->coercion->freeze >> on every
  type constraint in the library.

  =back

  =head2 Constants

  =over

  =item C<< NICE_PROTOTYPES >>

  If this is true, then Type::Library will give parameterizable type constraints
  slightly the nicer prototype of C<< (;$) >> instead of the default C<< (;@) >>.
  This allows constructs like:

     ArrayRef[Int] | HashRef[Int]

  ... to "just work".

  =back

  =head2 Export

  Type libraries are exporters. For the purposes of the following examples,
  assume that the C<Types::Mine> library defines types C<Number> and C<String>.

     # Exports nothing.
     #
     use Types::Mine;

     # Exports a function "String" which is a constant returning
     # the String type constraint.
     #
     use Types::Mine qw( String );

     # Exports both String and Number as above.
     #
     use Types::Mine qw( String Number );

     # Same.
     #
     use Types::Mine qw( :types );

     # Exports a sub "is_String" so that "is_String($foo)" is equivalent
     # to "String->check($foo)".
     #
     use Types::Mine qw( is_String );

     # Exports "is_String" and "is_Number".
     #
     use Types::Mine qw( :is );

     # Exports a sub "assert_String" so that "assert_String($foo)" is
     # equivalent to "String->assert_return($foo)".
     #
     use Types::Mine qw( assert_String );

     # Exports "assert_String" and "assert_Number".
     #
     use Types::Mine qw( :assert );

     # Exports a sub "to_String" so that "to_String($foo)" is equivalent
     # to "String->coerce($foo)".
     #
     use Types::Mine qw( to_String );

     # Exports "to_String" and "to_Number".
     #
     use Types::Mine qw( :to );

     # Exports "String", "is_String", "assert_String" and "coerce_String".
     #
     use Types::Mine qw( +String );

     # Exports everything.
     #
     use Types::Mine qw( :all );

  Type libraries automatically inherit from L<Exporter::Tiny>; see the
  documentation of that module for tips and tricks importing from libraries.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.

  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.


TYPE_LIBRARY

$fatpacked{"Type/Params.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARAMS';
  package Type::Params;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }

  BEGIN {
  	$Type::Params::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Params::VERSION   = '1.000005';
  }

  use B qw();
  use Eval::TypeTiny;
  use Scalar::Util qw(refaddr);
  use Error::TypeTiny;
  use Error::TypeTiny::Assertion;
  use Error::TypeTiny::WrongNumberOfParameters;
  use Type::Tiny::Union;
  use Types::Standard -types;
  use Types::TypeTiny qw(CodeLike ArrayLike to_TypeTiny);

  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';

  our @EXPORT = qw( compile );
  our @EXPORT_OK = qw( multisig validate Invocant );

  BEGIN {
  	my $Invocant = 'Type::Tiny::Union'->new(
  		name             => 'Invocant',
  		type_constraints => [Object, ClassName],
  	);
  	sub Invocant () { $Invocant };
  };

  sub _mkslurpy
  {
  	my ($name, $type, $tc, $i) = @_;
  	$name = 'local $_' if $name eq '$_';

  	$type eq '@'
  		? sprintf(
  			'%s = [ @_[%d..$#_] ];',
  			$name,
  			$i,
  		)
  		: sprintf(
  			'%s = (($#_-%d)%%2)==0 ? "Error::TypeTiny::WrongNumberOfParameters"->throw(message => sprintf("Odd number of elements in %%s", %s)) : +{ @_[%d..$#_] };',
  			$name,
  			$i,
  			B::perlstring("$tc"),
  			$i,
  		);
  }

  sub compile
  {
  	my (@code, %env);
  	@code = 'my (@R, %tmp, $tmp);';
  	push @code, '#placeholder';   # $code[1]

  	my %options    = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my $arg        = -1;
  	my $saw_slurpy = 0;
  	my $min_args   = 0;
  	my $max_args   = 0;
  	my $saw_opt    = 0;

  	while (@_)
  	{
  		++$arg;
  		my $constraint = shift;
  		my $is_optional;
  		my $really_optional;
  		my $is_slurpy;
  		my $varname;

  		if (Bool->check($constraint))
  		{
  			$constraint = $constraint ? Any : Optional[Any];
  		}

  		if (HashRef->check($constraint))
  		{
  			$constraint = to_TypeTiny($constraint->{slurpy});
  			push @code,
  				$constraint->is_a_type_of(Dict)     ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Map)      ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Tuple)    ? _mkslurpy('$_', '@', $constraint => $arg) :
  				$constraint->is_a_type_of(HashRef)  ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(ArrayRef) ? _mkslurpy('$_', '@', $constraint => $arg) :
  				Error::TypeTiny::croak("Slurpy parameter not of type HashRef or ArrayRef");
  			$varname = '$_';
  			$is_slurpy++;
  			$saw_slurpy++;
  		}
  		else
  		{
  			Error::TypeTiny::croak("Parameter following slurpy parameter") if $saw_slurpy;

  			$is_optional     = grep $_->{uniq} == Optional->{uniq}, $constraint->parents;
  			$really_optional = $is_optional && $constraint->parent->{uniq} eq Optional->{uniq} && $constraint->type_parameter;

  			if ($is_optional)
  			{
  				push @code, sprintf 'return @R if $#_ < %d;', $arg;
  				$saw_opt++;
  				$max_args++;
  			}
  			else
  			{
  				Error::TypeTiny::croak("Non-Optional parameter following Optional parameter") if $saw_opt;
  				$min_args++;
  				$max_args++;
  			}

  			$varname = sprintf '$_[%d]', $arg;
  		}

  		if ($constraint->has_coercion and $constraint->coercion->can_be_inlined)
  		{
  			push @code, sprintf(
  				'$tmp%s = %s;',
  				($is_optional ? '{x}' : ''),
  				$constraint->coercion->inline_coercion($varname)
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		elsif ($constraint->has_coercion)
  		{
  			$env{'@coerce'}[$arg] = $constraint->coercion->compiled_coercion;
  			push @code, sprintf(
  				'$tmp%s = $coerce[%d]->(%s);',
  				($is_optional ? '{x}' : ''),
  				$arg,
  				$varname,
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}

  		if ($constraint->can_be_inlined)
  		{
  			push @code, sprintf(
  				'(%s) or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				$really_optional
  					? $constraint->type_parameter->inline_check($varname)
  					: $constraint->inline_check($varname),
  				$constraint->{uniq},
  				B::perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		else
  		{
  			$env{'@check'}[$arg] = $really_optional
  				? $constraint->type_parameter->compiled_check
  				: $constraint->compiled_check;
  			push @code, sprintf(
  				'%s or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				sprintf(sprintf '$check[%d]->(%s)', $arg, $varname),
  				$constraint->{uniq},
  				B::perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}

  		push @code, sprintf 'push @R, %s;', $varname;
  	}

  	if ($min_args == $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ != %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  		);
  	}
  	elsif ($min_args < $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ < %d || @_ > %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  			$max_args,
  		);
  	}
  	elsif ($min_args and $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d) if @_ < %d;',
  			$min_args,
  			$min_args,
  		);
  	}

  	push @code, '@R;';

  	my $source  = "sub { no warnings; ".join("\n", @code)." };";

  	return $source if $options{want_source};

  	my $closure = eval_closure(
  		source      => $source,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => \%env,
  	);

  	return {
  		min_args   => $min_args,
  		max_args   => $saw_slurpy ? undef : $max_args,
  		closure    => $closure,
  	} if $options{want_details};

  	return $closure;
  }

  my %compiled;
  sub validate
  {
  	my $arr = shift;
  	my $sub = $compiled{ join ":", map($_->{uniq}||"\@$_->{slurpy}", @_) } ||= compile({ caller_level => 1 }, @_);
  	@_ = @$arr;
  	goto $sub;
  }

  sub multisig
  {
  	my %options = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my @multi = map {
  		CodeLike->check($_)  ? { closure => $_ } :
  		ArrayLike->check($_) ? compile({ want_details => 1 }, @$_) :
  		$_;
  	} @_;

  	my @code = 'sub { my $r; ';

  	for my $i (0 .. $#multi)
  	{
  		my $sig = $multi[$i];
  		my @cond;
  		push @cond, sprintf('@_ >= %s', $sig->{min_args}) if defined $sig->{min_args};
  		push @cond, sprintf('@_ <= %s', $sig->{max_args}) if defined $sig->{max_args};
  		push @code, sprintf('if (%s){', join(' and ', @cond)) if @cond;
  		push @code, sprintf('eval { $r = [ $multi[%d]{closure}->(@_) ] };', $i);
  		push @code, 'return(@$r) if $r;';
  		push @code, '}' if @cond;
  	}

  	push @code, '"Error::TypeTiny"->throw(message => "Parameter validation failed");';
  	push @code, '}';

  	eval_closure(
  		source      => \@code,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => { '@multi' => \@multi },
  	);
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords evals

  =head1 NAME

  Type::Params - Params::Validate-like parameter validation using Type::Tiny type constraints and coercions

  =head1 SYNOPSIS

   use v5.10;
   use strict;
   use warnings;

   use Type::Params qw( compile );
   use Types::Standard qw( slurpy Str ArrayRef Num );

   sub deposit_monies
   {
      state $check = compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);

      my $account = Local::BankAccount->new($sort_code, $account_number);
      $account->deposit($_) for @$monies;
   }

   deposit_monies("12-34-56", "11223344", 1.2, 3, 99.99);

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Type::Params uses L<Type::Tiny> constraints to validate the parameters to a
  sub. It takes the slightly unorthodox approach of separating validation
  into two stages:

  =over

  =item 1.

  Compiling the parameter specification into a coderef; then

  =item 2.

  Using the coderef to validate parameters.

  =back

  The first stage is slow (it might take a couple of milliseconds), but you
  only need to do it the first time the sub is called. The second stage is
  fast; according to my benchmarks faster even than the XS version of
  L<Params::Validate>.

  If you're using a modern version of Perl, you can use the C<state> keyword
  which was a feature added to Perl in 5.10. If you're stuck on Perl 5.8, the
  example from the SYNOPSIS could be rewritten as:

   my $deposit_monies_check;
   sub deposit_monies
   {
      $deposit_monies_check ||= compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);

      ...;
   }

  Not quite as neat, but not awful either.

  There's a shortcut reducing it to one step:

   use Type::Params qw( validate );

   sub deposit_monies
   {
      my ($sort_code, $account_number, $monies) =
         validate( \@_, Str, Str, slurpy ArrayRef[Num] );

      ...;
   }

  Type::Params has a few tricks up its sleeve to make sure performance doesn't
  suffer too much with the shortcut, but it's never going to be as fast as the
  two stage compile/execute.

  =begin trustme

  Dude, these functions are documented!

  =item compile

  =item validate

  =item Invocant

  =item multisig

  =end trustme

  =head1 COOKBOOK

  =head2 Positional Parameters

     sub nth_root
     {
        state $check = compile( Num, Num );
        my ($x, $n) = $check->(@_);

        return $x ** (1 / $n);
     }

  =head2 Method Calls

  Type::Params exports an additional keyword C<Invocant> on request. This is
  a type constraint accepting blessed objects and also class names.

     use Types::Standard qw( ClassName Object Str Int );
     use Type::Params qw( compile Invocant );

     # a class method
     sub new_from_json
     {
        state $check = compile( ClassName, Str );
        my ($class, $json) = $check->(@_);

        $class->new( from_json($json) );
     }

     # an object method
     sub dump
     {
        state $check = compile( Object, Int );
        my ($self, $limit) = $check->(@_);

        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }

     # can be called as either and object or class method
     sub run
     {
        state $check = compile( Invocant );
        my ($proto) = $check->(@_);

        my $self = ref($proto) ? $proto : $default_instance;
        $self->_run;
     }

  =head2 Optional Parameters

     use Types::Standard qw( Object Optional Int );

     sub dump
     {
        state $check = compile( Object, Optional[Int] );
        my ($self, $limit) = $check->(@_);
        $limit //= 0;

        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }

     $obj->dump(1);      # ok
     $obj->dump();       # ok
     $obj->dump(undef);  # dies

  =head2 Slurpy Parameters

     use Types::Standard qw( slurpy ClassName HashRef );

     sub new
     {
        state $check = compile( ClassName, slurpy HashRef );
        my ($class, $ref) = $check->(@_);
        bless $ref => $class;
     }

     __PACKAGE__->new(foo => 1, bar => 2);

  The following types from L<Types::Standard> can be made slurpy:
  C<ArrayRef>, C<Tuple>, C<HashRef>, C<Map>, C<Dict>. Hash-like types
  will die if an odd number of elements are slurped in.

  A check may only have one slurpy parameter, and it must be the last
  parameter.

  =head2 Named Parameters

  Just use a slurpy C<Dict>:

     use Types::Standard qw( slurpy Dict Ref Optional Int );

     sub dump
     {
        state $check = compile(
           slurpy Dict[
              var    => Ref,
              limit  => Optional[Int],
           ],
        );
        my ($arg) = $check->(@_);

        local $Data::Dumper::Maxdepth = $arg->{limit};
        print Data::Dumper::Dumper($arg->{var});
     }

     dump(var => $foo, limit => 1);   # ok
     dump(var => $foo);               # ok
     dump(limit => 1);                # dies

  =head2 Mixed Positional and Named Parameters

     use Types::Standard qw( slurpy Dict Ref Optional Int );

     sub my_print
     {
        state $check = compile(
           Str,
           slurpy Dict[
              colour => Optional[Str],
              size   => Optional[Int],
           ],
        );
        my ($string, $arg) = $check->(@_);
     }

     my_print("Hello World", colour => "blue");

  =head2 Coercions

  Coercions will automatically be applied for I<all> type constraints that have
  a coercion associated.

     use Type::Utils;
     use Types::Standard qw( Int Num );

     my $RoundedInt = declare as Int;
     coerce $RoundedInt, from Num, q{ int($_) };

     sub set_age
     {
        state $check = compile( Object, $RoundedInt );
        my ($self, $age) = $check->(@_);

        $self->{age} = $age;
     }

     $obj->set_age(32.5);   # ok; coerced to "32".

  Coercions carry over into structured types such as C<ArrayRef> automatically:

     sub delete_articles
     {
        state $check = compile( Object, slurpy ArrayRef[$RoundedInt] );
        my ($db, $articles) = $check->(@_);

        $db->select_article($_)->delete for @$articles;
     }

     # delete articles 1, 2 and 3
     delete_articles($my_db, 1.1, 2.2, 3.3);

  If type C<Foo> has coercions from C<Str> and C<ArrayRef> and you want to
  B<prevent> coercion, then use:

     state $check = compile( Foo->no_coercions );

  Or if you just want to prevent coercion from C<Str>, use:

     state $check = compile( Foo->minus_coercions(Str) );

  Or maybe add an extra coercion:

     state $check = compile(
        Foo->plus_coercions(Int, q{ Foo->new_from_number($_) }),
     );

  Note that the coercion is specified as a string of Perl code. This is usually
  the fastest way to do it, but a coderef is also accepted. Either way, the
  value to be coerced is C<< $_ >>.

  =head2 Alternatives

  Type::Params can export a C<multisig> function that compiles multiple
  alternative signatures into one, and uses the first one that works:

     state $check = multisig(
        [ Int, ArrayRef ],
        [ HashRef, Num ],
        [ CodeRef ],
     );

     my ($int, $arrayref) = $check->( 1, [] );
     my ($hashref, $num)  = $check->( {}, 1.1 );
     my ($code)           = $check->( sub { 1 } );

     $check->( sub { 1 }, 1.1 );  # throws an exception

  Coercions, slurpy parameters, etc still work.

  There's currently no indication of which of the multiple signatures
  succeeded.

  The present implementation involves compiling each signature independently,
  and trying them each (in their given order!) in an C<eval> block. The only
  slightly intelligent part is that it checks if C<< scalar(@_) >> fits into
  the signature properly (taking into account optional and slurpy parameters),
  and skips evals which couldn't possibly succeed.

  It's also possible to list coderefs as alternatives in C<multisig>:

     state $check = multisig(
        [ Int, ArrayRef ],
        sub { ... },
        [ HashRef, Num ],
        [ CodeRef ],
     );

  The coderef is expected to die if that alternative should be abandoned (and
  the next alternative tried), or return the list of accepted parameters. Here's
  a full example:

     sub get_from {
        state $check = multisig(
           [ Int, ArrayRef ],
           [ Str, HashRef ],
           sub {
              my ($meth, $obj);
              die unless is_Object($obj);
              die unless $obj->can($meth);
              return ($meth, $obj);
           },
        );
        my ($needle, $haystack) = $check->(@_);

        is_HashRef($haystack)  ? $haystack->{$needle} :
        is_ArrayRef($haystack) ? $haystack->[$needle] :
        is_Object($haystack)   ? $haystack->$needle   :
        die;
     }

     get_from(0, \@array);      # returns $array[0]
     get_from('foo', \%hash);   # returns $hash{foo}
     get_from('foo', $obj);     # returns $obj->foo

  =head1 COMPARISON WITH PARAMS::VALIDATE

  L<Type::Params> is not really a drop-in replacement for L<Params::Validate>;
  the API differs far too much to claim that. Yet it performs a similar task,
  so it makes sense to compare them.

  =over

  =item *

  Type::Params will tend to be faster if you've got a sub which is called
  repeatedly, but may be a little slower than Params::Validate for subs that
  are only called a few times. This is because it does a bunch of work the
  first time your sub is called to make subsequent calls a lot faster.

  =item *

  Type::Params is mostly geared towards positional parameters, while
  Params::Validate seems to be primarily aimed at named parameters. (Though
  either works for either.) Params::Validate doesn't appear to have a
  particularly natural way of validating a mix of positional and named
  parameters.

  =item *

  Type::Utils allows you to coerce parameters. For example, if you expect
  a L<Path::Tiny> object, you could coerce it from a string.

  =item *

  Params::Validate allows you to supply defaults for missing parameters;
  Type::Params does not, but you may be able to use coercion from Undef.

  =item *

  If you are primarily writing object-oriented code, using Moose or similar,
  and you are using Type::Tiny type constraints for your attributes, then
  using Type::Params allows you to use the same constraints for method calls.

  =item *

  Type::Params comes bundled with Types::Standard, which provides a much
  richer vocabulary of types than the type validation constants that come
  with Params::Validate. For example, Types::Standard provides constraints
  like C<< ArrayRef[Int] >> (an arrayref of integers), while the closest from
  Params::Validate is C<< ARRAYREF >>, which you'd need to supplement with
  additional callbacks if you wanted to check that the arrayref contained
  integers.

  Whatsmore, Type::Params doesn't just work with Types::Standard, but also
  any other Type::Tiny type constraints.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny>, L<Type::Coercion>, L<Types::Standard>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_PARAMS

$fatpacked{"Type/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARSER';
  package Type::Parser;

  use strict;
  use warnings;

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';

  # Token types
  #
  sub TYPE      () { "TYPE" };
  sub QUOTELIKE () { "QUOTELIKE" };
  sub STRING    () { "STRING" };
  sub CLASS     () { "CLASS" };
  sub L_BRACKET () { "L_BRACKET" };
  sub R_BRACKET () { "R_BRACKET" };
  sub COMMA     () { "COMMA" };
  sub SLURPY    () { "SLURPY" };
  sub UNION     () { "UNION" };
  sub INTERSECT () { "INTERSECT" };
  sub NOT       () { "NOT" };
  sub L_PAREN   () { "L_PAREN" };
  sub R_PAREN   () { "R_PAREN" };
  sub MYSTERY   () { "MYSTERY" };

  our @EXPORT_OK = qw( eval_type _std_eval parse extract_type );

  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';

  Evaluate: {

  	sub parse
  	{
  		my $str = $_[0];
  		my $parser = "Type::Parser::AstBuilder"->new(input => $str);
  		$parser->build;
  		wantarray ? ($parser->ast, $parser->remainder) : $parser->ast;
  	}

  	sub extract_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		wantarray ? (_eval_type($parsed, $reg), $tail) : _eval_type($parsed, $reg);
  	}

  	sub eval_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		_croak("Unexpected tail on type expression: $tail") if $tail =~ /\S/sm;
  		return _eval_type($parsed, $reg);
  	}

  	my $std;
  	sub _std_eval
  	{
  		require Type::Registry;
  		unless ($std)
  		{
  			$std = "Type::Registry"->new;
  			$std->add_types(-Standard);
  		}
  		eval_type($_[0], $std);
  	}

  	sub _eval_type
  	{
  		my ($node, $reg) = @_;

  		$node = _simplify_expression($node);

  		if ($node->{type} eq "list")
  		{
  			return map _eval_type($_, $reg), @{$node->{list}};
  		}

  		if ($node->{type} eq "union")
  		{
  			return $reg->make_union(
  				map _eval_type($_, $reg), @{$node->{union}}
  			);
  		}

  		if ($node->{type} eq "intersect")
  		{
  			return $reg->make_intersection(
  				map _eval_type($_, $reg), @{$node->{intersect}}
  			);
  		}

  		if ($node->{type} eq "slurpy")
  		{
  			return +{ slurpy => _eval_type($node->{of}, $reg) };
  		}

  		if ($node->{type} eq "complement")
  		{
  			return _eval_type($node->{of}, $reg)->complementary_type;
  		}

  		if ($node->{type} eq "parameterized")
  		{
  			my $base = _eval_type($node->{base}, $reg);

  			return $base unless $base->is_parameterizable || $node->{params};
  			return $base->parameterize($node->{params} ? _eval_type($node->{params}, $reg) : ());
  		}

  		if ($node->{type} eq "primary" and $node->{token}->type eq CLASS)
  		{
  			my $class = substr(
  				$node->{token}->spelling,
  				0,
  				length($node->{token}->spelling) - 2
  			);
  			return $reg->make_class_type($class);
  		}

  		if ($node->{type} eq "primary" and $node->{token}->type eq QUOTELIKE)
  		{
  			return eval($node->{token}->spelling); #ARGH
  		}

  		if ($node->{type} eq "primary" and $node->{token}->type eq STRING)
  		{
  			return $node->{token}->spelling;
  		}

  		if ($node->{type} eq "primary" and $node->{token}->type eq TYPE)
  		{
  			my $t = $node->{token}->spelling;
  			my $r = ($t =~ /^(.+)::(\w+)$/)
  				? $reg->foreign_lookup($t, 1)
  				: $reg->simple_lookup($t, 1);
  			$r or _croak("%s is not a known type constraint", $node->{token}->spelling);
  			return $r;
  		}
  	}

  	sub _simplify_expression
  	{
  		my $expr = shift;

  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq COMMA)
  		{
  			return _simplify("list", COMMA, $expr);
  		}

  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq UNION)
  		{
  			return _simplify("union", UNION, $expr);
  		}

  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq INTERSECT)
  		{
  			return _simplify("intersect", INTERSECT, $expr);
  		}

  		return $expr;
  	}

  	sub _simplify
  	{
  		my $type = shift;
  		my $op   = shift;

  		my @list;
  		for my $expr ($_[0]{lhs}, $_[0]{rhs})
  		{
  			if ($expr->{type} eq "expression" and $expr->{op}[0] eq $op)
  			{
  				my $simple = _simplify($type, $op, $expr);
  				push @list, @{ $simple->{$type} };
  			}
  			else
  			{
  				push @list, $expr;
  			}
  		}

  		return { type => $type, $type => \@list };
  	}
  }

  {
  	package # hide from CPAN
  	Type::Parser::AstBuilder;

  	sub new
  	{
  		my $class = shift;
  		bless { @_ }, $class;
  	}

  	our %precedence = (
  #		Type::Parser::COMMA()     , 1 ,
  		Type::Parser::UNION()     , 2 ,
  		Type::Parser::INTERSECT() , 3 ,
  		Type::Parser::NOT()       , 4 ,
  	);

  	sub _parse_primary
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};

  		$tokens->assert_not_empty;

  		if ($tokens->peek(0)->type eq Type::Parser::NOT)
  		{
  			$tokens->eat(Type::Parser::NOT);
  			$tokens->assert_not_empty;
  			return {
  				type  => "complement",
  				of    => $self->_parse_primary,
  			};
  		}

  		if ($tokens->peek(0)->type eq Type::Parser::SLURPY)
  		{
  			$tokens->eat(Type::Parser::SLURPY);
  			$tokens->assert_not_empty;
  			return {
  				type  => "slurpy",
  				of    => $self->_parse_primary,
  			};
  		}

  		if ($tokens->peek(0)->type eq Type::Parser::L_PAREN)
  		{
  			$tokens->eat(Type::Parser::L_PAREN);
  			my $r = $self->_parse_expression;
  			$tokens->eat(Type::Parser::R_PAREN);
  			return $r;
  		}

  		if ($tokens->peek(1)
  		and $tokens->peek(0)->type eq Type::Parser::TYPE
  		and $tokens->peek(1)->type eq Type::Parser::L_BRACKET)
  		{
  			my $base = { type  => "primary", token => $tokens->eat(Type::Parser::TYPE) };
  			$tokens->eat(Type::Parser::L_BRACKET);
  			$tokens->assert_not_empty;

  			local $precedence{ Type::Parser::COMMA() } = 1;

  			my $params = undef;
  			if ($tokens->peek(0)->type eq Type::Parser::R_BRACKET)
  			{
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			else
  			{
  				$params = $self->_parse_expression;
  				$params = { type => "list", list => [$params] } unless $params->{type} eq "list";
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			return {
  				type   => "parameterized",
  				base   => $base,
  				params => $params,
  			};
  		}

  		my $type = $tokens->peek(0)->type;
  		if ($type eq Type::Parser::TYPE
  		or  $type eq Type::Parser::QUOTELIKE
  		or  $type eq Type::Parser::STRING
  		or  $type eq Type::Parser::CLASS)
  		{
  			return { type  => "primary", token => $tokens->eat };
  		}

  		Type::Parser::_croak("Unexpected token in primary type expression; got '%s'", $tokens->peek(0)->spelling);
  	}

  	sub _parse_expression_1
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};

  		my ($lhs, $min_p) = @_;
  		while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} >= $min_p)
  		{
  			my $op  = $tokens->eat;
  			my $rhs = $self->_parse_primary;

  			while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} > $precedence{$op->type})
  			{
  				my $lookahead = $tokens->peek(0);
  				$rhs = $self->_parse_expression_1($rhs, $precedence{$lookahead->type});
  			}

  			$lhs = {
  				type => "expression",
  				op   => $op,
  				lhs  => $lhs,
  				rhs  => $rhs,
  			};
  		}
  		return $lhs;
  	}

  	sub _parse_expression
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};

  		return $self->_parse_expression_1($self->_parse_primary, 0);
  	}

  	sub build
  	{
  		my $self = shift;
  		$self->{tokens} = "Type::Parser::TokenStream"->new(remaining => $self->{input});
  		$self->{ast}    = $self->_parse_expression;
  	}

  	sub ast
  	{
  		$_[0]{ast};
  	}

  	sub remainder
  	{
  		$_[0]{tokens}->remainder;
  	}
  }

  {
  	package # hide from CPAN
  	Type::Parser::Token;
  	sub type     { $_[0][0] }
  	sub spelling { $_[0][1] }
  }

  {
  	package # hide from CPAN
  	Type::Parser::TokenStream;

  	use Scalar::Util qw(looks_like_number);
  	use Text::Balanced qw(extract_quotelike);

  	sub new
  	{
  		my $class = shift;
  		bless { stack => [], done => [], @_ }, $class;
  	}

  	sub peek
  	{
  		my $self  = shift;
  		my $ahead = $_[0];

  		while ($self->_stack_size <= $ahead and length $self->{remaining})
  		{
  			$self->_stack_extend;
  		}

  		my @tokens = grep ref, @{ $self->{stack} };
  		return $tokens[$ahead];
  	}

  	sub empty
  	{
  		my $self = shift;
  		not $self->peek(0);
  	}

  	sub eat
  	{
  		my $self = shift;
  		$self->_stack_extend unless $self->_stack_size;
  		my $r;
  		while (defined(my $item = shift @{$self->{stack}}))
  		{
  			push @{ $self->{done} }, $item;
  			if (ref $item)
  			{
  				$r = $item;
  				last;
  			}
  		}

  		if (@_ and $_[0] ne $r->type)
  		{
  			unshift @{$self->{stack}}, pop @{$self->{done}};
  			Type::Parser::_croak("Expected $_[0]; got ".$r->type);
  		}

  		return $r;
  	}

  	sub assert_not_empty
  	{
  		my $self = shift;
  		Type::Parser::_croak("Expected token; got empty string") if $self->empty;
  	}

  	sub _stack_size
  	{
  		my $self = shift;
  		scalar grep ref, @{ $self->{stack} };
  	}

  	sub _stack_extend
  	{
  		my $self = shift;
  		push @{ $self->{stack} }, $self->_read_token;
  		my ($space) = ($self->{remaining} =~ m/^([\s\n\r]*)/sm);
  		return unless length $space;
  		push @{ $self->{stack} }, $space;
  		substr($self->{remaining}, 0, length $space) = "";
  	}

  	sub remainder
  	{
  		my $self = shift;
  		return join "",
  			map { ref($_) ? $_->spelling : $_ }
  			(@{$self->{stack}}, $self->{remaining})
  	}

  	my %punctuation = (
  		'['       => bless([ Type::Parser::L_BRACKET, "[" ], "Type::Parser::Token"),
  		']'       => bless([ Type::Parser::R_BRACKET, "]" ], "Type::Parser::Token"),
  		'('       => bless([ Type::Parser::L_PAREN,   "[" ], "Type::Parser::Token"),
  		')'       => bless([ Type::Parser::R_PAREN,   "]" ], "Type::Parser::Token"),
  		','       => bless([ Type::Parser::COMMA,     "," ], "Type::Parser::Token"),
  		'=>'      => bless([ Type::Parser::COMMA,     "=>" ], "Type::Parser::Token"),
  		'slurpy'  => bless([ Type::Parser::SLURPY,    "slurpy" ], "Type::Parser::Token"),
  		'|'       => bless([ Type::Parser::UNION,     "|" ], "Type::Parser::Token"),
  		'&'       => bless([ Type::Parser::INTERSECT, "&" ], "Type::Parser::Token"),
  		'~'       => bless([ Type::Parser::NOT,       "~" ], "Type::Parser::Token"),
  	);

  	sub _read_token
  	{
  		my $self = shift;

  		return if $self->{remaining} eq "";

  		# Punctuation
  		#

  		if ($self->{remaining} =~ /^( => | [()\]\[|&~,] )/xsm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			return $punctuation{$spelling};
  		}

  		if (my $quotelike = extract_quotelike $self->{remaining})
  		{
  			return bless([ Type::Parser::QUOTELIKE, $quotelike ], "Type::Parser::Token"),;
  		}

  		if ($self->{remaining} =~ /^([+-]?[\w:.+]+)/sm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";

  			if ($spelling =~ /::$/sm)
  			{
  				return bless([ Type::Parser::CLASS, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif (looks_like_number($spelling))
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($self->{remaining} =~ /^\s*=>/sm) # peek ahead
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($spelling eq "slurpy")
  			{
  				return $punctuation{$spelling};
  			}

  			return bless([ Type::Parser::TYPE, $spelling ], "Type::Parser::Token");
  		}

  		my $rest = $self->{remaining};
  		$self->{remaining} = "";
  		return bless([ Type::Parser::MYSTERY, $rest ], "Type::Parser::Token");
  	}
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords non-whitespace

  =head1 NAME

  Type::Parser - parse type constraint strings

  =head1 SYNOPSIS

   use v5.10;
   use strict;
   use warnings;

   use Type::Parser qw( eval_type );
   use Type::Registry;

   my $reg = Type::Registry->for_me;
   $reg->add_types("Types::Standard");

   my $type = eval_type("Int | ArrayRef[Int]", $reg);

   $type->check(10);        # true
   $type->check([1..4]);    # true
   $type->check({foo=>1});  # false

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Generally speaking, you probably don't want to be using this module directly.
  Instead use the C<< lookup >> method from L<Type::Registry> which wraps it.

  =head2 Functions

  =over

  =item C<< parse($string) >>

  Parse the type constraint string into something like an AST.

  If called in list context, also returns any "tail" found on the original string.

  =item C<< extract_type($string, $registry) >>

  Compile a type constraint string into a L<Type::Tiny> object.

  If called in list context, also returns any "tail" found on the original string.

  =item C<< eval_type($string, $registry) >>

  Compile a type constraint string into a L<Type::Tiny> object.

  Throws an error if the "tail" contains any non-whitespace character.

  =back

  =head2 Constants

  The following constants correspond to values returned by C<< $token->type >>.

  =over

  =item C<< TYPE >>

  =item C<< QUOTELIKE >>

  =item C<< STRING >>

  =item C<< CLASS >>

  =item C<< L_BRACKET >>

  =item C<< R_BRACKET >>

  =item C<< COMMA >>

  =item C<< SLURPY >>

  =item C<< UNION >>

  =item C<< INTERSECT >>

  =item C<< NOT >>

  =item C<< L_PAREN >>

  =item C<< R_PAREN >>

  =item C<< MYSTERY >>

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Registry>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_PARSER

$fatpacked{"Type/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_REGISTRY';
  package Type::Registry;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Registry::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Registry::VERSION   = '1.000005';
  }

  use Exporter::Tiny qw( mkopt );
  use Scalar::Util qw( refaddr );
  use Type::Parser qw( eval_type );
  use Types::TypeTiny qw( CodeLike ArrayLike to_TypeTiny );

  our @ISA = 'Exporter::Tiny';
  our @EXPORT_OK = qw(t);

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;

  	if ($name eq "t")
  	{
  		my $caller = $globals->{into};
  		my $reg = $class->for_class(
  			ref($caller) ? sprintf('HASH(0x%08X)', refaddr($caller)) : $caller
  		);
  		return t => sub (;$) { @_ ? $reg->lookup(@_) : $reg };
  	}

  	return $class->SUPER::_exporter_expand_sub(@_);
  }

  sub new
  {
  	my $class = shift;
  	ref($class) and _croak("Not an object method");
  	bless {}, $class;
  }

  {
  	my %registries;

  	sub for_class
  	{
  		my $class = shift;
  		my ($for) = @_;
  		$registries{$for} ||= $class->new;
  	}

  	sub for_me
  	{
  		my $class = shift;
  		my $for   = caller;
  		$registries{$for} ||= $class->new;
  	}
  }

  sub add_types
  {
  	my $self = shift;
  	my $opts = mkopt(\@_);
  	for my $opt (@$opts)
  	{
  		my ($lib, $types) = @_;

  		$lib =~ s/^-/Types::/;
  		eval "require $lib";

  		my %hash;

  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$types ||= [qw/-types/];
  			ArrayLike->check($types)
  				or _croak("Expected arrayref following '%s'; got %s", $lib, $types);

  			$lib->import({into => \%hash}, @$types);
  			$hash{$_} = &{$hash{$_}}() for keys %hash;
  		}
  		elsif ($lib->isa("MooseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MooseX::Types type constraint library. No import options currently supported", $lib);

  			require Moose::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Moose::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		elsif ($lib->isa("MouseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MouseX::Types type constraint library. No import options currently supported", $lib);

  			require Mouse::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Mouse::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		else
  		{
  			_croak("%s is not a type library", $lib);
  		}

  		for my $key (sort keys %hash)
  		{
  			exists($self->{$key})
  				and $self->{$key}{uniq} != $hash{$key}{uniq}
  				and _croak("Duplicate type name: %s", $key);
  			$self->{$key} = $hash{$key};
  		}
  	}
  	$self;
  }

  sub add_type
  {
  	my $self = shift;
  	my ($type, $name) = @_;
  	$type = to_TypeTiny($type);
  	$name ||= do {
  		$type->is_anon
  			and _croak("Expected named type constraint; got anonymous type constraint");
  		$type->name;
  	};

  	exists($self->{$name})
  		and $self->{$name}{uniq} != $type->{uniq}
  		and _croak("Duplicate type name: %s", $name);

  	$self->{$name} = $type;
  	$self;
  }

  sub alias_type
  {
  	my $self = shift;
  	my ($old, @new) = @_;
  	my $lookup = eval { $self->lookup($old) }
  		or _croak("Expected existing type constraint name; got '$old'");
  	$self->{$_} = $lookup for @new;
  	$self;
  }

  sub simple_lookup
  {
  	my $self = shift;

  	my ($tc) = @_;
  	$tc =~ s/(^\s+|\s+$)//g;

  	if (exists $self->{$tc})
  	{
  		return $self->{$tc};
  	}

  	return;
  }

  sub foreign_lookup
  {
  	my $self = shift;

  	return $_[1] ? () : $self->simple_lookup($_[0], 1)
  		unless $_[0] =~ /^(.+)::(\w+)$/;

  	my $library  = $1;
  	my $typename = $2;

  	eval "require $library;";

  	if ( $library->isa('MooseX::Types::Base') )
  	{
  		require Moose::Util::TypeConstraints;
  		my $type = Moose::Util::TypeConstraints::find_type_constraint(
  			$library->get_type($typename)
  		) or return;
  		return to_TypeTiny($type);
  	}

  	if ( $library->isa('MouseX::Types::Base') )
  	{
  		require Mouse::Util::TypeConstraints;
  		my $sub  = $library->can($typename) or return;
  		my $type = Mouse::Util::TypeConstraints::find_type_constraint($sub->()) or return;
  		return to_TypeTiny($type);
  	}

  	if ( $library->can("get_type") )
  	{
  		my $type = $library->get_type($typename);
  		return to_TypeTiny($type);
  	}

  	return;
  }

  sub lookup
  {
  	my $self = shift;

  	$self->simple_lookup(@_) or eval_type($_[0], $self);
  }

  sub make_union
  {
  	my $self = shift;
  	my (@types) = @_;

  	require Type::Tiny::Union;
  	return "Type::Tiny::Union"->new(type_constraints => \@types);
  }

  sub make_intersection
  {
  	my $self = shift;
  	my (@types) = @_;

  	require Type::Tiny::Intersection;
  	return "Type::Tiny::Intersection"->new(type_constraints => \@types);
  }

  sub make_class_type
  {
  	my $self = shift;
  	my ($class) = @_;

  	require Type::Tiny::Class;
  	return "Type::Tiny::Class"->new(class => $class);
  }

  sub make_role_type
  {
  	my $self = shift;
  	my ($role) = @_;

  	require Type::Tiny::Role;
  	return "Type::Tiny::Role"->new(role => $role);
  }

  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  	my $type = $self->simple_lookup($method);
  	return $type if $type;
  	_croak(q[Can't locate object method "%s" via package "%s"], $method, ref($self));
  }

  # Prevent AUTOLOAD being called for DESTROY!
  sub DESTROY
  {
  	return;
  }

  DELAYED: {
  	our %DELAYED;
  	for my $package (sort keys %DELAYED)
  	{
  		my $reg   = __PACKAGE__->for_class($package);
  		my $types = $DELAYED{$package};

  		for my $name (sort keys %$types)
  		{
  			$reg->add_type($types->{$name}, $name);
  		}
  	}
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords optlist

  =head1 NAME

  Type::Registry - a glorified hashref for looking up type constraints

  =head1 SYNOPSIS

  =for test_synopsis no warnings qw(misc);

     package Foo::Bar;

     use Type::Registry;

     my $reg = "Type::Registry"->for_me;  # a registry for Foo::Bar

     # Register all types from Types::Standard
     $reg->add_types(-Standard);

     # Register just one type from Types::XSD
     $reg->add_types(-XSD => ["NonNegativeInteger"]);

     # Register all types from MyApp::Types
     $reg->add_types("MyApp::Types");

     # Create a type alias
     $reg->alias_type("NonNegativeInteger" => "Count");

     # Look up a type constraint
     my $type = $reg->lookup("ArrayRef[Count]");

     $type->check([1, 2, 3.14159]);  # croaks

  Alternatively:

     package Foo::Bar;

     use Type::Registry qw( t );

     # Register all types from Types::Standard
     t->add_types(-Standard);

     # Register just one type from Types::XSD
     t->add_types(-XSD => ["NonNegativeInteger"]);

     # Register all types from MyApp::Types
     t->add_types("MyApp::Types");

     # Create a type alias
     t->alias_type("NonNegativeInteger" => "Count");

     # Look up a type constraint
     my $type = t("ArrayRef[Count]");

     $type->check([1, 2, 3.14159]);  # croaks

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  A type registry is basically just a hashref mapping type names to type
  constraint objects.

  =head2 Constructors

  =over

  =item C<< new >>

  Create a new glorified hashref.

  =item C<< for_class($class) >>

  Create or return the existing glorified hashref associated with the given
  class.

  Note that any type constraint you have imported from Type::Library-based
  type libraries will be automatically available in your class' registry.

  =item C<< for_me >>

  Create or return the existing glorified hashref associated with the caller.

  =back

  =head2 Methods

  =over

  =item C<< add_types(@libraries) >>

  The libraries list is treated as an "optlist" (a la L<Data::OptList>).

  Strings are the names of type libraries; if the first character is a
  hyphen, it is expanded to the "Types::" prefix. If followed by an
  arrayref, this is the list of types to import from that library.
  Otherwise, imports all types from the library.

     use Type::Registry qw(t);

     t->add_types(-Standard);  # OR: t->add_types("Types::Standard");

     t->add_types(
        -TypeTiny => ['HashLike'],
        -Standard => ['HashRef' => { -as => 'RealHash' }],
     );

  L<MooseX::Types> (and experimentally, L<MouseX::Types>) libraries can
  also be added this way, but I<< cannot be followed by an arrayref of
  types to import >>.

  =item C<< add_type($type, $name) >>

  The long-awaited singular form of C<add_types>. Given a type constraint
  object, adds it to the registry with a given name. The name may be
  omitted, in which case C<< $type->name >> is called, and Type::Registry
  will throw an error if C<< $type >> is anonymous. If a name is explicitly
  given, Type::Registry cares not one wit whether the type constraint is
  anonymous.

  This method can even add L<MooseX::Types> and L<MouseX::Types> type
  constraints; indeed anything that can be handled by L<Types::TypeTiny>'s
  C<to_TypeTiny> function. (Bear in mind that to_TypeTiny I<always> results
  in an anonymous type constraint, so C<< $name >> will be required.)

  =item C<< alias_type($oldname, $newname) >>

  Create an alias for an existing type.

  =item C<< simple_lookup($name) >>

  Look up a type in the registry by name.

  Returns undef if not found.

  =item C<< foreign_lookup($name) >>

  Like C<simple_lookup>, but if the type name contains "::", will attempt
  to load it from a type library. (And will attempt to load that module.)

  =item C<< lookup($name) >>

  Look up by name, with a DSL.

     t->lookup("Int|ArrayRef[Int]")

  The DSL can be summed up as:

     X               type from this registry
     My::Lib::X      type from a type library
     ~X              complementary type
     X | Y           union
     X & Y           intersection
     X[...]          parameterized type
     slurpy X        slurpy type
     Foo::Bar::      class type

  Croaks if not found.

  =item C<< make_union(@constraints) >>,
  C<< make_intersection(@constraints) >>,
  C<< make_class_type($class) >>,
  C<< make_role_type($role) >>

  Convenience methods for creating certain common type constraints.

  =item C<< AUTOLOAD >>

  Overloaded to call C<lookup>.

     $registry->Str;  # like $registry->lookup("Str")

  =back

  =head2 Functions

  =over

  =item C<< t >>

  This class can export a function C<< t >> which acts like
  C<< "Type::Registry"->for_class($importing_class) >>.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Library>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_REGISTRY

$fatpacked{"Type/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY';
  package Type::Tiny;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }

  BEGIN {
  	$Type::Tiny::AUTHORITY   = 'cpan:TOBYINK';
  	$Type::Tiny::VERSION     = '1.000005';
  	$Type::Tiny::XS_VERSION  = '0.010';
  }

  use Eval::TypeTiny ();
  use Scalar::Util qw( blessed weaken refaddr isweak );
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  sub _swap { $_[2] ? @_[1,0] : @_[0,1] }

  BEGIN {
  	($] < 5.010001)
  		? eval q{ sub SUPPORT_SMARTMATCH () { !!0 } }
  		: eval q{ sub SUPPORT_SMARTMATCH () { !!1 } };
  	($] >= 5.014)
  		? eval q{ sub _FIXED_PRECEDENCE () { !!1 } }
  		: eval q{ sub _FIXED_PRECEDENCE () { !!0 } };
  };

  BEGIN {
  	my $try_xs =
  		exists($ENV{PERL_TYPE_TINY_XS}) ? !!$ENV{PERL_TYPE_TINY_XS} :
  		exists($ENV{PERL_ONLY})         ?  !$ENV{PERL_ONLY} :
  		1;

  	my $use_xs = 0;
  	$try_xs and eval {
  		require Type::Tiny::XS;
  		'Type::Tiny::XS'->VERSION($Type::Tiny::XS_VERSION);
  		$use_xs++;
  	};

  	*_USE_XS = $use_xs
  		? sub () { !!1 }
  		: sub () { !!0 };

  	*_USE_MOUSE = $try_xs
  		? sub () { $INC{'Mouse/Util.pm'} and Mouse::Util::MOUSE_XS() }
  		: sub () { !!0 };
  };

  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	q(|)       => sub {
  		my @tc = _swap @_;
  		if (!_FIXED_PRECEDENCE && !blessed $tc[0] && ref $tc[0] eq 'ARRAY') {
  			require Type::Tiny::_HalfOp;
  			return "Type::Tiny::_HalfOp"->new('|', @tc);
  		}
  		require Type::Tiny::Union;
  		"Type::Tiny::Union"->new(type_constraints => \@tc)
  	},
  	q(&)       => sub {
  		my @tc = _swap @_;
  		if (!_FIXED_PRECEDENCE && !blessed $tc[0] && ref $tc[0] eq 'ARRAY') {
  			require Type::Tiny::_HalfOp;
  			return "Type::Tiny::_HalfOp"->new('&', @tc);
  		}
  		require Type::Tiny::Intersection;
  		"Type::Tiny::Intersection"->new(type_constraints => \@tc)
  	},
  	q(~)       => sub { shift->complementary_type },
  	q(==)      => sub { $_[0]->equals($_[1]) },
  	q(<)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(_swap @_) },
  	q(>)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(reverse _swap @_) },
  	q(<=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(_swap @_) },
  	q(>=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(reverse _swap @_) },
  	q(eq)      => sub { "$_[0]" eq "$_[1]" },
  	q(cmp)     => sub { $_[2] ? ("$_[1]" cmp "$_[0]") : ("$_[0]" cmp "$_[1]") },
  	fallback   => 1,
  ;
  BEGIN {
  	overload->import(
  		q(~~)    => sub { $_[0]->check($_[1]) },
  		fallback => 1, # 5.10 loses the fallback otherwise
  	) if Type::Tiny::SUPPORT_SMARTMATCH;
  }

  sub _overload_coderef
  {
  	my $self = shift;
  	$self->message unless exists $self->{message};

  #	if ($self->has_parent && $self->_is_null_constraint)
  #	{
  #		$self->{_overload_coderef} ||= $self->parent->_overload_coderef;
  #	}
  #	els
  	if (!exists($self->{message}) && exists(&Sub::Quote::quote_sub) && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_assert('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->assert_return(@_) };
  	}

  	$self->{_overload_coderef};
  }

  our %ALL_TYPES;

  my $QFS;
  my $uniq = 1;
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;

  	if (exists $params{parent})
  	{
  		$params{parent} = ref($params{parent}) =~ /^Type::Tiny\b/
  			? $params{parent}
  			: Types::TypeTiny::to_TypeTiny($params{parent});

  		_croak "Parent must be an instance of %s", __PACKAGE__
  			unless blessed($params{parent}) && $params{parent}->isa(__PACKAGE__);
  	}

  	$params{name} = "__ANON__" unless exists $params{name};
  	$params{uniq} = $uniq++;

  	if ($params{name} ne "__ANON__")
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$params{name} =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $params{name} =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid type name', $params{name};
  	}

  	if (exists $params{coercion} and !ref $params{coercion} and $params{coercion})
  	{
  		$params{parent}->has_coercion
  			or _croak "coercion => 1 requires type to have a direct parent with a coercion";

  		$params{coercion} = $params{parent}->coercion->type_coercion_map;
  	}

  	if (!exists $params{inlined}
  	and exists $params{constraint}
  	and ( !exists $params{parent} or $params{parent}->can_be_inlined )
  	and $QFS ||= "Sub::Quote"->can("quoted_from_sub"))
  	{
  		my (undef, $perlstring, $captures) = @{ $QFS->($params{constraint}) || [] };

  		$params{inlined} = sub {
  			my ($self, $var) = @_;
  			my $code = Sub::Quote::inlinify(
  				$perlstring,
  				$var,
  				$var eq q($_) ? '' : "local \$_ = $var;",
  				1,
  			);
  			$code = sprintf('%s and %s', $self->parent->inline_check($var), $code) if $self->has_parent;
  			return $code;
  		} if $perlstring && !$captures;
  	}

  	my $self = bless \%params, $class;

  	unless ($params{tmp})
  	{
  		my $uniq = $self->{uniq};

  		$ALL_TYPES{$uniq} = $self;
  		weaken( $ALL_TYPES{$uniq} );

  		package # no index
  			Moo::HandleMoose;
  		my $tmp = $self;
  		Scalar::Util::weaken($tmp);
  		$Moo::HandleMoose::TYPE_MAP{$self} = sub { $tmp };
  	}

  	if (ref($params{coercion}) eq q(CODE))
  	{
  		require Types::Standard;
  		my $code = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(Types::Standard::Any(), $code);
  	}
  	elsif (ref($params{coercion}) eq q(ARRAY))
  	{
  		my $arr = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(@$arr);
  	}

  	if ($params{my_methods} and eval { require Sub::Name })
  	{
  		for my $key (keys %{$params{my_methods}})
  		{
  			Sub::Name::subname(
  				sprintf("%s::my_%s", $self->qualified_name, $key),
  				$params{my_methods}{$key},
  			);
  		}
  	}

  	return $self;
  }

  sub DESTROY
  {
  	my $self = shift;
  	delete( $ALL_TYPES{$self->{uniq}} );
  	package # no index
  		Moo::HandleMoose;
  	delete( $Moo::HandleMoose::TYPE_MAP{$self} );
  	return;
  }

  sub _clone
  {
  	my $self = shift;
  	my %opts;
  	$opts{$_} = $self->{$_} for qw< name display_name message >;
  	$self->create_child_type(%opts);
  }

  our $DD;
  sub _dd
  {
  	@_ = $_ unless @_;
  	my ($value) = @_;

  	goto $DD if ref($DD) eq q(CODE);

  	require B;

  	!defined $value ? 'Undef' :
  	!ref $value     ? sprintf('Value %s', B::perlstring($value)) :
  	do {
  		my $N = 0 + (defined($DD) ? $DD : 72);
  		require Data::Dumper;
  		local $Data::Dumper::Indent   = 0;
  		local $Data::Dumper::Useqq    = 1;
  		local $Data::Dumper::Terse    = 1;
  		local $Data::Dumper::Sortkeys = 1;
  		local $Data::Dumper::Maxdepth = 2;
  		my $str = Data::Dumper::Dumper($value);
  		$str = substr($str, 0, $N - 12).'...'.substr($str, -1, 1)
  			if length($str) >= $N;
  		"Reference $str";
  	}
  }

  sub _loose_to_TypeTiny
  {
  	map +(
  		ref($_)
  			? Types::TypeTiny::to_TypeTiny($_)
  			: do { require Type::Utils; Type::Utils::dwim_type($_) }
  	), @_;
  }

  sub name                     { $_[0]{name} }
  sub display_name             { $_[0]{display_name}   ||= $_[0]->_build_display_name }
  sub parent                   { $_[0]{parent} }
  sub constraint               { $_[0]{constraint}     ||= $_[0]->_build_constraint }
  sub compiled_check           { $_[0]{compiled_type_constraint} ||= $_[0]->_build_compiled_check }
  sub coercion                 { $_[0]{coercion}       ||= $_[0]->_build_coercion }
  sub message                  { $_[0]{message} }
  sub library                  { $_[0]{library} }
  sub inlined                  { $_[0]{inlined} }
  sub constraint_generator     { $_[0]{constraint_generator} }
  sub inline_generator         { $_[0]{inline_generator} }
  sub name_generator           { $_[0]{name_generator} ||= $_[0]->_build_name_generator }
  sub coercion_generator       { $_[0]{coercion_generator} }
  sub parameters               { $_[0]{parameters} }
  sub moose_type               { $_[0]{moose_type}     ||= $_[0]->_build_moose_type }
  sub mouse_type               { $_[0]{mouse_type}     ||= $_[0]->_build_mouse_type }
  sub deep_explanation         { $_[0]{deep_explanation} }
  sub my_methods               { $_[0]{my_methods}     ||= $_[0]->_build_my_methods }

  sub has_parent               { exists $_[0]{parent} }
  sub has_library              { exists $_[0]{library} }
  sub has_coercion             {        $_[0]{coercion} and !!@{ $_[0]{coercion}->type_coercion_map } }
  sub has_inlined              { exists $_[0]{inlined} }
  sub has_constraint_generator { exists $_[0]{constraint_generator} }
  sub has_inline_generator     { exists $_[0]{inline_generator} }
  sub has_coercion_generator   { exists $_[0]{coercion_generator} }
  sub has_parameters           { exists $_[0]{parameters} }
  sub has_message              { defined $_[0]{message} }
  sub has_deep_explanation     { exists $_[0]{deep_explanation} }

  sub _default_message         { $_[0]{_default_message} ||= $_[0]->_build_default_message }

  sub _assert_coercion
  {
  	my $self = shift;
  	_croak "No coercion for this type constraint"
  		unless $self->has_coercion && @{$self->coercion->type_coercion_map};
  	return $self->coercion;
  }

  my $null_constraint = sub { !!1 };

  sub _build_display_name
  {
  	shift->name;
  }

  sub _build_constraint
  {
  	return $null_constraint;
  }

  sub _is_null_constraint
  {
  	shift->constraint == $null_constraint;
  }

  sub _build_coercion
  {
  	require Type::Coercion;
  	my $self = shift;
  	my %opts = (type_constraint => $self);
  	$opts{display_name} = "to_$self" unless $self->is_anon;
  	return "Type::Coercion"->new(%opts);
  }

  sub _build_default_message
  {
  	my $self = shift;
  	return sub { sprintf '%s did not pass type constraint', _dd($_[0]) } if "$self" eq "__ANON__";
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s"', _dd($_[0]), $name };
  }

  sub _build_name_generator
  {
  	my $self = shift;
  	return sub {
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], @a);
  	};
  }

  sub _build_compiled_check
  {
  	my $self = shift;

  	if ($self->_is_null_constraint and $self->has_parent)
  	{
  		return $self->parent->compiled_check;
  	}

  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', $self->inline_check('$_[0]')),
  		description => sprintf("compiled check '%s'", $self),
  	) if $self->can_be_inlined;

  	my @constraints;
  	push @constraints, $self->parent->compiled_check if $self->has_parent;
  	push @constraints, $self->constraint if !$self->_is_null_constraint;
  	return $null_constraint unless @constraints;

  	return sub ($)
  	{
  		local $_ = $_[0];
  		for my $c (@constraints)
  		{
  			return unless $c->(@_);
  		}
  		return !!1;
  	};
  }

  sub equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");

  	return !!1 if refaddr($self) == refaddr($other);

  	return !!1 if $self->has_parent  && $self->_is_null_constraint  && $self->parent==$other;
  	return !!1 if $other->has_parent && $other->_is_null_constraint && $other->parent==$self;

  	return !!1 if refaddr($self->compiled_check) == refaddr($other->compiled_check);

  	return $self->qualified_name eq $other->qualified_name
  		if $self->has_library && !$self->is_anon && $other->has_library && !$other->is_anon;

  	return $self->inline_check('$x') eq $other->inline_check('$x')
  		if $self->can_be_inlined && $other->can_be_inlined;

  	return;
  }

  sub is_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");

  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->equals($other);
  #		$this = $parent;
  #	}
  #	return;

  	return unless $self->has_parent;
  	$self->parent->equals($other) or $self->parent->is_subtype_of($other);
  }

  sub is_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");

  	$other->is_subtype_of($self);
  }

  sub is_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");

  	$self->equals($other) or $self->is_subtype_of($other);
  }

  sub strictly_equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	$self->{uniq} == $other->{uniq};
  }

  sub is_strictly_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");

  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->strictly_equals($other);
  #		$this = $parent;
  #	}
  #	return;

  	return unless $self->has_parent;
  	$self->parent->strictly_equals($other) or $self->parent->is_strictly_subtype_of($other);
  }

  sub is_strictly_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");

  	$other->is_strictly_subtype_of($self);
  }

  sub is_strictly_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");

  	$self->strictly_equals($other) or $self->is_strictly_subtype_of($other);
  }

  sub qualified_name
  {
  	my $self = shift;
  	(exists $self->{library} and $self->name ne "__ANON__")
  		? "$self->{library}::$self->{name}"
  		: $self->{name};
  }

  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }

  sub parents
  {
  	my $self = shift;
  	return unless $self->has_parent;
  	return ($self->parent, $self->parent->parents);
  }

  sub find_parent
  {
  	my $self = shift;
  	my ($test) = @_;

  	local ($_, $.);
  	my $type  = $self;
  	my $count = 0;
  	while ($type)
  	{
  		if ($test->($_=$type, $.=$count))
  		{
  			return wantarray ? ($type, $count) : $type;
  		}
  		else
  		{
  			$type = $type->parent;
  			$count++;
  		}
  	}

  	return;
  }

  sub check
  {
  	my $self = shift;
  	($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  }

  sub _strict_check
  {
  	my $self = shift;
  	local $_ = $_[0];

  	my @constraints =
  		reverse
  		map  { $_->constraint }
  		grep { not $_->_is_null_constraint }
  		($self, $self->parents);

  	for my $c (@constraints)
  	{
  		return unless $c->(@_);
  	}

  	return !!1;
  }

  sub get_message
  {
  	my $self = shift;
  	local $_ = $_[0];
  	$self->has_message
  		? $self->message->(@_)
  		: $self->_default_message->(@_);
  }

  sub validate
  {
  	my $self = shift;

  	return undef if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);

  	local $_ = $_[0];
  	return $self->get_message(@_);
  }

  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;

  	return undef if $self->check($value);

  	if ($self->has_parent)
  	{
  		my $parent = $self->parent->validate_explain($value, $varname);
  		return [ sprintf('"%s" is a subtype of "%s"', $self, $self->parent), @$parent ] if $parent;
  	}

  	my $message = sprintf(
  		'%s%s',
  		$self->get_message($value),
  		$varname eq q{$_} ? '' : sprintf(' (in %s)', $varname),
  	);

  	if ($self->is_parameterized and $self->parent->has_deep_explanation)
  	{
  		my $deep = $self->parent->deep_explanation->($self, $value, $varname);
  		return [ $message, @$deep ] if $deep;
  	}

  	return [ $message, sprintf('"%s" is defined as: %s', $self, $self->_perlcode) ];
  }

  my $b;
  sub _perlcode
  {
  	my $self = shift;

  	return $self->inline_check('$_')
  		if $self->can_be_inlined;

  	$b ||= do {
  		require B::Deparse;
  		my $tmp = "B::Deparse"->new;
  		$tmp->ambient_pragmas(strict => "all", warnings => "all") if $tmp->can('ambient_pragmas');
  		$tmp;
  	};

  	my $code = $b->coderef2text($self->constraint);
  	$code =~ s/\s+/ /g;
  	return "sub $code";
  }

  sub assert_valid
  {
  	my $self = shift;

  	return !!1 if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);

  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }

  sub assert_return
  {
  	my $self = shift;

  	return $_[0] if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);

  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }

  sub can_be_inlined
  {
  	my $self = shift;
  	return $self->parent->can_be_inlined
  		if $self->has_parent && $self->_is_null_constraint;
  	return !!1
  		if !$self->has_parent && $self->_is_null_constraint;
  	return $self->has_inlined;
  }

  sub inline_check
  {
  	my $self = shift;
  	_croak 'Cannot inline type constraint check for "%s"', $self
  		unless $self->can_be_inlined;

  	return $self->parent->inline_check(@_)
  		if $self->has_parent && $self->_is_null_constraint;
  	return '(!!1)'
  		if !$self->has_parent && $self->_is_null_constraint;

  	local $_ = $_[0];
  	my @r = $self->inlined->($self, @_);
  	if (@r and not defined $r[0])
  	{
  		_croak 'Inlining type constraint check for "%s" returned undef!', $self
  			unless $self->has_parent;
  		$r[0] = $self->parent->inline_check(@_);
  	}
  	my $r = join " && " => map { /[;{}]/ ? "do { $_ }" : "($_)" } @r;
  	return @r==1 ? $r : "($r)";
  }

  sub inline_assert
  {
  	require B;
  	my $self = shift;
  	my $varname = $_[0];
  	my $code = sprintf(
  		q[do { no warnings "void"; %s ? %s : Type::Tiny::_failed_check(%d, %s, %s) };],
  		$self->inline_check(@_),
  		$varname,
  		$self->{uniq},
  		B::perlstring("$self"),
  		$varname,
  	);
  	return $code;
  }

  sub _failed_check
  {
  	require Error::TypeTiny::Assertion;

  	my ($self, $name, $value, %attrs) = @_;
  	$self = $ALL_TYPES{$self} unless ref $self;

  	my $exception_class = delete($attrs{exception_class}) || "Error::TypeTiny::Assertion";

  	if ($self)
  	{
  		$exception_class->throw(
  			message => $self->get_message($value),
  			type    => $self,
  			value   => $value,
  			%attrs,
  		);
  	}
  	else
  	{
  		$exception_class->throw(
  			message => sprintf('%s did not pass type constraint "%s"', _dd($value), $name),
  			value   => $value,
  			%attrs,
  		);
  	}
  }

  sub coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->coerce(@_);
  }

  sub assert_coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->assert_coerce(@_);
  }

  sub is_parameterizable
  {
  	shift->has_constraint_generator;
  }

  sub is_parameterized
  {
  	shift->has_parameters;
  }

  my %param_cache;
  sub parameterize
  {
  	my $self = shift;

  	$self->is_parameterizable
  		or @_ ? _croak("Type '%s' does not accept parameters", "$self") : return($self);

  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;

  	# Generate a key for caching parameterized type constraints,
  	# but only if all the parameters are strings or type constraints.
  	my $key;
  	if ( not grep(ref($_) && !Types::TypeTiny::TypeTiny->check($_), @_) )
  	{
  		require B;
  		$key = join ":", map(Types::TypeTiny::TypeTiny->check($_) ? $_->{uniq} : B::perlstring($_), $self, @_);
  	}

  	return $param_cache{$key} if defined $key && defined $param_cache{$key};

  	local $Type::Tiny::parameterize_type = $self;
  	local $_ = $_[0];
  	my $P;

  	my ($constraint, $compiled) = $self->constraint_generator->(@_);

  	if (Types::TypeTiny::TypeTiny->check($constraint))
  	{
  		$P = $constraint;
  	}
  	else
  	{
  		my %options = (
  			constraint   => $constraint,
  			display_name => $self->name_generator->($self, @_),
  			parameters   => [@_],
  		);
  		$options{compiled_type_constraint} = $compiled
  			if $compiled;
  		$options{inlined} = $self->inline_generator->(@_)
  			if $self->has_inline_generator;
  		exists $options{$_} && !defined $options{$_} && delete $options{$_}
  			for keys %options;

  		$P = $self->create_child_type(%options);

  		my $coercion;
  		$coercion = $self->coercion_generator->($self, $P, @_)
  			if $self->has_coercion_generator;
  		$P->coercion->add_type_coercions( @{$coercion->type_coercion_map} )
  			if $coercion;
  	}

  	if (defined $key)
  	{
  		$param_cache{$key} = $P;
  		weaken($param_cache{$key});
  	}

  	$P->coercion->freeze;

  	return $P;
  }

  sub child_type_class
  {
  	__PACKAGE__;
  }

  sub create_child_type
  {
  	my $self = shift;
  	return $self->child_type_class->new(parent => $self, @_);
  }

  sub complementary_type
  {
  	my $self = shift;
  	my $r    = ($self->{complementary_type} ||= $self->_build_complementary_type);
  	weaken($self->{complementary_type}) unless isweak($self->{complementary_type});
  	return $r;
  }

  sub _build_complementary_type
  {
  	my $self = shift;
  	my %opts = (
  		constraint   => sub { not $self->check($_) },
  		display_name => sprintf("~%s", $self),
  	);
  	$opts{display_name} =~ s/^\~{2}//;
  	$opts{inlined} = sub { shift; "not(".$self->inline_check(@_).")" }
  		if $self->can_be_inlined;
  	return "Type::Tiny"->new(%opts);
  }

  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	require Moose::Meta::TypeConstraint;
  	return "Moose::Meta::TypeConstraint"->new(%opts);
  }

  sub _build_moose_type
  {
  	my $self = shift;

  	my $r;
  	if ($self->{_is_core})
  	{
  		require Moose::Util::TypeConstraints;
  		$r = Moose::Util::TypeConstraints::find_type_constraint($self->name);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		Scalar::Util::weaken($r->{"Types::TypeTiny::to_TypeTiny"});
  	}
  	else
  	{
  		my $wrapped_inlined = sub {
  			shift;
  			$self->inline_check(@_);
  		};

  		my %opts;
  		$opts{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  		$opts{parent}     = $self->parent->moose_type if $self->has_parent;
  		$opts{constraint} = $self->constraint         unless $self->_is_null_constraint;
  		$opts{message}    = $self->message            if $self->has_message;
  		$opts{inlined}    = $wrapped_inlined          if $self->has_inlined;

  		$r = $self->_instantiate_moose_type(%opts);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		$self->{moose_type} = $r;  # prevent recursion
  		$r->coercion($self->coercion->moose_coercion) if $self->has_coercion;
  	}

  	return $r;
  }

  sub _build_mouse_type
  {
  	my $self = shift;

  	my %options;
  	$options{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  	$options{parent}     = $self->parent->mouse_type if $self->has_parent;
  	$options{constraint} = $self->constraint         unless $self->_is_null_constraint;
  	$options{message}    = $self->message            if $self->has_message;

  	require Mouse::Meta::TypeConstraint;
  	my $r = "Mouse::Meta::TypeConstraint"->new(%options);

  	$self->{mouse_type} = $r;  # prevent recursion
  	$r->_add_type_coercions(
  		$self->coercion->freeze->_codelike_type_coercion_map('mouse_type')
  	) if $self->has_coercion;

  	return $r;
  }

  sub _process_coercion_list
  {
  	my $self = shift;

  	my @pairs;
  	while (@_)
  	{
  		my $next = shift;
  		if (blessed($next) and $next->isa('Type::Coercion') and $next->is_parameterized)
  		{
  			push @pairs => (
  				@{ $next->_reparameterize($self)->type_coercion_map }
  			);
  		}
  		elsif (blessed($next) and $next->can('type_coercion_map'))
  		{
  			push @pairs => (
  				@{ $next->type_coercion_map },
  			);
  		}
  		elsif (ref($next) eq q(ARRAY))
  		{
  			unshift @_, @$next;
  		}
  		else
  		{
  			push @pairs => (
  				Types::TypeTiny::to_TypeTiny($next),
  				shift,
  			);
  		}
  	}

  	return @pairs;
  }

  sub plus_coercions
  {
  	my $self = shift;
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		$self->_process_coercion_list(@_),
  		@{$self->coercion->type_coercion_map},
  	);
  	$new->coercion->freeze;
  	return $new;
  }

  sub plus_fallback_coercions
  {
  	my $self = shift;

  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		@{$self->coercion->type_coercion_map},
  		$self->_process_coercion_list(@_),
  	);
  	$new->coercion->freeze;
  	return $new;
  }

  sub minus_coercions
  {
  	my $self = shift;

  	my $new = $self->_clone;
  	my @not = grep Types::TypeTiny::TypeTiny->check($_), $self->_process_coercion_list($new, @_);

  	my @keep;
  	my $c = $self->coercion->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		my $keep_this = 1;
  		NOT: for my $n (@not)
  		{
  			if ($c->[$i] == $n)
  			{
  				$keep_this = 0;
  				last NOT;
  			}
  		}

  		push @keep, $c->[$i], $c->[$i+1] if $keep_this;
  	}

  	$new->coercion->add_type_coercions(@keep);
  	$new->coercion->freeze;
  	return $new;
  }

  sub no_coercions
  {
  	my $new = shift->_clone;
  	$new->coercion->freeze;
  	$new;
  }

  sub coercibles
  {
  	my $self = shift;
  	$self->has_coercion ? $self->coercion->_source_type_union : $self;
  }

  sub isa
  {
  	my $self = shift;

  	if ($INC{"Moose.pm"} and ref($self) and $_[0] =~ /^(?:Class::MOP|MooseX?::Meta)::(.+)$/)
  	{
  		my $meta = $1;

  		return !!1                             if $meta eq 'TypeConstraint';
  		return $self->is_parameterized         if $meta eq 'TypeConstraint::Parameterized';
  		return $self->is_parameterizable       if $meta eq 'TypeConstraint::Parameterizable';
  		return $self->isa('Type::Tiny::Union') if $meta eq 'TypeConstraint::Union';

  		my $inflate = $self->moose_type;
  		return $inflate->isa(@_);
  	}

  	if ($INC{"Mouse.pm"} and ref($self) and $_[0] eq 'Mouse::Meta::TypeConstraint')
  	{
  		return !!1;
  	}

  	$self->SUPER::isa(@_);
  }

  sub _build_my_methods
  {
  	return {};
  }

  sub _lookup_my_method
  {
  	my $self = shift;
  	my ($name) = @_;

  	if ($self->my_methods->{$name})
  	{
  		return $self->my_methods->{$name};
  	}

  	if ($self->has_parent)
  	{
  		return $self->parent->_lookup_my_method(@_);
  	}

  	return;
  }

  sub can
  {
  	my $self = shift;

  	return !!0 if $_[0] eq 'type_parameter' && blessed($_[0]) && $_[0]->has_parameters;

  	my $can = $self->SUPER::can(@_);
  	return $can if $can;

  	if (ref($self))
  	{
  		if ($INC{"Moose.pm"})
  		{
  			my $method = $self->moose_type->can(@_);
  			return sub { shift->moose_type->$method(@_) } if $method;
  		}
  		if ($_[0] =~ /\Amy_(.+)\z/)
  		{
  			my $method = $self->_lookup_my_method($1);
  			return $method if $method;
  		}
  	}

  	return;
  }

  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';

  	if (ref($self))
  	{
  		if ($INC{"Moose.pm"})
  		{
  			my $method = $self->moose_type->can($m);
  			return $self->moose_type->$method(@_) if $method;
  		}
  		if ($m =~ /\Amy_(.+)\z/)
  		{
  			my $method = $self->_lookup_my_method($1);
  			return $self->$method(@_) if $method;
  		}
  	}

  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }

  sub DOES
  {
  	my $self = shift;

  	return !!1 if  ref($self) && $_[0] =~ m{^ Type::API::Constraint (?: ::Coercible | ::Inlinable )? $}x;
  	return !!1 if !ref($self) && $_[0] eq 'Type::API::Constraint::Constructor';

  	"UNIVERSAL"->can("DOES") ? $self->SUPER::DOES(@_) : $self->isa(@_);
  }

  sub _has_xsub
  {
  	require B;
  	!!B::svref_2object( shift->compiled_check )->XSUB;
  }

  sub of                         { shift->parameterize(@_) }
  sub where                      { shift->create_child_type(constraint => @_) }

  # fill out Moose-compatible API
  sub inline_environment         { +{} }
  sub _inline_check              { shift->inline_check(@_) }
  sub _compiled_type_constraint  { shift->compiled_check(@_) }
  sub meta                       { _croak("Not really a Moose::Meta::TypeConstraint. Sorry!") }
  sub compile_type_constraint    { shift->compiled_check }
  sub _actually_compile_type_constraint   { shift->_build_compiled_check }
  sub hand_optimized_type_constraint      { shift->{hand_optimized_type_constraint} }
  sub has_hand_optimized_type_constraint  { exists(shift->{hand_optimized_type_constraint}) }
  sub type_parameter             { (shift->parameters || [])->[0] }

  # some stuff for Mouse-compatible API
  sub __is_parameterized         { shift->is_parameterized(@_) }
  sub _add_type_coercions        { shift->coercion->add_type_coercions(@_) };
  sub _as_string                 { shift->qualified_name(@_) }
  sub _compiled_type_coercion    { shift->coercion->compiled_coercion(@_) };
  sub _identity                  { refaddr(shift) };
  sub _unite                     { require Type::Tiny::Union; "Type::Tiny::Union"->new(type_constraints => \@_) };

  # Hooks for Type::Tie
  sub TIESCALAR  { require Type::Tie; unshift @_, 'Type::Tie::SCALAR'; goto \&Type::Tie::SCALAR::TIESCALAR };
  sub TIEARRAY   { require Type::Tie; unshift @_, 'Type::Tie::ARRAY';  goto \&Type::Tie::ARRAY::TIEARRAY };
  sub TIEHASH    { require Type::Tie; unshift @_, 'Type::Tie::HASH';   goto \&Type::Tie::HASH::TIEHASH };

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords Moo(se)-compatible MooseX MouseX MooX Moose-compat invocant

  =head1 NAME

  Type::Tiny - tiny, yet Moo(se)-compatible type constraint

  =head1 SYNOPSIS

     use Scalar::Util qw(looks_like_number);
     use Type::Tiny;

     my $NUM = "Type::Tiny"->new(
        name       => "Number",
        constraint => sub { looks_like_number($_) },
        message    => sub { "$_ ain't a number" },
     );

     package Ermintrude {
        use Moo;
        has favourite_number => (is => "ro", isa => $NUM);
     }

     package Bullwinkle {
        use Moose;
        has favourite_number => (is => "ro", isa => $NUM);
     }

     package Maisy {
        use Mouse;
        has favourite_number => (is => "ro", isa => $NUM);
     }

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  L<Type::Tiny> is a tiny class for creating Moose-like type constraint
  objects which are compatible with Moo, Moose and Mouse.

  Maybe now we won't need to have separate MooseX, MouseX and MooX versions
  of everything? We can but hope...

  This documents the internals of L<Type::Tiny>. L<Type::Tiny::Manual> is
  a better starting place if you're new.

  =head2 Constructor

  =over

  =item C<< new(%attributes) >>

  Moose-style constructor function.

  =back

  =head2 Attributes

  Attributes are named values that may be passed to the constructor. For
  each attribute, there is a corresponding reader method. For example:

     my $type = Type::Tiny->new( name => "Foo" );
     print $type->name, "\n";   # says "Foo"

  =head3 Important attributes

  These are the attributes you are likely to be most interested in
  providing when creating your own type constraints, and most interested
  in reading when dealing with type constraint objects.

  =over

  =item C<< constraint >>

  Coderef to validate a value (C<< $_ >>) against the type constraint. The
  coderef will not be called unless the value is known to pass any parent
  type constraint (see C<parent> below).

  Defaults to C<< sub { 1 } >> - i.e. a coderef that passes all values.

  =item C<< parent >>

  Optional attribute; parent type constraint. For example, an "Integer"
  type constraint might have a parent "Number".

  If provided, must be a Type::Tiny object.

  =item C<< inlined >>

  A coderef which returns a string of Perl code suitable for inlining this
  type. Optional.

  If C<constraint> (above) is a coderef generated via L<Sub::Quote>, then
  Type::Tiny I<may> be able to automatically generate C<inlined> for you.

  =item C<< name >>

  The name of the type constraint. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).

  Optional; if not supplied will be an anonymous type constraint.

  =item C<< display_name >>

  A name to display for the type constraint when stringified. These don't
  have to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.

  =item C<< library >>

  The package name of the type library this type is associated with.
  Optional. Informational only: setting this attribute does not install
  the type into the package.

  =item C<< message >>

  Coderef that returns an error message when C<< $_ >> does not validate
  against the type constraint. Optional (there's a vaguely sensible default.)

  =item C<< coercion >>

  A L<Type::Coercion> object associated with this type.

  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built coercion object.

  You may pass C<< coercion => 1 >> to the constructor to inherit coercions
  from the constraint's parent. (This requires the parent constraint to have
  a coercion.)

  =item C<< my_methods >>

  Experimenal hashref of additional methods that can be called on the type
  constraint object.

  =back

  =head3 Attributes related to parameterizable and parameterized types

  The following additional attributes are used for parameterizable (e.g.
  C<ArrayRef>) and parameterized (e.g. C<< ArrayRef[Int] >>) type
  constraints. Unlike Moose, these aren't handled by separate subclasses.

  =over

  =item C<< constraint_generator >>

  Coderef that generates a new constraint coderef based on parameters.
  Alternatively, the constraint generator can return a fully-formed
  Type::Tiny object, in which case the C<name_generator>, C<inline_generator>,
  and C<coercion_generator> attributes documented below are ignored.

  Optional; providing a generator makes this type into a parameterizable
  type constraint.

  =item C<< name_generator >>

  A coderef which generates a new display_name based on parameters.
  Optional; the default is reasonable.

  =item C<< inline_generator >>

  A coderef which generates a new inlining coderef based on parameters.

  =item C<< coercion_generator >>

  A coderef which generates a new L<Type::Coercion> object based on parameters.

  =item C<< deep_explanation >>

  This API is not finalized. Coderef used by L<Error::TypeTiny::Assertion> to
  peek inside parameterized types and figure out why a value doesn't pass the
  constraint.

  =item C<< parameters >>

  In parameterized types, returns an arrayref of the parameters.

  =back

  =head3 Lazy generated attributes

  The following attributes should not be usually passed to the constructor;
  unless you're doing something especially unusual, you should rely on the
  default lazily-built return values.

  =over

  =item C<< compiled_check >>

  Coderef to validate a value (C<< $_[0] >>) against the type constraint.
  This coderef is expected to also handle all validation for the parent
  type constraints.

  =item C<< complementary_type >>

  A complementary type for this type. For example, the complementary type
  for an integer type would be all things that are not integers, including
  floating point numbers, but also alphabetic strings, arrayrefs, filehandles,
  etc.

  =item C<< moose_type >>, C<< mouse_type >>

  Objects equivalent to this type constraint, but as a
  L<Moose::Meta::TypeConstraint> or L<Mouse::Meta::TypeConstraint>.

  It should rarely be necessary to obtain a L<Moose::Meta::TypeConstraint>
  object from L<Type::Tiny> because the L<Type::Tiny> object itself should
  be usable pretty much anywhere a L<Moose::Meta::TypeConstraint> is expected.

  =back

  =head2 Methods

  =head3 Predicate methods

  These methods return booleans indicating information about the type
  constraint. They are each tightly associated with a particular attribute.
  (See L</"Attributes">.)

  =over

  =item C<has_parent>, C<has_library>, C<has_inlined>, C<has_constraint_generator>, C<has_inline_generator>, C<has_coercion_generator>, C<has_parameters>, C<has_message>, C<has_deep_explanation>

  Simple Moose-style predicate methods indicating the presence or
  absence of an attribute.

  =item C<has_coercion>

  Predicate method with a little extra DWIM. Returns false if the coercion is
  a no-op.

  =item C<< is_anon >>

  Returns true iff the type constraint does not have a C<name>.

  =item C<< is_parameterized >>, C<< is_parameterizable >>

  Indicates whether a type has been parameterized (e.g. C<< ArrayRef[Int] >>)
  or could potentially be (e.g. C<< ArrayRef >>).

  =back

  =head3 Validation and coercion

  The following methods are used for coercing and validating values
  against a type constraint:

  =over

  =item C<< check($value) >>

  Returns true iff the value passes the type constraint.

  =item C<< validate($value) >>

  Returns the error message for the value; returns an explicit undef if the
  value passes the type constraint.

  =item C<< assert_valid($value) >>

  Like C<< check($value) >> but dies if the value does not pass the type
  constraint.

  Yes, that's three very similar methods. Blame L<Moose::Meta::TypeConstraint>
  whose API I'm attempting to emulate. :-)

  =item C<< assert_return($value) >>

  Like C<< assert_valid($value) >> but returns the value if it passes the type
  constraint.

  This seems a more useful behaviour than C<< assert_valid($value) >>. I would
  have just changed C<< assert_valid($value) >> to do this, except that there
  are edge cases where it could break Moose compatibility.

  =item C<< get_message($value) >>

  Returns the error message for the value; even if the value passes the type
  constraint.

  =item C<< validate_explain($value, $varname) >>

  Like C<validate> but instead of a string error message, returns an arrayref
  of strings explaining the reasoning why the value does not meet the type
  constraint, examining parent types, etc.

  The C<< $varname >> is an optional string like C<< '$foo' >> indicating the
  name of the variable being checked.

  =item C<< coerce($value) >>

  Attempt to coerce C<< $value >> to this type.

  =item C<< assert_coerce($value) >>

  Attempt to coerce C<< $value >> to this type. Throws an exception if this is
  not possible.

  =back

  =head3 Child type constraint creation and parameterization

  These methods generate new type constraint objects that inherit from the
  constraint they are called upon:

  =over

  =item C<< create_child_type(%attributes) >>

  Construct a new Type::Tiny object with this object as its parent.

  =item C<< where($coderef) >>

  Shortcut for creating an anonymous child type constraint. Use it like
  C<< HashRef->where(sub { exists($_->{name}) }) >>. That said, you can
  get a similar result using overloaded C<< & >>:

     HashRef & sub { exists($_->{name}) }

  =item C<< child_type_class >>

  The class that create_child_type will construct by default.

  =item C<< parameterize(@parameters) >>

  Creates a new parameterized type; throws an exception if called on a
  non-parameterizable type.

  =item C<< of(@parameters) >>

  A cute alias for C<parameterize>. Use it like C<< ArrayRef->of(Int) >>.

  =item C<< plus_coercions($type1, $code1, ...) >>

  Shorthand for creating a new child type constraint with the same coercions
  as this one, but then adding some extra coercions (at a higher priority than
  the existing ones).

  =item C<< plus_fallback_coercions($type1, $code1, ...) >>

  Like C<plus_coercions>, but added at a lower priority.

  =item C<< minus_coercions($type1, ...) >>

  Shorthand for creating a new child type constraint with fewer type coercions.

  =item C<< no_coercions >>

  Shorthand for creating a new child type constraint with no coercions at all.

  =back

  =head3 Type relationship introspection methods

  These methods allow you to determine a type constraint's relationship to
  other type constraints in an organised hierarchy:

  =over

  =item C<< equals($other) >>, C<< is_subtype_of($other) >>, C<< is_supertype_of($other) >>, C<< is_a_type_of($other) >>

  Compare two types. See L<Moose::Meta::TypeConstraint> for what these all mean.
  (OK, Moose doesn't define C<is_supertype_of>, but you get the idea, right?)

  Note that these have a slightly DWIM side to them. If you create two
  L<Type::Tiny::Class> objects which test the same class, they're considered
  equal. And:

     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_subtype_of( $subtype_of_Num );  # true

  =item C<< strictly_equals($other) >>, C<< is_strictly_subtype_of($other) >>, C<< is_strictly_supertype_of($other) >>, C<< is_strictly_a_type_of($other) >>

  Stricter versions of the type comparison functions. These only care about
  explicit inheritance via C<parent>.

     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_strictly_subtype_of( $subtype_of_Num );  # false

  =item C<< parents >>

  Returns a list of all this type constraint's ancestor constraints. For
  example, if called on the C<Str> type constraint would return the list
  C<< (Value, Defined, Item, Any) >>.

  B<< Due to a historical misunderstanding, this differs from the Moose
  implementation of the C<parents> method. In Moose, C<parents> only returns the
  immediate parent type constraints, and because type constraints only have
  one immediate parent, this is effectively an alias for C<parent>. The
  extension module L<MooseX::Meta::TypeConstraint::Intersection> is the only
  place where multiple type constraints are returned; and they are returned
  as an arrayref in violation of the base class' documentation. I'm keeping
  my behaviour as it seems more useful. >>

  =item C<< find_parent($coderef) >>

  Loops through the parent type constraints I<< including the invocant
  itself >> and returns the nearest ancestor type constraint where the
  coderef evaluates to true. Within the coderef the ancestor currently
  being checked is C<< $_ >>. Returns undef if there is no match.

  In list context also returns the number of type constraints which had
  been looped through before the matching constraint was found.

  =item C<< coercibles >>

  Return a type constraint which is the union of type constraints that can be
  coerced to this one (including this one). If this type constraint has no
  coercions, returns itself.

  =item C<< type_parameter >>

  In parameterized type constraints, returns the first item on the list of
  parameters; otherwise returns undef. For example:

     ( ArrayRef[Int] )->type_parameter;    # returns Int
     ( ArrayRef[Int] )->parent;            # returns ArrayRef

  Note that parameterizable type constraints can perfectly legitimately take
  multiple parameters (several off the parameterizable type constraints in
  L<Types::Standard> do). This method only returns the first such parameter.
  L</"Attributes related to parameterizable and parameterized types">
  documents the C<parameters> attribute, which returns an arrayref of all
  the parameters.

  =back

  =head3 Inlining methods

  =for stopwords uated

  The following methods are used to generate strings of Perl code which
  may be pasted into stringy C<eval>uated subs to perform type checks:

  =over

  =item C<< can_be_inlined >>

  Returns boolean indicating if this type can be inlined.

  =item C<< inline_check($varname) >>

  Creates a type constraint check for a particular variable as a string of
  Perl code. For example:

     print( Types::Standard::Num->inline_check('$foo') );

  prints the following output:

     (!ref($foo) && Scalar::Util::looks_like_number($foo))

  For Moose-compat, there is an alias C<< _inline_check >> for this method.

  =item C<< inline_assert($varname) >>

  Much like C<inline_check> but outputs a statement of the form:

     die ... unless ...;

  Note that if this type has a custom error message, the inlined code will
  I<ignore> this custom message!!

  =back

  =head3 Other methods

  =over

  =item C<< qualified_name >>

  For non-anonymous type constraints that have a library, returns a qualified
  C<< "MyLib::MyType" >> sort of name. Otherwise, returns the same as C<name>.

  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>

  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeConstraint.

  If Mouse is loaded, then C<isa> mocks Mouse::Meta::TypeConstraint.

  =item C<< DOES($role) >>

  Overridden to advertise support for various roles.

  See also L<Type::API::Constraint>, etc.

  =item C<< TIESCALAR >>, C<< TIEARRAY >>, C<< TIEHASH >>

  These are provided as hooks that wrap L<Type::Tie>. (Type::Tie is distributed
  separately, and can be used with non-Type::Tiny type constraints too.) They
  allow the following to work:

     use Types::Standard qw(Int);
     tie my @list, Int;
     push @list, 123, 456;   # ok
     push @list, "Hello";    # dies

  =back

  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.

  =over

  =item C<< compile_type_constraint >>

  =item C<< hand_optimized_type_constraint >>

  =item C<< has_hand_optimized_type_constraint >>

  =item C<< inline_environment >>

  =item C<< meta >>

  =back

  =head2 Overloading

  =over

  =item *

  Stringification is overloaded to return the qualified name.

  =item *

  Boolification is overloaded to always return true.

  =item *

  Coderefification is overloaded to call C<assert_return>.

  =item *

  On Perl 5.10.1 and above, smart match is overloaded to call C<check>.

  =item *

  The C<< == >> operator is overloaded to call C<equals>.

  =item *

  The C<< < >> and C<< > >> operators are overloaded to call C<is_subtype_of>
  and C<is_supertype_of>.

  =item *

  The C<< ~ >> operator is overloaded to call C<complementary_type>.

  =item *

  The C<< | >> operator is overloaded to build a union of two type constraints.
  See L<Type::Tiny::Union>.

  =item *

  The C<< & >> operator is overloaded to build the intersection of two type
  constraints. See L<Type::Tiny::Intersection>.

  =back

  Previous versions of Type::Tiny would overload the C<< + >> operator to
  call C<plus_coercions> or C<plus_fallback_coercions> as appropriate.
  Support for this was dropped after 0.040.

  =head2 Constants

  =over

  =item C<< Type::Tiny::SUPPORT_SMARTMATCH >>

  Indicates whether the smart match overload is supported on your
  version of Perl.

  =back

  =head2 Package Variables

  =over

  =item C<< $Type::Tiny::DD >>

  This undef by default but may be set to a coderef that Type::Tiny
  and related modules will use to dump data structures in things like
  error messages.

  Otherwise Type::Tiny uses it's own routine to dump data structures.
  C<< $DD >> may then be set to a number to limit the lengths of the
  dumps. (Default limit is 72.)

  This is a package variable (rather than get/set class methods) to allow
  for easy localization.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SUPPORT

  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>, L<Type::API>.

  L<Type::Library>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.

  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>, L<Type::Tiny::Intersection>.

  L<Moose::Meta::TypeConstraint>,
  L<Mouse::Meta::TypeConstraint>.

  L<Type::Params>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 THANKS

  Thanks to Matt S Trout for advice on L<Moo> integration.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_TINY

$fatpacked{"Type/Tiny/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_CLASS';
  package Type::Tiny::Class;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }

  BEGIN {
  	$Type::Tiny::Class::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Class::VERSION   = '1.000005';
  }

  use Scalar::Util qw< blessed >;

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  use Type::Tiny ();
  our @ISA = 'Type::Tiny';

  sub new {
  	my $proto = shift;
  	return $proto->class->new(@_) if blessed $proto; # DWIM

  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Class type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Class type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Class type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply class name" unless exists $opts{class};

  	if (Type::Tiny::_USE_XS)
  	{
  		my $xsub = Type::Tiny::XS::get_coderef_for("InstanceOf[".$opts{class}."]");
  		$opts{compiled_type_constraint} = $xsub if $xsub;
  	}
  	elsif (Type::Tiny::_USE_MOUSE)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("generate_isa_predicate_for");
  		$opts{compiled_type_constraint} = $maker->($opts{class}) if $maker;
  	}

  	return $proto->SUPER::new(%opts);
  }

  sub class       { $_[0]{class} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }

  sub has_inlined { !!1 }

  sub _build_constraint
  {
  	my $self  = shift;
  	my $class = $self->class;
  	return sub { blessed($_) and $_->isa($class) };
  }

  sub _build_inlined
  {
  	my $self  = shift;
  	my $class = $self->class;

  	if (Type::Tiny::_USE_XS)
  	{
  		my $xsub = Type::Tiny::XS::get_subname_for("InstanceOf[$class]");
  		return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  	}

  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and $var->isa(q[$class])};
  	};
  }

  sub _build_default_message
  {
  	no warnings 'uninitialized';
  	my $self = shift;
  	my $c = $self->class;
  	return sub { sprintf '%s did not pass type constraint (not isa %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not isa %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }

  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Class;
  	return "Moose::Meta::TypeConstraint::Class"->new(%opts, class => $self->class);
  }

  sub plus_constructors
  {
  	my $self = shift;

  	unless (@_)
  	{
  		require Types::Standard;
  		push @_, Types::Standard::HashRef(), "new";
  	}

  	require B;
  	require Types::TypeTiny;

  	my $class = B::perlstring($self->class);

  	my @r;
  	while (@_)
  	{
  		my $source = shift;
  		Types::TypeTiny::TypeTiny->check($source)
  			or _croak "Expected type constraint; got $source";

  		my $constructor = shift;
  		Types::TypeTiny::StringLike->check($constructor)
  			or _croak "Expected string; got $constructor";

  		push @r, $source, sprintf('%s->%s($_)', $class, $constructor);
  	}

  	return $self->plus_coercions(\@r);
  }

  sub has_parent
  {
  	!!1;
  }

  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }

  sub _build_parent
  {
  	my $self  = shift;
  	my $class = $self->class;

  	# Some classes (I'm looking at you, Math::BigFloat) include a class in
  	# their @ISA to inherit methods, but then override isa() to return false,
  	# so that they don't appear to be a subclass.
  	#
  	# In these cases, we don't want to list the parent class as a parent
  	# type constraint.
  	#
  	my @isa = grep $class->isa($_), do { no strict "refs"; no warnings; @{"$class\::ISA"} };

  	if (@isa == 0)
  	{
  		require Types::Standard;
  		return Types::Standard::Object();
  	}

  	if (@isa == 1)
  	{
  		return ref($self)->new(class => $isa[0])
  	}

  	require Type::Tiny::Intersection;
  	"Type::Tiny::Intersection"->new(
  		type_constraints => [ map ref($self)->new(class => $_), @isa ],
  	);
  }

  *__get_linear_isa_dfs = eval { require mro }
  	? \&mro::get_linear_isa
  	: sub {
  		no strict 'refs';

  		my $classname = shift;
  		my @lin = ($classname);
  		my %stored;

  		foreach my $parent (@{"$classname\::ISA"})
  		{
  			my $plin = __get_linear_isa_dfs($parent);
  			foreach (@$plin) {
  				next if exists $stored{$_};
  				push(@lin, $_);
  				$stored{$_} = 1;
  			}
  		}

  		return \@lin;
  	};

  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;

  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);

  	my @isa = @{ __get_linear_isa_dfs(ref $value) };

  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);

  	require Type::Utils;
  	return [
  		sprintf('"%s" requires that the reference isa %s', $self, $self->class),
  		sprintf('The reference%s isa %s', $display_var, Type::Utils::english_list(@isa)),
  	];
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Type::Tiny::Class - type constraints based on the "isa" method

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Type constraints of the general form C<< { $_->isa("Some::Class") } >>.

  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:

  =head2 Constructor

  =over

  =item C<new>

  When the constructor is called on an I<instance> of Type::Tiny::Class, it
  passes the call through to the constructor of the class for the constraint.
  So for example:

     my $type = Type::Tiny::Class->new(class => "Foo::Bar");
     my $obj  = $type->new(hello => "World");
     say ref($obj);   # prints "Foo::Bar"

  This little bit of DWIM was borrowed from L<MooseX::Types::TypeDecorator>,
  but Type::Tiny doesn't take the idea quite as far.

  =back

  =head2 Attributes

  =over

  =item C<class>

  The class for the constraint.

  =item C<constraint>

  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.

  =item C<inlined>

  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.

  =item C<parent>

  Parent is automatically calculated, and cannot be passed to the constructor.

  =back

  =head2 Methods

  =over

  =item C<< plus_constructors($source, $method_name) >>

  Much like C<plus_coercions> but adds coercions that go via a constructor.
  (In fact, this is implemented as a wrapper for C<plus_coercions>.)

  Example:

     package MyApp::Minion;

     use Moose; extends "MyApp::Person";

     use Types::Standard qw( HashRef Str );
     use Type::Utils qw( class_type );

     my $Person = class_type({ class => "MyApp::Person" });

     has boss => (
        is     => "ro",
        isa    => $Person->plus_constructors(
           HashRef,     "new",
           Str,         "_new_from_name",
        ),
        coerce => 1,
     );

     package main;

     MyApp::Minion->new(
        ...,
        boss => "Bob",  ## via MyApp::Person->_new_from_name
     );

     MyApp::Minion->new(
        ...,
        boss => { name => "Bob" },  ## via MyApp::Person->new
     );

  Because coercing C<HashRef> via constructor is a common desire, if
  you call C<plus_constructors> with no arguments at all, this is the
  default.

     $classtype->plus_constructors(Types::Standard::HashRef, "new")
     $classtype->plus_constructors()  ## identical to above

  This is handy for Moose/Mouse/Moo-based classes.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>.

  L<Moose::Meta::TypeConstraint::Class>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_TINY_CLASS

$fatpacked{"Type/Tiny/Duck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_DUCK';
  package Type::Tiny::Duck;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Tiny::Duck::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Duck::VERSION   = '1.000005';
  }

  use Scalar::Util qw< blessed >;

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  use Type::Tiny ();
  our @ISA = 'Type::Tiny';

  sub new {
  	my $proto = shift;

  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Duck type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Duck type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Duck type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of methods" unless exists $opts{methods};

  	$opts{methods} = [$opts{methods}] unless ref $opts{methods};

  	if (Type::Tiny::_USE_XS)
  	{
  		my $methods = join ",", sort(@{$opts{methods}});
  		my $xsub    = Type::Tiny::XS::get_coderef_for("HasMethods[$methods]");
  		$opts{compiled_type_constraint} = $xsub if $xsub;
  	}
  	elsif (Type::Tiny::_USE_MOUSE)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("generate_can_predicate_for");
  		$opts{compiled_type_constraint} = $maker->($opts{methods}) if $maker;
  	}

  	return $proto->SUPER::new(%opts);
  }

  sub methods     { $_[0]{methods} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }

  sub has_inlined { !!1 }

  sub _build_constraint
  {
  	my $self    = shift;
  	my @methods = @{$self->methods};
  	return sub { blessed($_[0]) and not grep(!$_[0]->can($_), @methods) };
  }

  sub _build_inlined
  {
  	my $self = shift;
  	my @methods = @{$self->methods};

  	if (Type::Tiny::_USE_XS)
  	{
  		my $methods = join ",", sort(@{$self->methods});
  		my $xsub    = Type::Tiny::XS::get_subname_for("HasMethods[$methods]");
  		return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  	}

  	sub {
  		my $var = $_[1];
  		local $" = q{ };
  		# If $var is $_ or $_->{foo} or $foo{$_} or somesuch, then we
  		# can't use it within the grep expression, so we need to save
  		# it into a temporary variable ($tmp).
  		($var =~ /\$_/)
  			? qq{ Scalar::Util::blessed($var) and not do { my \$tmp = $var; grep(!\$tmp->can(\$_), qw/@methods/) } }
  			: qq{ Scalar::Util::blessed($var) and not grep(!$var->can(\$_), qw/@methods/) };
  	};
  }

  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};

  	require Moose::Meta::TypeConstraint::DuckType;
  	return "Moose::Meta::TypeConstraint::DuckType"->new(%opts, methods => $self->methods);
  }

  sub has_parent
  {
  	!!1;
  }

  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }

  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;

  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);

  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the reference can %s',
  			$self,
  			Type::Utils::english_list(map qq["$_"], @{$self->methods}),
  		),
  		map  sprintf('The reference cannot "%s"', $_),
  		grep !$value->can($_),
  		@{$self->methods}
  	];
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Type::Tiny::Duck - type constraints based on the "can" method

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Type constraints of the general form C<< { $_->can("method") } >>.

  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:

  =head2 Attributes

  =over

  =item C<methods>

  An arrayref of method names.

  =item C<constraint>

  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.

  =item C<inlined>

  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.

  =item C<parent>

  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>.

  L<Moose::Meta::TypeConstraint::DuckType>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_TINY_DUCK

$fatpacked{"Type/Tiny/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ENUM';
  package Type::Tiny::Enum;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Tiny::Enum::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Enum::VERSION   = '1.000005';
  }

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  use overload q[@{}] => 'values';

  use Type::Tiny ();
  our @ISA = 'Type::Tiny';

  sub new
  {
  	my $proto = shift;

  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Enum type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Enum type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Enum type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of values" unless exists $opts{values};

  	my %tmp =
  		map { $_ => 1 }
  		@{ ref $opts{values} eq "ARRAY" ? $opts{values} : [$opts{values}] };
  	$opts{values} = [sort keys %tmp];

  	if (Type::Tiny::_USE_XS and not grep /[^-\w]/, @{$opts{values}})
  	{
  		my $enum = join ",", @{$opts{values}};
  		my $xsub = Type::Tiny::XS::get_coderef_for("Enum[$enum]");
  		$opts{compiled_type_constraint} = $xsub if $xsub;
  	}

  	return $proto->SUPER::new(%opts);
  }

  sub values      { $_[0]{values} }
  sub constraint  { $_[0]{constraint} ||= $_[0]->_build_constraint }

  sub _build_display_name
  {
  	my $self = shift;
  	sprintf("Enum[%s]", join q[,], @$self);
  }

  sub _build_constraint
  {
  	my $self = shift;

  	my $regexp = join "|", map quotemeta, @$self;
  	return sub { defined and m{\A(?:$regexp)\z} };
  }

  sub can_be_inlined
  {
  	!!1;
  }

  sub inline_check
  {
  	my $self = shift;

  	if (Type::Tiny::_USE_XS)
  	{
  		my $enum = join ",", @{$self->values};
  		my $xsub = Type::Tiny::XS::get_subname_for("Enum[$enum]");
  		return "$xsub\($_[0]\)" if $xsub;
  	}

  	my $regexp = join "|", map quotemeta, @$self;
  	$_[0] eq '$_'
  		? "(defined and !ref and m{\\A(?:$regexp)\\z})"
  		: "(defined($_[0]) and !ref($_[0]) and $_[0] =~ m{\\A(?:$regexp)\\z})";
  }

  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Enum;
  	return "Moose::Meta::TypeConstraint::Enum"->new(%opts, values => $self->values);
  }

  sub has_parent
  {
  	!!1;
  }

  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Str();
  }

  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;

  	return undef if $self->check($value);

  	require Type::Utils;
  	!defined($value) ? [
  		sprintf(
  			'"%s" requires that the value is defined',
  			$self,
  		),
  	] :
  	@$self < 13 ? [
  		sprintf(
  			'"%s" requires that the value is equal to %s',
  			$self,
  			Type::Utils::english_list(\"or", map B::perlstring($_), @$self),
  		),
  	] :
  	[
  		sprintf(
  			'"%s" requires that the value is one of an enumerated list of strings',
  			$self,
  		),
  	];
  }


  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Type::Tiny::Enum - string enum type constraints

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Enum type constraints.

  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:

  =head2 Attributes

  =over

  =item C<values>

  Arrayref of allowable value strings. Non-string values (e.g. objects with
  overloading) will be stringified in the constructor.

  =item C<constraint>

  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.

  =item C<inlined>

  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.

  =item C<parent>

  Parent is always Types::Standard::Str, and cannot be passed to the
  constructor.

  =back

  =head2 Overloading

  =over

  =item *

  Arrayrefification calls C<values>.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>.

  L<Moose::Meta::TypeConstraint::Enum>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_TINY_ENUM

$fatpacked{"Type/Tiny/Intersection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_INTERSECTION';
  package Type::Tiny::Intersection;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Tiny::Intersection::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Intersection::VERSION   = '1.000005';
  }

  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };

  use Type::Tiny ();
  our @ISA = 'Type::Tiny';

  sub new {
  	my $proto = shift;

  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Intersection type constraints cannot have a parent constraint" if exists $opts{parent};
  	_croak "Intersection type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Intersection type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};

  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];

  	if (Type::Tiny::_USE_XS)
  	{
  		my @constraints = @{$opts{type_constraints}};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;

  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "AllOf[%s]", join(',', @known)
  			);
  			$opts{compiled_type_constraint} = $xsub if $xsub;
  		}
  	}

  	return $proto->SUPER::new(%opts);
  }

  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }

  sub _build_display_name
  {
  	my $self = shift;
  	join q[&], @$self;
  }

  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) || return for @checks;
  		return !!1;
  	}
  }

  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }

  sub inline_check
  {
  	my $self = shift;

  	if (Type::Tiny::_USE_XS and !exists $self->{xs_sub})
  	{
  		$self->{xs_sub} = undef;

  		my @constraints = @{$self->type_constraints};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;

  		if (@known == @constraints)
  		{
  			$self->{xs_sub} = Type::Tiny::XS::get_subname_for(
  				sprintf "AllOf[%s]", join(',', @known)
  			);
  		}
  	}

  	if (Type::Tiny::_USE_XS and $self->{xs_sub}) {
  		return "$self->{xs_sub}\($_[0]\)";
  	}

  	sprintf '(%s)', join " and ", map $_->inline_check($_[0]), @$self;
  }

  sub has_parent
  {
  	!!@{ $_[0]{type_constraints} };
  }

  sub parent
  {
  	$_[0]{type_constraints}[0];
  }

  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;

  	return undef if $self->check($value);

  	require Type::Utils;
  	for my $type (@$self)
  	{
  		my $deep = $type->validate_explain($value, $varname);
  		return [
  			sprintf(
  				'"%s" requires that the value pass %s',
  				$self,
  				Type::Utils::english_list(map qq["$_"], @$self),
  			),
  			@$deep,
  		] if $deep;
  	}

  	# This should never happen...
  	return;  # uncoverable statement
  }


  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Type::Tiny::Intersection - intersection type constraints

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Intersection type constraints.

  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:

  =head2 Attributes

  =over

  =item C<type_constraints>

  Arrayref of type constraints.

  When passed to the constructor, if any of the type constraints in the
  intersection is itself an intersection type constraint, this is "exploded"
  into the new intersection.

  =item C<constraint>

  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.

  =item C<inlined>

  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.

  =item C<parent>

  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.

  (Technically any of the types in the intersection could be treated as a
  parent type; we choose the first arbitrarily.)

  =back

  =head2 Overloading

  =over

  =item *

  Arrayrefification calls C<type_constraints>.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>.

  L<MooseX::Meta::TypeConstraint::Intersection>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_TINY_INTERSECTION

$fatpacked{"Type/Tiny/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ROLE';
  package Type::Tiny::Role;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Tiny::Role::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Role::VERSION   = '1.000005';
  }

  use Scalar::Util qw< blessed weaken >;

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  require Type::Tiny;
  our @ISA = 'Type::Tiny';

  my %cache;

  sub new {
  	my $proto = shift;

  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Role type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Role type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Role type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply role name" unless exists $opts{role};

  	return $proto->SUPER::new(%opts);
  }

  sub role        { $_[0]{role} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }

  sub has_inlined { !!1 }

  sub _build_constraint
  {
  	my $self = shift;
  	my $role = $self->role;
  	return sub { blessed($_) and do { my $method = $_->can('DOES')||$_->can('isa'); $_->$method($role) } };
  }

  sub _build_inlined
  {
  	my $self = shift;
  	my $role = $self->role;
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and do { my \$method = $var->can('DOES')||$var->can('isa'); $var->\$method(q[$role]) }};
  	};
  }

  sub _build_default_message
  {
  	my $self = shift;
  	my $c = $self->role;
  	return sub { sprintf '%s did not pass type constraint (not DOES %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not DOES %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }

  sub has_parent
  {
  	!!1;
  }

  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }

  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;

  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	return ["Reference provides no DOES method to check roles"] unless $value->can('DOES');

  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);

  	return [
  		sprintf('"%s" requires that the reference does %s', $self, $self->role),
  		sprintf("The reference%s doesn't %s", $display_var, $self->role),
  	];
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Type::Tiny::Role - type constraints based on the "DOES" method

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Type constraints of the general form C<< { $_->DOES("Some::Role") } >>.

  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:

  =head2 Attributes

  =over

  =item C<role>

  The role for the constraint.

  Note that this package doesn't subscribe to any particular flavour of roles
  (L<Moose::Role>, L<Mouse::Role>, L<Moo::Role>, L<Role::Tiny>, etc). It simply
  trusts the object's C<DOES> method (see L<UNIVERSAL>).

  =item C<constraint>

  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.

  =item C<inlined>

  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.

  =item C<parent>

  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>.

  L<Moose::Meta::TypeConstraint::Role>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_TINY_ROLE

$fatpacked{"Type/Tiny/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_UNION';
  package Type::Tiny::Union;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Tiny::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Union::VERSION   = '1.000005';
  }

  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };

  use Type::Tiny ();
  our @ISA = 'Type::Tiny';

  sub new {
  	my $proto = shift;

  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Union type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Union type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Union type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};

  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];

  	if (Type::Tiny::_USE_XS)
  	{
  		my @constraints = @{$opts{type_constraints}};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;

  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "AnyOf[%s]", join(',', @known)
  			);
  			$opts{compiled_type_constraint} = $xsub if $xsub;
  		}
  	}

  	my $self = $proto->SUPER::new(%opts);
  	$self->coercion if grep $_->has_coercion, @$self;
  	return $self;
  }

  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }

  sub _build_display_name
  {
  	my $self = shift;
  	join q[|], @$self;
  }

  sub _build_coercion
  {
  	require Type::Coercion::Union;
  	my $self = shift;
  	return "Type::Coercion::Union"->new(type_constraint => $self);
  }

  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) && return !!1 for @checks;
  		return;
  	}
  }

  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }

  sub inline_check
  {
  	my $self = shift;

  	if (Type::Tiny::_USE_XS and !exists $self->{xs_sub})
  	{
  		$self->{xs_sub} = undef;

  		my @constraints = @{$self->type_constraints};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;

  		if (@known == @constraints)
  		{
  			$self->{xs_sub} = Type::Tiny::XS::get_subname_for(
  				sprintf "AnyOf[%s]", join(',', @known)
  			);
  		}
  	}

  	if (Type::Tiny::_USE_XS and $self->{xs_sub}) {
  		return "$self->{xs_sub}\($_[0]\)";
  	}

  	sprintf '(%s)', join " or ", map $_->inline_check($_[0]), @$self;
  }

  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};

  	my @tc = map $_->moose_type, @{$self->type_constraints};

  	require Moose::Meta::TypeConstraint::Union;
  	return "Moose::Meta::TypeConstraint::Union"->new(%opts, type_constraints => \@tc);
  }

  sub has_parent
  {
  	defined(shift->parent);
  }

  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }

  sub _build_parent
  {
  	my $self = shift;
  	my ($first, @rest) = @$self;

  	for my $parent ($first, $first->parents)
  	{
  		return $parent unless grep !$_->is_a_type_of($parent), @rest;
  	}

  	return;
  }

  sub find_type_for
  {
  	my @types = @{+shift};
  	for my $type (@types)
  	{
  		return $type if $type->check(@_);
  	}
  	return;
  }

  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;

  	return undef if $self->check($value);

  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the value pass %s',
  			$self,
  			Type::Utils::english_list(\"or", map qq["$_"], @$self),
  		),
  		map {
  			$_->get_message($value),
  			map("    $_", @{ $_->validate_explain($value) || []}),
  		} @$self
  	];
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Type::Tiny::Union - union type constraints

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Union type constraints.

  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:

  =head2 Attributes

  =over

  =item C<type_constraints>

  Arrayref of type constraints.

  When passed to the constructor, if any of the type constraints in the union
  is itself a union type constraint, this is "exploded" into the new union.

  =item C<constraint>

  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.

  =item C<inlined>

  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.

  =item C<parent>

  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.

  =item C<coercion>

  You probably do not pass this to the constructor. (It's not currently
  disallowed, as there may be a use for it that I haven't thought of.)

  The auto-generated default will be a L<Type::Coercion::Union> object.

  =back

  =head2 Methods

  =over

  =item C<< find_type_for($value) >>

  Returns the first individual type constraint in the union which
  C<< $value >> passes.

  =back

  =head2 Overloading

  =over

  =item *

  Arrayrefification calls C<type_constraints>.

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_TINY_UNION

$fatpacked{"Type/Tiny/_HalfOp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY__HALFOP';
  package Type::Tiny::_HalfOp;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Tiny::_HalfOp::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::_HalfOp::VERSION   = '1.000005';
  }

  use overload ();

  sub new {
  	my ($class, $op, $param, $type) = @_;
  	bless {
  		op    => $op,
  		param => $param,
  		type  => $type,
  	}, $class;
  }

  sub complete {
  	my ($self, $type) = @_;
  	my $complete_type = $type->parameterize(@{$self->{param}});
  	my $method = overload::Method($complete_type, $self->{op});
  	$complete_type->$method($self->{type});
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords pragmas

  =head1 NAME

  Type::Tiny::_HalfOp - half-completed overloaded operation

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This is not considered part of Type::Tiny's public API.

  It is a class representing a half-completed overloaded operation.

  =head2 Constructor

  =over

  =item C<< new($operation, $param, $type) >>

  =back

  =head2 Method

  =over

  =item C<< complete($type) >>

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 AUTHOR

  Graham Knop E<lt>haarg@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2014 by Graham Knop.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_TINY__HALFOP

$fatpacked{"Type/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_UTILS';
  package Type::Utils;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Type::Utils::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Utils::VERSION   = '1.000005';
  }

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  use Scalar::Util qw< blessed >;
  use Type::Library;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny HashLike StringLike CodeLike >;

  our @EXPORT = qw<
  	declare as where message inline_as
  	class_type role_type duck_type union intersection enum
  	coerce from via
  	declare_coercion to_type
  >;
  our @EXPORT_OK = (
  	@EXPORT,
  	qw<
  		extends type subtype
  		match_on_type compile_match_on_type
  		dwim_type english_list
  		classifier
  	>,
  );

  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';

  sub extends
  {
  	_croak "Not a type library" unless caller->isa("Type::Library");
  	my $caller = caller->meta;

  	foreach my $lib (@_)
  	{
  		eval "use $lib; 1" or _croak "Could not load library '$lib': $@";

  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$caller->add_type( $lib->get_type($_) )
  				for sort $lib->meta->type_names;
  			$caller->add_coercion( $lib->get_coercion($_) )
  				for sort $lib->meta->coercion_names;
  		}
  		elsif ($lib->isa('MooseX::Types::Base'))
  		{
  			require Moose::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $moose = Moose::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($moose);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $moose->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		elsif ($lib->isa('MouseX::Types::Base'))
  		{
  			require Mouse::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $mouse = Mouse::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($mouse);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $mouse->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		else
  		{
  			_croak("'$lib' is not a type constraint library");
  		}
  	}
  }

  sub declare
  {
  	my %opts;
  	if (@_ % 2 == 0)
  	{
  		%opts = @_;
  		if (@_==2 and $_[0]=~ /^_*[A-Z]/ and $_[1] =~ /^[0-9]+$/)
  		{
  			require Carp;
  			Carp::carp("Possible missing comma after 'declare $_[0]'");
  		}
  	}
  	else
  	{
  		(my($name), %opts) = @_;
  		_croak "Cannot provide two names for type" if exists $opts{name};
  		$opts{name} = $name;
  	}

  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;

  	if (defined $opts{parent})
  	{
  		$opts{parent} = to_TypeTiny($opts{parent});

  		unless (TypeTiny->check($opts{parent}))
  		{
  			$caller->isa("Type::Library")
  				or _croak("Parent type cannot be a %s", ref($opts{parent})||'non-reference scalar');
  			$opts{parent} = $caller->meta->get_type($opts{parent})
  				or _croak("Could not find parent type");
  		}
  	}

  	my $type;
  	if (defined $opts{parent})
  	{
  		$type = delete($opts{parent})->create_child_type(%opts);
  	}
  	else
  	{
  		my $bless = delete($opts{bless}) || "Type::Tiny";
  		eval "require $bless";
  		$type = $bless->new(%opts);
  	}

  	if ($caller->isa("Type::Library"))
  	{
  		$caller->meta->add_type($type) unless $type->is_anon;
  	}

  	return $type;
  }

  *subtype = \&declare;
  *type = \&declare;

  sub as (@)
  {
  	parent => @_;
  }

  sub where (&;@)
  {
  	constraint => @_;
  }

  sub message (&;@)
  {
  	message => @_;
  }

  sub inline_as (&;@)
  {
  	inlined => @_;
  }

  sub class_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ shift or {} };

  	if (defined $name)
  	{
  		$opts{name}  = $name unless exists $opts{name};
  		$opts{class} = $name unless exists $opts{class};

  		$opts{name} =~ s/:://g;
  	}

  	$opts{bless} = "Type::Tiny::Class";

  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }

  sub role_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ shift or {} };

  	if (defined $name)
  	{
  		$opts{name} = $name unless exists $opts{name};
  		$opts{role} = $name unless exists $opts{role};

  		$opts{name} =~ s/:://g;
  	}

  	$opts{bless} = "Type::Tiny::Role";

  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }

  sub duck_type
  {
  	my $name    = ref($_[0]) ? undef : shift;
  	my @methods = @{ shift or [] };

  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{methods} = \@methods;

  	$opts{bless} = "Type::Tiny::Duck";

  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }

  sub enum
  {
  	my $name   = ref($_[0]) ? undef : shift;
  	my @values = @{ shift or [] };

  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{values} = \@values;

  	$opts{bless} = "Type::Tiny::Enum";

  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }

  sub union
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ shift or [] };

  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;

  	$opts{bless} = "Type::Tiny::Union";

  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }

  sub intersection
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ shift or [] };

  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;

  	$opts{bless} = "Type::Tiny::Intersection";

  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }

  sub declare_coercion
  {
  	my %opts;
  	$opts{name} = shift if !ref($_[0]);

  	while (HashLike->check($_[0]) and not TypeTiny->check($_[0]))
  	{
  		%opts = (%opts, %{+shift});
  	}

  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;

  	my $bless = delete($opts{bless}) || "Type::Coercion";
  	eval "require $bless";
  	my $c = $bless->new(%opts);

  	my @C;

  	if ($caller->isa("Type::Library"))
  	{
  		my $meta = $caller->meta;
  		$meta->add_coercion($c) unless $c->is_anon;
  		while (@_)
  		{
  			push @C, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @C, shift;
  		}
  	}
  	else
  	{
  		@C = @_;
  	}

  	$c->add_type_coercions(@C);

  	return $c->freeze;
  }

  sub coerce
  {
  	if ((scalar caller)->isa("Type::Library"))
  	{
  		my $meta = (scalar caller)->meta;
  		my ($type) = map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  		my @opts;
  		while (@_)
  		{
  			push @opts, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @opts, shift;
  		}
  		return $type->coercion->add_type_coercions(@opts);
  	}

  	my ($type, @opts) = @_;
  	$type = to_TypeTiny($type);
  	return $type->coercion->add_type_coercions(@opts);
  }

  sub from (@)
  {
  	return @_;
  }

  sub to_type (@)
  {
  	my $type = shift;
  	unless (TypeTiny->check($type))
  	{
  		caller->isa("Type::Library")
  			or _croak "Target type cannot be a string";
  		$type = caller->meta->get_type($type)
  			or _croak "Could not find target type";
  	}
  	return +{ type_constraint => $type }, @_;
  }

  sub via (&;@)
  {
  	return @_;
  }

  sub match_on_type
  {
  	my $value = shift;

  	while (@_)
  	{
  		my $code;
  		if (@_ == 1)
  		{
  			$code = shift;
  		}
  		else
  		{
  			(my($type), $code) = splice(@_, 0, 2);
  			TypeTiny->($type)->check($value) or next;
  		}

  		if (StringLike->check($code))
  		{
  			local $_ = $value;
  			if (wantarray) {
  				my @r = eval "$code";
  				die $@ if $@;
  				return @r;
  			}
  			if (defined wantarray) {
  				my $r = eval "$code";
  				die $@ if $@;
  				return $r;
  			}
  			eval "$code";
  			die $@ if $@;
  			return;
  		}
  		else
  		{
  			CodeLike->($code);
  			local $_ = $value;
  			return $code->($value);
  		}
  	}

  	_croak("No cases matched for %s", Type::Tiny::_dd($value));
  }

  sub compile_match_on_type
  {
  	my @code = 'sub { local $_ = $_[0]; ';
  	my @checks;
  	my @actions;

  	my $els = '';

  	while (@_)
  	{
  		my ($type, $code);
  		if (@_ == 1)
  		{
  			require Types::Standard;
  			($type, $code) = (Types::Standard::Any(), shift);
  		}
  		else
  		{
  			($type, $code) = splice(@_, 0, 2);
  			TypeTiny->($type);
  		}

  		if ($type->can_be_inlined)
  		{
  			push @code, sprintf('%sif (%s)', $els, $type->inline_check('$_'));
  		}
  		else
  		{
  			push @checks, $type;
  			push @code, sprintf('%sif ($checks[%d]->check($_))', $els, $#checks);
  		}

  		$els = 'els';

  		if (StringLike->check($code))
  		{
  			push @code, sprintf('  { %s }', $code);
  		}
  		else
  		{
  			CodeLike->($code);
  			push @actions, $code;
  			push @code, sprintf('  { $actions[%d]->(@_) }', $#actions);
  		}
  	}

  	push @code, 'else', '  { Type::Utils::_croak("No cases matched for %s", Type::Tiny::_dd($_[0])) }';

  	push @code, '}';  # /sub

  	require Eval::TypeTiny;
  	return Eval::TypeTiny::eval_closure(
  		source      => \@code,
  		environment => {
  			'@actions' => \@actions,
  			'@checks'  => \@checks,
  		},
  	);
  }

  sub classifier
  {
  	my $i;
  	compile_match_on_type(
  		+(
  			map {
  				my $type = $_->[0];
  				$type => sub { $type };
  			}
  			sort { $b->[1] <=> $a->[1] or $a->[2] <=> $b->[2] }
  			map [$_, scalar(my @parents = $_->parents), ++$i],
  			@_
  		),
  		q[ undef ],
  	);
  }

  {
  	package #hide
  	Type::Registry::DWIM;

  	our @ISA = qw(Type::Registry);

  	sub foreign_lookup
  	{
  		my $self = shift;
  		my $r = $self->SUPER::foreign_lookup(@_);
  		return $r if $r;

  		if (defined($self->{"~~assume"})
  		and $_[0] =~ /[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/)
  		{
  			my $method = $self->{"~~assume"};
  			return $self->$method(@_);
  		}

  		return;
  	}

  	sub simple_lookup
  	{
  		my $self = shift;
  		my $r;

  		# If the lookup is chained to a class, then the class' own
  		# type registry gets first refusal.
  		#
  		if (defined $self->{"~~chained"})
  		{
  			my $chained = "Type::Registry"->for_class($self->{"~~chained"});
  			$r = eval { $chained->simple_lookup(@_) } unless $self == $chained;
  			return $r if defined $r;
  		}

  		# Fall back to types in Types::Standard.
  		require Types::Standard;
  		return 'Types::Standard'->get_type($_[0]) if 'Types::Standard'->has_type($_[0]);

  		# Only continue any further if we've been called from Type::Parser.
  		return unless $_[1];

  		my $moose_lookup = sub
  		{
  			if ($INC{'Moose.pm'})
  			{
  				require Moose::Util::TypeConstraints;
  				require Types::TypeTiny;
  				$r = Moose::Util::TypeConstraints::find_type_constraint($_[0]);
  				$r = Types::TypeTiny::to_TypeTiny($r) if defined $r;
  			}
  			defined $r;
  		};

  		my $mouse_lookup = sub
  		{
  			if ($INC{'Mouse.pm'})
  			{
  				require Mouse::Util::TypeConstraints;
  				require Types::TypeTiny;
  				$r = Mouse::Util::TypeConstraints::find_type_constraint($_[0]);
  				$r = Types::TypeTiny::to_TypeTiny($r) if defined $r;
  			}
  			defined $r;
  		};

  		my $meta;
  		if (defined $self->{"~~chained"})
  		{
  			$meta ||= Moose::Util::find_meta($self->{"~~chained"}) if $INC{'Moose.pm'};
  			$meta ||= Mouse::Util::find_meta($self->{"~~chained"}) if $INC{'Mouse.pm'};
  		}

  		if ($meta and $meta->isa('Class::MOP::Module'))
  		{
  			$moose_lookup->(@_) and return $r;
  		}
  		elsif ($meta and $meta->isa('Mouse::Meta::Module'))
  		{
  			$mouse_lookup->(@_) and return $r;
  		}
  		else
  		{
  			$moose_lookup->(@_) and return $r;
  			$mouse_lookup->(@_) and return $r;
  		}

  		return $self->foreign_lookup(@_);
  	}
  }

  our $dwimmer;
  sub dwim_type
  {
  	my ($string, %opts) = @_;
  	$opts{for} = caller unless defined $opts{for};

  	$dwimmer ||= do {
  		require Type::Registry;
  		'Type::Registry::DWIM'->new;
  	};

  	local $dwimmer->{'~~chained'} = $opts{for};
  	local $dwimmer->{'~~assume'}  = $opts{does} ? 'make_role_type' : 'make_class_type';

  	$dwimmer->lookup($string);
  }

  sub english_list
  {
  	my $conjunction = ref($_[0]) eq 'SCALAR' ? ${+shift} : 'and';
  	my @items = sort @_;

  	return $items[0] if @items == 1;
  	return "$items[0] $conjunction $items[1]" if @items == 2;

  	my $tail = pop @items;
  	join(', ', @items, "$conjunction $tail");
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords smush smushed

  =head1 NAME

  Type::Utils - utility functions to make defining and using type constraints a little easier

  =head1 SYNOPSIS

     package Types::Mine;

     use Type::Library -base;
     use Type::Utils -all;

     BEGIN { extends "Types::Standard" };

     declare "AllCaps",
        as "Str",
        where { uc($_) eq $_ },
        inline_as { my $varname = $_[1]; "uc($varname) eq $varname" };

     coerce "AllCaps",
        from "Str", via { uc($_) };

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This module provides utility functions to make defining and using type
  constraints a little easier.

  =head2 Type declaration functions

  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.

  =over

  =item C<< declare $name, %options >>

  =item C<< declare %options >>

  Declare a named or anonymous type constraint. Use C<as> and C<where> to
  specify the parent type (if any) and (possibly) refine its definition.

     declare EvenInt, as Int, where { $_ % 2 == 0 };

     my $EvenInt = declare as Int, where { $_ % 2 == 0 };

  B<< NOTE: >>
  If the caller package inherits from L<Type::Library> then any non-anonymous
  types declared in the package will be automatically installed into the
  library.

  Hidden gem: if you're inheriting from a type constraint that includes some
  coercions, you can include C<< coercion => 1 >> in the C<< %options >> hash
  to inherit the coercions.

  =item C<< subtype $name, %options >>

  =item C<< subtype %options >>

  Declare a named or anonymous type constraint which is descended from an
  existing type constraint. Use C<as> and C<where> to specify the parent
  type and refine its definition.

  Actually, you should use C<declare> instead; this is just an alias.

  This function is not exported by default.

  =item C<< type $name, %options >>

  =item C<< type %options >>

  Declare a named or anonymous type constraint which is not descended from
  an existing type constraint. Use C<where> to provide a coderef that
  constrains values.

  Actually, you should use C<declare> instead; this is just an alias.

  This function is not exported by default.

  =item C<< as $parent >>

  Used with C<declare> to specify a parent type constraint:

     declare EvenInt, as Int, where { $_ % 2 == 0 };

  =item C<< where { BLOCK } >>

  Used with C<declare> to provide the constraint coderef:

     declare EvenInt, as Int, where { $_ % 2 == 0 };

  The coderef operates on C<< $_ >>, which is the value being tested.

  =item C<< message { BLOCK } >>

  Generate a custom error message when a value fails validation.

     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        message {
           Int->validate($_) or "$_ is not divisible by two";
        };

  Without a custom message, the messages generated by Type::Tiny are along
  the lines of I<< Value "33" did not pass type constraint "EvenInt" >>,
  which is usually reasonable.

  =item C<< inline_as { BLOCK } >>

  Generate a string of Perl code that can be used to inline the type check into
  other functions. If your type check is being used within a L<Moose> or L<Moo>
  constructor or accessor methods, or used by L<Type::Params>, this can lead to
  significant performance improvements.

     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           my ($constraint, $varname) = @_;
           my $perlcode =
              $constraint->parent->inline_check($varname)
              . "&& ($varname % 2 == 0)";
           return $perlcode;
        };

     warn EvenInt->inline_check('$xxx');  # demonstration

  B<Experimental:> your C<inline_as> block can return a list, in which case
  these will be smushed together with "&&". The first item on the list may
  be undef, in which case the undef will be replaced by the inlined parent
  type constraint. (And will throw an exception if there is no parent.)

     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           return (undef, "($_ % 2 == 0)");
        };

  Returning a list like this is considered experimental, is not tested very
  much, and I offer no guarantees that it will necessarily work with
  Moose/Mouse/Moo.

  =item C<< class_type $name, { class => $package, %options } >>

  =item C<< class_type { class => $package, %options } >>

  =item C<< class_type $name >>

  Shortcut for declaring a L<Type::Tiny::Class> type constraint.

  If C<< $package >> is omitted, is assumed to be the same as C<< $name >>.
  If C<< $name >> contains "::" (which would be an invalid name as far as
  L<Type::Tiny> is concerned), this will be removed.

  So for example, C<< class_type("Foo::Bar") >> declares a L<Type::Tiny::Class>
  type constraint named "FooBar" which constrains values to objects blessed
  into the "Foo::Bar" package.

  =item C<< role_type $name, { role => $package, %options } >>

  =item C<< role_type { role => $package, %options } >>

  =item C<< role_type $name >>

  Shortcut for declaring a L<Type::Tiny::Role> type constraint.

  If C<< $package >> is omitted, is assumed to be the same as C<< $name >>.
  If C<< $name >> contains "::" (which would be an invalid name as far as
  L<Type::Tiny> is concerned), this will be removed.

  =item C<< duck_type $name, \@methods >>

  =item C<< duck_type \@methods >>

  Shortcut for declaring a L<Type::Tiny::Duck> type constraint.

  =item C<< union $name, \@constraints >>

  =item C<< union \@constraints >>

  Shortcut for declaring a L<Type::Tiny::Union> type constraint.

  =item C<< enum $name, \@values >>

  =item C<< enum \@values >>

  Shortcut for declaring a L<Type::Tiny::Enum> type constraint.

  =item C<< intersection $name, \@constraints >>

  =item C<< intersection \@constraints >>

  Shortcut for declaring a L<Type::Tiny::Intersection> type constraint.

  =back

  =head2 Coercion declaration functions

  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.

  =over

  =item C<< coerce $target, @coercions >>

  Add coercions to the target type constraint. The list of coercions is a
  list of type constraint, conversion code pairs. Conversion code can be
  either a string of Perl code or a coderef; in either case the value to
  be converted is C<< $_ >>.

  =item C<< from $source >>

  Sugar to specify a type constraint in a list of coercions:

     coerce EvenInt, from Int, via { $_ * 2 };  # As a coderef...
     coerce EvenInt, from Int, q { $_ * 2 };    # or as a string!

  =item C<< via { BLOCK } >>

  Sugar to specify a coderef in a list of coercions.

  =item C<< declare_coercion $name, \%opts, $type1, $code1, ... >>

  =item C<< declare_coercion \%opts, $type1, $code1, ... >>

  Declares a coercion that is not explicitly attached to any type in the
  library. For example:

     declare_coercion "ArrayRefFromAny", from "Any", via { [$_] };

  This coercion will be exportable from the library as a L<Type::Coercion>
  object, but the ArrayRef type exported by the library won't automatically
  use it.

  Coercions declared this way are immutable (frozen).

  =item C<< to_type $type >>

  Used with C<declare_coercion> to declare the target type constraint for
  a coercion, but still without explicitly attaching the coercion to the
  type constraint:

     declare_coercion "ArrayRefFromAny",
        to_type "ArrayRef",
        from "Any", via { [$_] };

  You should pretty much always use this when declaring an unattached
  coercion because it's exceedingly useful for a type coercion to know what
  it will coerce to - this allows it to skip coercion when no coercion is
  needed (e.g. avoiding coercing C<< [] >> to C<< [ [] ] >>) and allows
  C<assert_coerce> to work properly.

  =back

  =head2 Type library management

  =over

  =item C<< extends @libraries >>

  Indicates that this type library extends other type libraries, importing
  their type constraints.

  Should usually be executed in a C<< BEGIN >> block.

  This is not exported by default because it's not fun to export it to Moo,
  Moose or Mouse classes! C<< use Type::Utils -all >> can be used to import
  it into your type library.

  =back

  =head2 Other

  =over

  =item C<< match_on_type $value => ($type => \&action, ..., \&default?) >>

  Something like a C<switch>/C<case> or C<given>/C<when> construct. Dispatches
  along different code paths depending on the type of the incoming value.
  Example blatantly stolen from the Moose documentation:

     sub to_json
     {
        my $value = shift;

        return match_on_type $value => (
           HashRef() => sub {
              my $hash = shift;
              '{ '
                 . (
                 join ", " =>
                 map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                 sort keys %$hash
              ) . ' }';
           },
           ArrayRef() => sub {
              my $array = shift;
              '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
           },
           Num()   => q {$_},
           Str()   => q { '"' . $_ . '"' },
           Undef() => q {'null'},
           => sub { die "$_ is not acceptable json type" },
        );
     }

  Note that unlike Moose, code can be specified as a string instead of a
  coderef. (e.g. for C<Num>, C<Str> and C<Undef> above.)

  For improved performance, try C<compile_match_on_type>.

  This function is not exported by default.

  =item C<< my $coderef = compile_match_on_type($type => \&action, ..., \&default?) >>

  Compile a C<match_on_type> block into a coderef. The following JSON
  converter is about two orders of magnitude faster than the previous
  example:

     sub to_json;
     *to_json = compile_match_on_type(
        HashRef() => sub {
           my $hash = shift;
           '{ '
              . (
              join ", " =>
              map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
              sort keys %$hash
           ) . ' }';
        },
        ArrayRef() => sub {
           my $array = shift;
           '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
        },
        Num()   => q {$_},
        Str()   => q { '"' . $_ . '"' },
        Undef() => q {'null'},
        => sub { die "$_ is not acceptable json type" },
     );

  Remember to store the coderef somewhere fairly permanent so that you
  don't compile it over and over. C<state> variables (in Perl >= 5.10)
  are good for this. (Same sort of idea as L<Type::Params>.)

  This function is not exported by default.

  =item C<< my $coderef = classifier(@types) >>

  Returns a coderef that can be used to classify values according to their
  type constraint. The coderef, when passed a value, returns a type
  constraint which the value satisfies.

     use feature qw( say );
     use Type::Utils qw( classifier );
     use Types::Standard qw( Int Num Str Any );

     my $classifier = classifier(Str, Int, Num, Any);

     say $classifier->( "42"  )->name;   # Int
     say $classifier->( "4.2" )->name;   # Num
     say $classifier->( []    )->name;   # Any

  Note that, for example, "42" satisfies Int, but it would satisfy the
  type constraints Num, Str, and Any as well. In this case, the
  classifier has picked the most specific type constraint that "42"
  satisfies.

  If no type constraint is satisfied by the value, then the classifier
  will return undef.

  =item C<< dwim_type($string, %options) >>

  Given a string like "ArrayRef[Int|CodeRef]", turns it into a type constraint
  object, hopefully doing what you mean.

  It uses the syntax of L<Type::Parser>. Firstly the L<Type::Registry>
  for the caller package is consulted; if that doesn't have a match,
  L<Types::Standard> is consulted for type constraint names; and if
  there's still no match, then if a type constraint looks like a class
  name, a new L<Type::Tiny::Class> object is created for it.

  Somewhere along the way, it also checks Moose/Mouse's type constraint
  registries if they are loaded.

  You can specify an alternative for the caller using the C<for> option.
  If you'd rather create a L<Type::Tiny::Role> object, set the C<does>
  option to true.

     # An arrayref of objects, each of which must do role Foo.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);

     Type::Registry->for_me->add_types("-Standard");
     Type::Registry->for_me->alias_type("Int" => "Foo");

     # An arrayref of integers.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);

  While it's probably better overall to use the proper L<Type::Registry>
  interface for resolving type constraint strings, this function often does
  what you want.

  It should never die if it fails to find a type constraint (but may die
  if the type constraint string is syntactically malformed), preferring to
  return undef.

  This function is not exported by default.

  =item C<< english_list(\$conjunction, @items) >>

  Joins the items with commas, placing a conjunction before the final item.
  The conjunction is optional, defaulting to "and".

     english_list(qw/foo bar baz/);       # "foo, bar, and baz"
     english_list(\"or", qw/quux quuux/); # "quux or quuux"

  This function is not exported by default.

  =back

  =head1 EXPORT

  By default, all of the functions documented above are exported, except
  C<subtype> and C<type> (prefer C<declare> instead), C<extends>, C<dwim_type>,
  C<match_on_type>/C<compile_match_on_type>, C<classifier>, and
  C<english_list>.

  This module uses L<Exporter::Tiny>; see the documentation of that module
  for tips and tricks importing from Type::Utils.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>, L<Type::Library>, L<Types::Standard>, L<Type::Coercion>.

  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>.

  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPE_UTILS

$fatpacked{"Types/Common/Numeric.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_NUMERIC';
  package Types::Common::Numeric;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }

  BEGIN {
  	$Types::Common::Numeric::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::Numeric::VERSION   = '1.000005';
  }

  use Type::Library -base, -declare => qw(
  	PositiveNum PositiveOrZeroNum
  	PositiveInt PositiveOrZeroInt
  	NegativeNum NegativeOrZeroNum
  	NegativeInt NegativeOrZeroInt
  	SingleDigit
  );

  use Type::Tiny ();
  use Types::Standard qw( Num Int );

  my $meta = __PACKAGE__->meta;

  $meta->add_type(
  	name       => 'PositiveNum',
  	parent     => Num,
  	constraint => sub { $_ > 0 },
  	inlined    => sub { undef, qq($_ > 0) },
  	message    => sub { "Must be a positive number" },
  );

  $meta->add_type(
  	name       => 'PositiveOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ >= 0) },
  	message    => sub { "Must be a number greater than or equal to zero" },
  );

  my ($pos_int, $posz_int);
  if (Type::Tiny::_USE_XS) {
  	$pos_int  = Type::Tiny::XS::get_coderef_for('PositiveInt');
  	$posz_int = Type::Tiny::XS::get_coderef_for('PositiveOrZeroInt');
  }

  $meta->add_type(
  	name       => 'PositiveInt',
  	parent     => Int,
  	constraint => sub { $_ > 0 },
  	inlined    => sub {
  		if ($pos_int) {
  			my $xsub = Type::Tiny::XS::get_subname_for($_[0]->name);
  			return "$xsub($_[1])" if $xsub;
  		}
  		undef, qq($_ > 0);
  	},
  	message    => sub { "Must be a positive integer" },
  	$pos_int ? ( compiled_type_constraint => $pos_int ) : (),
  );

  $meta->add_type(
  	name       => 'PositiveOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub {
  		if ($posz_int) {
  			my $xsub = Type::Tiny::XS::get_subname_for($_[0]->name);
  			return "$xsub($_[1])" if $xsub;
  		}
  		undef, qq($_ >= 0);
  	},
  	message    => sub { "Must be an integer greater than or equal to zero" },
  	$posz_int ? ( compiled_type_constraint => $posz_int ) : (),
  );

  $meta->add_type(
  	name       => 'NegativeNum',
  	parent     => Num,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative number" },
  );

  $meta->add_type(
  	name       => 'NegativeOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ <= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be a number less than or equal to zero" },
  );

  $meta->add_type(
  	name       => 'NegativeInt',
  	parent     => Int,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative integer" },
  );

  $meta->add_type(
  	name       => 'NegativeOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ <= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be an integer less than or equal to zero" },
  );

  $meta->add_type(
  	name       => 'SingleDigit',
  	parent     => Int,
  	constraint => sub { $_ >= -9 and $_ <= 9 },
  	inlined    => sub { undef, qq($_ >= -9), qq($_ <= 9) },
  	message    => sub { "Must be a single digit" },
  );

  __PACKAGE__->meta->make_immutable;

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Types::Common::Numeric - drop-in replacement for MooseX::Types::Common::Numeric

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  A drop-in replacement for L<MooseX::Types::Common::Numeric>.

  =head2 Types

  The following types are similar to those described in
  L<MooseX::Types::Common::Numeric>.

  =over

  =item C<PositiveNum>

  =item C<PositiveOrZeroNum>

  =item C<PositiveInt>

  =item C<PositiveOrZeroInt>

  =item C<NegativeNum>

  =item C<NegativeOrZeroNum>

  =item C<NegativeInt>

  =item C<NegativeOrZeroInt>

  =item C<SingleDigit>

  =back

  C<SingleDigit> interestingly accepts the numbers -9 to -1; not
  just 0 to 9.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Types::Standard>, L<Types::Common::String>.

  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_COMMON_NUMERIC

$fatpacked{"Types/Common/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_STRING';
  package Types::Common::String;

  use 5.006001;
  use strict;
  use warnings;
  use utf8;

  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }

  BEGIN {
  	$Types::Common::String::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::String::VERSION   = '1.000005';
  }

  use Type::Library -base, -declare => qw(
  	SimpleStr
  	NonEmptySimpleStr
  	NumericCode
  	LowerCaseSimpleStr
  	UpperCaseSimpleStr
  	Password
  	StrongPassword
  	NonEmptyStr
  	LowerCaseStr
  	UpperCaseStr
  );

  use Type::Tiny ();
  use Types::Standard qw( Str );

  my $meta = __PACKAGE__->meta;

  $meta->add_type(
  	name       => SimpleStr,
  	parent     => Str,
  	constraint => sub { length($_) <= 255 and not /\n/ },
  	inlined    => sub { undef, qq(length($_) <= 255), qq($_ !~ /\\n/) },
  	message    => sub { "Must be a single line of no more than 255 chars" },
  );

  $meta->add_type(
  	name       => NonEmptySimpleStr,
  	parent     => SimpleStr,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub { undef, qq(length($_) > 0) },
  	message    => sub { "Must be a non-empty single line of no more than 255 chars" },
  );

  $meta->add_type(
  	name       => NumericCode,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { /^[0-9]+$/ },
  	inlined    => sub { SimpleStr->inline_check($_), qq($_ =~ m/^[0-9]+\$/) },
  	message    => sub {
  		'Must be a non-empty single line of no more than 255 chars that consists '
  			. 'of numeric characters only'
  	},
  );

  NumericCode->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ do { (my $code = $_) =~ s/[[:punct:]]//g; $code } ],
  );

  $meta->add_type(
  	name       => Password,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { length($_) > 3 },
  	inlined    => sub { SimpleStr->inline_check($_), qq(length($_) > 3) },
  	message    => sub { "Must be between 4 and 255 chars" },
  );

  $meta->add_type(
  	name       => StrongPassword,
  	parent     => Password,
  	constraint => sub { length($_) > 7 and /[^a-zA-Z]/ },
  	inlined    => sub { SimpleStr()->inline_check($_), qq(length($_) > 7), qq($_ =~ /[^a-zA-Z]/) },
  	message    => sub { "Must be between 8 and 255 chars, and contain a non-alpha char" },
  );

  my ($nestr);
  if (Type::Tiny::_USE_XS) {
  	$nestr = Type::Tiny::XS::get_coderef_for('NonEmptyStr');
  }

  $meta->add_type(
  	name       => NonEmptyStr,
  	parent     => Str,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub {
  		if ($nestr) {
  			my $xsub = Type::Tiny::XS::get_subname_for($_[0]->name);
  			return "$xsub($_[1])" if $xsub;
  		}
  		undef, qq(length($_) > 0);
  	},
  	message    => sub { "Must not be empty" },
  	$nestr ? ( compiled_type_constraint => $nestr ) : (),
  );

  $meta->add_type(
  	name       => LowerCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain upper case letters" },
  );

  LowerCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ lc($_) ],
  );

  $meta->add_type(
  	name       => UpperCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );

  UpperCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ uc($_) ],
  );

  $meta->add_type(
  	name       => LowerCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain pper case letters" },
  );

  LowerCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ lc($_) ],
  );

  $meta->add_type(
  	name       => UpperCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );

  UpperCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ uc($_) ],
  );

  __PACKAGE__->meta->make_immutable;

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Types::Common::String - drop-in replacement for MooseX::Types::Common::String

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  A drop-in replacement for L<MooseX::Types::Common::String>.

  =head2 Types

  The following types are similar to those described in
  L<MooseX::Types::Common::String>.

  =over

  =item C<SimpleStr>

  =item C<NonEmptySimpleStr>

  =item C<NumericCode>

  =item C<LowerCaseSimpleStr>

  =item C<UpperCaseSimpleStr>

  =item C<Password>

  =item C<StrongPassword>

  =item C<NonEmptyStr>

  =item C<LowerCaseStr>

  =item C<UpperCaseStr>

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Types::Standard>, L<Types::Common::Numeric>.

  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_COMMON_STRING

$fatpacked{"Types/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD';
  package Types::Standard;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	eval { require re };
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  	if ($] < 5.010) { require Devel::TypeTiny::Perl58Compat };
  }

  BEGIN {
  	$Types::Standard::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::VERSION   = '1.000005';
  }

  use Type::Library -base;

  our @EXPORT_OK = qw( slurpy );

  use Scalar::Util qw( blessed looks_like_number );
  use Type::Tiny ();
  use Types::TypeTiny ();

  BEGIN {
  	*_is_class_loaded = Type::Tiny::_USE_XS
  		? \&Type::Tiny::XS::Util::is_class_loaded
  		: sub {
  			return !!0 if ref $_[0];
  			return !!0 if not $_[0];
  			my $stash = do { no strict 'refs'; \%{"$_[0]\::"} };
  			return !!1 if exists $stash->{'ISA'};
  			return !!1 if exists $stash->{'VERSION'};
  			foreach my $globref (values %$stash) {
  				return !!1 if *{$globref}{CODE};
  			}
  			return !!0;
  		};
  };

  my $add_core_type = sub {
  	my $meta = shift;
  	my ($typedef) = @_;

  	my $name = $typedef->{name};
  	my ($xsub, $xsubname);

  	# We want Map and Tuple to be XSified, even if they're not
  	# really core.
  	$typedef->{_is_core} = 1
  		unless $name eq 'Map' || $name eq 'Tuple';

  	if ( Type::Tiny::_USE_XS
  	and not ($name eq 'RegexpRef') ) {
  		$xsub     = Type::Tiny::XS::get_coderef_for($name);
  		$xsubname = Type::Tiny::XS::get_subname_for($name);
  	}

  	elsif ( Type::Tiny::_USE_MOUSE
  	and not ($name eq 'RegexpRef' or $name eq 'Int' or $name eq 'Object') ) {
  		require Mouse::Util::TypeConstraints;
  		$xsub     = "Mouse::Util::TypeConstraints"->can($name);
  		$xsubname = "Mouse::Util::TypeConstraints::$name" if $xsub;
  	}

  	$typedef->{compiled_type_constraint} = $xsub if $xsub;

  	$typedef->{inlined} = sub { "$xsubname\($_[1])" }
  		if defined($xsubname) and (
  			# These should be faster than their normal inlined
  			# equivalents
  			$name eq 'Str' or
  			$name eq 'Bool' or
  			$name eq 'ClassName' or
  			$name eq 'RegexpRef' or
  			$name eq 'FileHandle'
  		);

  	$meta->add_type($typedef);
  };

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  my $meta = __PACKAGE__->meta;

  # Stringable and LazyLoad are optimizations that complicate
  # this module somewhat, but they have led to performance
  # improvements. If Types::Standard wasn't such a key type
  # library, I wouldn't use them. I strongly discourage anybody
  # from using them in their own code. If you're looking for
  # examples of how to write a type library sanely, you're
  # better off looking at the code for Types::Common::Numeric
  # and Types::Common::String.

  sub Stringable (&)
  {
  	package #private
  	Types::Standard::_Stringable;
  	use overload q[""] => sub { $_[0]{text} ||= $_[0]{code}->() }, fallback => 1;
  	bless +{ code => $_[0] };
  }

  sub LazyLoad ($$)
  {
  	package #private
  	Types::Standard::LazyLoad;
  	use overload fallback => 1, q[&{}] => sub {
  		my ($typename, $function) = @{$_[0]};
  		my $type  = $meta->get_type($typename);
  		my $class = "Types::Standard::$typename";
  		eval "require $class; 1" or die($@);
  		# Majorly break encapsulation for Type::Tiny :-O
  		for my $key (keys %$type)
  		{
  			next unless ref($type->{$key}) eq __PACKAGE__;
  			my $f = $type->{$key}[1];
  			$type->{$key} = $class->can("__$f");
  		}
  		return $class->can("__$function");
  	};
  	bless \@_;
  }

  no warnings;

  BEGIN { *STRICTNUM = $ENV{PERL_TYPES_STANDARD_STRICTNUM} ? sub(){!!1} : sub(){!!0} };

  my $_any = $meta->$add_core_type({
  	name       => "Any",
  	inlined    => sub { "!!1" },
  });

  my $_item = $meta->$add_core_type({
  	name       => "Item",
  	inlined    => sub { "!!1" },
  	parent     => $_any,
  });

  $meta->$add_core_type({
  	name       => "Bool",
  	parent     => $_item,
  	constraint => sub { !defined $_ or $_ eq q() or $_ eq '0' or $_ eq '1' },
  	inlined    => sub { "!defined $_[1] or $_[1] eq q() or $_[1] eq '0' or $_[1] eq '1'" },
  });

  my $_undef = $meta->$add_core_type({
  	name       => "Undef",
  	parent     => $_item,
  	constraint => sub { !defined $_ },
  	inlined    => sub { "!defined($_[1])" },
  });

  my $_def = $meta->$add_core_type({
  	name       => "Defined",
  	parent     => $_item,
  	constraint => sub { defined $_ },
  	inlined    => sub { "defined($_[1])" },
  });

  my $_val = $meta->$add_core_type({
  	name       => "Value",
  	parent     => $_def,
  	constraint => sub { not ref $_ },
  	inlined    => sub { "defined($_[1]) and not ref($_[1])" },
  });

  my $_str = $meta->$add_core_type({
  	name       => "Str",
  	parent     => $_val,
  	constraint => sub { ref(\$_) eq 'SCALAR' or ref(\(my $val = $_)) eq 'SCALAR' },
  	inlined    => sub {
  		"defined($_[1]) and do { ref(\\$_[1]) eq 'SCALAR' or ref(\\(my \$val = $_[1])) eq 'SCALAR' }"
  	},
  });

  my $_laxnum = $meta->add_type({
  	name       => "LaxNum",
  	parent     => $_str,
  	constraint => sub { looks_like_number $_ },
  	inlined    => sub { "defined($_[1]) && !ref($_[1]) && Scalar::Util::looks_like_number($_[1])" },
  });

  my $_strictnum = $meta->add_type({
  	name       => "StrictNum",
  	parent     => $_str,
  	constraint => sub {
  		my $val = $_;
  		($val =~ /\A[+-]?[0-9]+\z/) ||
  		( $val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
  		(?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
  		[0-9]*                                #matches 0-9 zero or more times
  		(?:\.[0-9]+)?                         #matches optional .89 or nothing
  		(?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
  		\z/x );
  	},
  	inlined    => sub {
  		'my $val = '.$_[1].';'.
  		Value()->inline_check('$val')
  		.' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
  		. '$val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
  			(?=[0-9]|\.[0-9])                 # matches previous +- only if there is something like 3 or .3
  			[0-9]*                            # matches 0-9 zero or more times
  			(?:\.[0-9]+)?                     # matches optional .89 or nothing
  			(?:[Ee](?:[+-]?[0-9]+))?          # matches E1 or e1 or e-1 or e+1 etc
  		\z/x ); '
  	},
  });

  my $_num = $meta->add_type({
  	name       => "Num",
  	parent     => (STRICTNUM ? $_strictnum : $_laxnum),
  });

  $meta->$add_core_type({
  	name       => "Int",
  	parent     => $_num,
  	constraint => sub { /\A-?[0-9]+\z/ },
  	inlined    => sub { "defined $_[1] and $_[1] =~ /\\A-?[0-9]+\\z/" },
  });

  my $_classn = $meta->add_type({
  	name       => "ClassName",
  	parent     => $_str,
  	constraint => \&_is_class_loaded,
  	inlined    => sub { "Types::Standard::_is_class_loaded(do { my \$tmp = $_[1] })" },
  });

  $meta->add_type({
  	name       => "RoleName",
  	parent     => $_classn,
  	constraint => sub { not $_->can("new") },
  	inlined    => sub { "Types::Standard::_is_class_loaded(do { my \$tmp = $_[1] }) and not $_[1]\->can('new')" },
  });

  my $_ref = $meta->$add_core_type({
  	name       => "Ref",
  	parent     => $_def,
  	constraint => sub { ref $_ },
  	inlined    => sub { "!!ref($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Ref') unless @_;

  		my $reftype = shift;
  		Types::TypeTiny::StringLike->check($reftype)
  			or _croak("Parameter to Ref[`a] expected to be string; got $reftype");

  		$reftype = "$reftype";
  		return sub {
  			ref($_[0]) and Scalar::Util::reftype($_[0]) eq $reftype;
  		}
  	},
  	inline_generator => sub
  	{
  		my $reftype = shift;
  		return sub {
  			my $v = $_[1];
  			"ref($v) and Scalar::Util::reftype($v) eq q($reftype)";
  		};
  	},
  	deep_explanation => sub {
  		require B;
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		return if $type->check($value);
  		my $reftype = Scalar::Util::reftype($value);
  		return [
  			sprintf('"%s" constrains reftype(%s) to be equal to %s', $type, $varname, B::perlstring($param)),
  			sprintf('reftype(%s) is %s', $varname, defined($reftype) ? B::perlstring($reftype) : "undef"),
  		];
  	},
  });

  $meta->$add_core_type({
  	name       => "CodeRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "CODE" },
  	inlined    => sub { "ref($_[1]) eq 'CODE'" },
  });

  $meta->$add_core_type({
  	name       => "RegexpRef",
  	parent     => $_ref,
  	constraint => sub { ref($_) && !!re::is_regexp($_) },
  	inlined    => sub { "ref($_[1]) && !!re::is_regexp($_[1])" },
  });

  $meta->$add_core_type({
  	name       => "GlobRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "GLOB" },
  	inlined    => sub { "ref($_[1]) eq 'GLOB'" },
  });

  $meta->$add_core_type({
  	name       => "FileHandle",
  	parent     => $_ref,
  	constraint => sub {
  		(ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
  		or (blessed($_) && $_->isa("IO::Handle"))
  	},
  	inlined    => sub {
  		"(ref($_[1]) eq \"GLOB\" && Scalar::Util::openhandle($_[1])) ".
  		"or (Scalar::Util::blessed($_[1]) && $_[1]\->isa(\"IO::Handle\"))"
  	},
  });

  my $_arr = $meta->$add_core_type({
  	name       => "ArrayRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "ARRAY" },
  	inlined    => sub { "ref($_[1]) eq 'ARRAY'" },
  	constraint_generator => LazyLoad(ArrayRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ArrayRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ArrayRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ArrayRef => 'coercion_generator'),
  });

  my $_hash = $meta->$add_core_type({
  	name       => "HashRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "HASH" },
  	inlined    => sub { "ref($_[1]) eq 'HASH'" },
  	constraint_generator => LazyLoad(HashRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(HashRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(HashRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(HashRef => 'coercion_generator'),
  	my_methods => {
  		hashref_allows_key => sub {
  			my $self = shift;
  			Str()->check($_[0]);
  		},
  		hashref_allows_value => sub {
  			my $self = shift;
  			my ($key, $value) = @_;

  			return !!0 unless $self->my_hashref_allows_key($key);
  			return !!1 if $self==HashRef();

  			my $href  = $self->find_parent(sub { $_->has_parent && $_->parent==HashRef() });
  			my $param = $href->type_parameter;

  			Str()->check($key) and $param->check($value);
  		},
  	},
  });

  $meta->$add_core_type({
  	name       => "ScalarRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "SCALAR" or ref $_ eq "REF" },
  	inlined    => sub { "ref($_[1]) eq 'SCALAR' or ref($_[1]) eq 'REF'" },
  	constraint_generator => LazyLoad(ScalarRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ScalarRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ScalarRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ScalarRef => 'coercion_generator'),
  });

  my $_obj = $meta->$add_core_type({
  	name       => "Object",
  	parent     => $_ref,
  	constraint => sub { blessed $_ },
  	inlined    => sub { "Scalar::Util::blessed($_[1])" },
  });

  $meta->$add_core_type({
  	name       => "Maybe",
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Maybe') unless @_;

  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Maybe[`a] expected to be a type constraint; got $param");

  		my $param_compiled_check = $param->compiled_check;
  		my @xsub;
  		if (Type::Tiny::_USE_XS)
  		{
  			my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  			push @xsub, Type::Tiny::XS::get_coderef_for("Maybe[$paramname]")
  				if $paramname;
  		}
  		elsif (Type::Tiny::_USE_MOUSE and $param->_has_xsub)
  		{
  			require Mouse::Util::TypeConstraints;
  			my $maker = "Mouse::Util::TypeConstraints"->can("_parameterize_Maybe_for");
  			push @xsub, $maker->($param) if $maker;
  		}

  		return(
  			sub
  			{
  				my $value = shift;
  				return !!1 unless defined $value;
  				return $param->check($value);
  			},
  			@xsub,
  		);
  	},
  	inline_generator => sub {
  		my $param = shift;

  		my $param_compiled_check = $param->compiled_check;
  		if (Type::Tiny::_USE_XS)
  		{
  			my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  			my $xsubname  = Type::Tiny::XS::get_subname_for("Maybe[$paramname]");
  			return sub { "$xsubname\($_[1]\)" } if $xsubname;
  		}

  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			my $param_check = $param->inline_check($v);
  			"!defined($v) or $param_check";
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];

  		return [
  			sprintf('%s is defined', Type::Tiny::_dd($value)),
  			sprintf('"%s" constrains the value with "%s" if it is defined', $type, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });

  my $_map = $meta->$add_core_type({
  	name       => "Map",
  	parent     => $_hash,
  	constraint_generator => LazyLoad(Map => 'constraint_generator'),
  	inline_generator     => LazyLoad(Map => 'inline_generator'),
  	deep_explanation     => LazyLoad(Map => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Map => 'coercion_generator'),
  	my_methods => {
  		hashref_allows_key => sub {
  			my $self = shift;
  			my ($key) = @_;

  			return Str()->check($key) if $self==Map();

  			my $map = $self->find_parent(sub { $_->has_parent && $_->parent==Map() });
  			my ($kcheck, $vcheck) = @{ $map->parameters };

  			($kcheck or Any())->check($key);
  		},
  		hashref_allows_value => sub {
  			my $self = shift;
  			my ($key, $value) = @_;

  			return !!0 unless $self->my_hashref_allows_key($key);
  			return !!1 if $self==Map();

  			my $map = $self->find_parent(sub { $_->has_parent && $_->parent==Map() });
  			my ($kcheck, $vcheck) = @{ $map->parameters };

  			($kcheck or Any())->check($key)
  				and ($vcheck or Any())->check($value);
  		},
  	},
  });

  my $_Optional = $meta->add_type({
  	name       => "Optional",
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Optional') unless @_;

  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Optional[`a] expected to be a type constraint; got $param");

  		sub { $param->check($_[0]) }
  	},
  	inline_generator => sub {
  		my $param = shift;
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			$param->inline_check($v);
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];

  		return [
  			sprintf('%s exists', $varname),
  			sprintf('"%s" constrains %s with "%s" if it exists', $type, $varname, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });

  sub slurpy {
  	my $t = shift;
  	wantarray ? (+{ slurpy => $t }, @_) : +{ slurpy => $t };
  }

  $meta->$add_core_type({
  	name       => "Tuple",
  	parent     => $_arr,
  	name_generator => sub
  	{
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], map { ref($_) eq "HASH" ? sprintf("slurpy %s", $_->{slurpy}) : $_ } @a);
  	},
  	constraint_generator => LazyLoad(Tuple => 'constraint_generator'),
  	inline_generator     => LazyLoad(Tuple => 'inline_generator'),
  	deep_explanation     => LazyLoad(Tuple => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Tuple => 'coercion_generator'),
  });

  $meta->add_type({
  	name       => "Dict",
  	parent     => $_hash,
  	name_generator => sub
  	{
  		my ($s, @p) = @_;
  		my $l = ref($p[-1]) eq q(HASH) ? pop(@p)->{slurpy} : undef;
  		my %a = @p;
  		sprintf('%s[%s%s]', $s, join(q[,], map sprintf("%s=>%s", $_, $a{$_}), sort keys %a), $l ? ",slurpy $l" : '');
  	},
  	constraint_generator => LazyLoad(Dict => 'constraint_generator'),
  	inline_generator     => LazyLoad(Dict => 'inline_generator'),
  	deep_explanation     => LazyLoad(Dict => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Dict => 'coercion_generator'),
  	my_methods => {
  		dict_is_slurpy => sub
  		{
  			my $self = shift;

  			return !!0 if $self==Dict();

  			my $dict = $self->find_parent(sub { $_->has_parent && $_->parent==Dict() });
  			ref($dict->parameters->[-1]) eq q(HASH)
  				? $dict->parameters->[-1]{slurpy}
  				: !!0
  		},
  		hashref_allows_key => sub
  		{
  			my $self = shift;
  			my ($key) = @_;

  			return Str()->check($key) if $self==Dict();

  			my $dict = $self->find_parent(sub { $_->has_parent && $_->parent==Dict() });
  			my %params;
  			my $slurpy = $dict->my_dict_is_slurpy;
  			if ($slurpy)
  			{
  				my @args = @{$dict->parameters};
  				pop @args;
  				%params = @args;
  			}
  			else
  			{
  				%params = @{ $dict->parameters }
  			}

  			return !!1
  				if exists($params{$key});
  			return !!0
  				if !$slurpy;
  			return Str()->check($key)
  				if $slurpy==Any() || $slurpy==Item() || $slurpy==Defined() || $slurpy==Ref();
  			return $slurpy->my_hashref_allows_key($key)
  				if $slurpy->is_a_type_of(HashRef());
  			return !!0;
  		},
  		hashref_allows_value => sub
  		{
  			my $self = shift;
  			my ($key, $value) = @_;

  			return !!0 unless $self->my_hashref_allows_key($key);
  			return !!1 if $self==Dict();

  			my $dict = $self->find_parent(sub { $_->has_parent && $_->parent==Dict() });
  			my %params;
  			my $slurpy = $dict->my_dict_is_slurpy;
  			if ($slurpy)
  			{
  				my @args = @{$dict->parameters};
  				pop @args;
  				%params = @args;
  			}
  			else
  			{
  				%params = @{ $dict->parameters }
  			}

  			return !!1
  				if exists($params{$key}) && $params{$key}->check($value);
  			return !!0
  				if !$slurpy;
  			return !!1
  				if $slurpy==Any() || $slurpy==Item() || $slurpy==Defined() || $slurpy==Ref();
  			return $slurpy->my_hashref_allows_value($key, $value)
  				if $slurpy->is_a_type_of(HashRef());
  			return !!0;
  		},
  	},
  });

  use overload ();
  $meta->add_type({
  	name       => "Overload",
  	parent     => $_obj,
  	constraint => sub { overload::Overloaded($_) },
  	inlined    => sub { "Scalar::Util::blessed($_[1]) and overload::Overloaded($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Overload') unless @_;

  		my @operations = map {
  			Types::TypeTiny::StringLike->check($_)
  				? "$_"
  				: _croak("Parameters to Overload[`a] expected to be a strings; got $_");
  		} @_;

  		return sub {
  			my $value = shift;
  			for my $op (@operations) {
  				return unless overload::Method($value, $op);
  			}
  			return !!1;
  		}
  	},
  	inline_generator => sub {
  		my @operations = @_;
  		return sub {
  			my $v = $_[1];
  			join " and ",
  				"Scalar::Util::blessed($v)",
  				map "overload::Method($v, q[$_])", @operations;
  		};
  	},
  });

  our %_StrMatch;
  $meta->add_type({
  	name       => "StrMatch",
  	parent     => $_str,
  	constraint_generator => sub
  	{
  		return $meta->get_type('StrMatch') unless @_;

  		my ($regexp, $checker) = @_;

  		ref($regexp) eq 'Regexp'
  			or _croak("First parameter to StrMatch[`a] expected to be a Regexp; got $regexp");

  		if (@_ > 1)
  		{
  			$checker = Types::TypeTiny::to_TypeTiny($checker);
  			Types::TypeTiny::TypeTiny->check($checker)
  				or _croak("Second parameter to StrMatch[`a] expected to be a type constraint; got $checker")
  		}

  		$checker
  			? sub {
  				my $value = shift;
  				return if ref($value);
  				my @m = ($value =~ $regexp);
  				$checker->check(\@m);
  			}
  			: sub {
  				my $value = shift;
  				!ref($value) and $value =~ $regexp;
  			}
  		;
  	},
  	inline_generator => sub
  	{
  		require B;
  		my ($regexp, $checker) = @_;
  		my $regexp_string = "$regexp";
  		$_StrMatch{$regexp_string} = $regexp;
  		if ($checker)
  		{
  			return unless $checker->can_be_inlined;
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and do { my \$m = [$v =~ \$Types::Standard::_StrMatch{%s}]; %s }",
  					B::perlstring($regexp_string),
  					$checker->inline_check('$m'),
  				;
  			};
  		}
  		else
  		{
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and $v =~ \$Types::Standard::_StrMatch{%s}",
  					B::perlstring($regexp_string),
  				;
  			};
  		}
  	},
  });

  $meta->add_type({
  	name       => "OptList",
  	parent     => $_arr,
  	constraint => sub {
  		for my $inner (@$_) {
  			return unless ref($inner) eq q(ARRAY);
  			return unless @$inner == 2;
  			return unless is_Str($inner->[0]);
  		}
  		return !!1;
  	},
  	inlined     => sub {
  		my ($self, $var) = @_;
  		my $Str_check = Str()->inline_check('$inner->[0]');
  		my @code = 'do { my $ok = 1; ';
  		push @code,   sprintf('for my $inner (@{%s}) { no warnings; ', $var);
  		push @code,   sprintf('($ok=0) && last unless ref($inner) eq q(ARRAY) && @$inner == 2 && (%s); ', $Str_check);
  		push @code,   '} ';
  		push @code, '$ok }';
  		return (undef, join(q( ), @code));
  	},
  });

  $meta->add_type({
  	name       => "Tied",
  	parent     => $_ref,
  	constraint => sub {
  		!!tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_})
  	},
  	inlined    => sub {
  		my ($self, $var) = @_;
  		$self->parent->inline_check($var)
  		. " and !!tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var})"
  	},
  	name_generator => sub
  	{
  		my $self  = shift;
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require B;
  			return sprintf("%s[%s]", $self, B::perlstring($param));
  		}
  		return sprintf("%s[%s]", $self, $param);
  	},
  	constraint_generator => sub
  	{
  		return $meta->get_type('Tied') unless @_;

  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}

  		my $check = $param->compiled_check;
  		return sub {
  			$check->(tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_}));
  		};
  	},
  	inline_generator => sub {
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		return unless $param->can_be_inlined;

  		return sub {
  			require B;
  			my $var = $_[1];
  			sprintf(
  				"%s and do { my \$TIED = tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var}); %s }",
  				Ref()->inline_check($var),
  				$param->inline_check('$TIED')
  			);
  		};
  	},
  });

  $meta->add_type({
  	name       => "InstanceOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('InstanceOf') unless @_;
  		require Type::Tiny::Class;
  		my @classes = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Class"->new(class => $_, display_name => sprintf('InstanceOf[%s]', B::perlstring($_)))
  		} @_;
  		return $classes[0] if @classes == 1;

  		require B;
  		require Type::Tiny::Union;
  		return "Type::Tiny::Union"->new(
  			type_constraints => \@classes,
  			display_name     => sprintf('InstanceOf[%s]', join q[,], map B::perlstring($_->class), @classes),
  		);
  	},
  });

  $meta->add_type({
  	name       => "ConsumerOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('ConsumerOf') unless @_;
  		require B;
  		require Type::Tiny::Role;
  		my @roles = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Role"->new(role => $_, display_name => sprintf('ConsumerOf[%s]', B::perlstring($_)))
  		} @_;
  		return $roles[0] if @roles == 1;

  		require Type::Tiny::Intersection;
  		return "Type::Tiny::Intersection"->new(
  			type_constraints => \@roles,
  			display_name     => sprintf('ConsumerOf[%s]', join q[,], map B::perlstring($_->role), @roles),
  		);
  	},
  });

  $meta->add_type({
  	name       => "HasMethods",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('HasMethods') unless @_;
  		require B;
  		require Type::Tiny::Duck;
  		return "Type::Tiny::Duck"->new(
  			methods      => \@_,
  			display_name => sprintf('HasMethods[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });

  $meta->add_type({
  	name       => "Enum",
  	parent     => $_str,
  	constraint_generator => sub {
  		return $meta->get_type('Enum') unless @_;
  		require B;
  		require Type::Tiny::Enum;
  		return "Type::Tiny::Enum"->new(
  			values       => \@_,
  			display_name => sprintf('Enum[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });

  $meta->add_coercion({
  	name               => "MkOpt",
  	type_constraint    => $meta->get_type("OptList"),
  	type_coercion_map  => [
  		$_arr,    q{ Exporter::Tiny::mkopt($_) },
  		$_hash,   q{ Exporter::Tiny::mkopt($_) },
  		$_undef,  q{ [] },
  	],
  });

  $meta->add_coercion({
  	name               => "Join",
  	type_constraint    => $_str,
  	coercion_generator => sub {
  		my ($self, $target, $sep) = @_;
  		Types::TypeTiny::StringLike->check($sep)
  			or _croak("Parameter to Join[`a] expected to be a string; got $sep");
  		require B;
  		$sep = B::perlstring($sep);
  		return (ArrayRef(), qq{ join($sep, \@\$_) });
  	},
  });

  $meta->add_coercion({
  	name               => "Split",
  	type_constraint    => $_arr,
  	coercion_generator => sub {
  		my ($self, $target, $re) = @_;
  		ref($re) eq q(Regexp)
  			or _croak("Parameter to Split[`a] expected to be a regular expresssion; got $re");
  		my $regexp_string = "$re";
  		$regexp_string =~ s/\\\//\\\\\//g; # toothpicks
  		return (Str(), qq{ [split /$regexp_string/, \$_] });
  	},
  });

  __PACKAGE__->meta->make_immutable;

  1;

  __END__

  =pod

  =for stopwords booleans vstrings typeglobs

  =encoding utf-8

  =for stopwords datetimes

  =head1 NAME

  Types::Standard - bundled set of built-in types for Type::Tiny

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  L<Type::Tiny> bundles a few types which seem to be useful.

  =head2 Moose-like

  The following types are similar to those described in
  L<Moose::Util::TypeConstraints>.

  =over

  =item C<< Any >>

  Absolutely any value passes this type constraint (even undef).

  =item C<< Item >>

  Essentially the same as C<Any>. All other type constraints in this library
  inherit directly or indirectly from C<Item>.

  =item C<< Bool >>

  Values that are reasonable booleans. Accepts 1, 0, the empty string and
  undef.

  =item C<< Maybe[`a] >>

  Given another type constraint, also accepts undef. For example,
  C<< Maybe[Int] >> accepts all integers plus undef.

  =item C<< Undef >>

  Only undef passes this type constraint.

  =item C<< Defined >>

  Only undef fails this type constraint.

  =item C<< Value >>

  Any defined, non-reference value.

  =item C<< Str >>

  Any string.

  (The only difference between C<Value> and C<Str> is that the former accepts
  typeglobs and vstrings.)

  Other customers also bought: C<< StringLike >> from L<Types::TypeTiny>.

  =item C<< Num >>

  See C<LaxNum> and C<StrictNum> below.

  =item C<< Int >>

  An integer; that is a string of digits 0 to 9, optionally prefixed with a
  hyphen-minus character.

  =item C<< ClassName >>

  The name of a loaded package. The package must have C<< @ISA >> or
  C<< $VERSION >> defined, or must define at least one sub to be considered
  a loaded package.

  =item C<< RoleName >>

  Like C<< ClassName >>, but the package must I<not> define a method called
  C<new>. This is subtly different from Moose's type constraint of the same
  name; let me know if this causes you any problems. (I can't promise I'll
  change anything though.)

  =item C<< Ref[`a] >>

  Any defined reference value, including blessed objects.

  Unlike Moose, C<Ref> is a parameterized type, allowing Scalar::Util::reftype
  checks, a la

     Ref["HASH"]  # hashrefs, including blessed hashrefs

  =item C<< ScalarRef[`a] >>

  A value where C<< ref($value) eq "SCALAR" or ref($value) eq "REF" >>.

  If parameterized, the referred value must pass the additional constraint.
  For example, C<< ScalarRef[Int] >> must be a reference to a scalar which
  holds an integer value.

  =item C<< ArrayRef[`a] >>

  A value where C<< ref($value) eq "ARRAY" >>.

  If parameterized, the elements of the array must pass the additional
  constraint. For example, C<< ArrayRef[Num] >> must be a reference to an
  array of numbers.

  Other customers also bought: C<< ArrayLike >> from L<Types::TypeTiny>.

  =item C<< HashRef[`a] >>

  A value where C<< ref($value) eq "HASH" >>.

  If parameterized, the values of the hash must pass the additional
  constraint. For example, C<< HashRef[Num] >> must be a reference to an
  hash where the values are numbers. The hash keys are not constrained,
  but Perl limits them to strings; see C<Map> below if you need to further
  constrain the hash values.

  Other customers also bought: C<< HashLike >> from L<Types::TypeTiny>.

  =item C<< CodeRef >>

  A value where C<< ref($value) eq "CODE" >>.

  Other customers also bought: C<< CodeLike >> from L<Types::TypeTiny>.

  =item C<< RegexpRef >>

  A value where C<< ref($value) eq "Regexp" >>.

  =item C<< GlobRef >>

  A value where C<< ref($value) eq "GLOB" >>.

  =item C<< FileHandle >>

  A file handle.

  =item C<< Object >>

  A blessed object.

  (This also accepts regexp refs.)

  =back

  =head2 Structured

  OK, so I stole some ideas from L<MooseX::Types::Structured>.

  =over

  =item C<< Map[`k, `v] >>

  Similar to C<HashRef> but parameterized with type constraints for both the
  key and value. The constraint for keys would typically be a subtype of
  C<Str>.

  =item C<< Tuple[...] >>

  Subtype of C<ArrayRef>, accepting an list of type constraints for
  each slot in the array.

  C<< Tuple[Int, HashRef] >> would match C<< [1, {}] >> but not C<< [{}, 1] >>.

  =item C<< Dict[...] >>

  Subtype of C<HashRef>, accepting an list of type constraints for
  each slot in the hash.

  For example C<< Dict[name => Str, id => Int] >> allows
  C<< { name => "Bob", id => 42 } >>.

  =item C<< Optional[`a] >>

  Used in conjunction with C<Dict> and C<Tuple> to specify slots that are
  optional and may be omitted (but not necessarily set to an explicit undef).

  C<< Dict[name => Str, id => Optional[Int]] >> allows C<< { name => "Bob" } >>
  but not C<< { name => "Bob", id => "BOB" } >>.

  Note that any use of C<< Optional[`a] >> outside the context of
  parameterized C<Dict> and C<Tuple> type constraints makes little sense,
  and its behaviour is undefined. (An exception: it is used by
  L<Type::Params> for a similar purpose to how it's used in C<Tuple>.)

  =back

  This module also exports a C<slurpy> function, which can be used as
  follows.

  It can cause additional trailing values in a C<Tuple> to be slurped
  into a structure and validated. For example, slurping into an ArrayRef:

     my $type = Tuple[Str, slurpy ArrayRef[Int]];

     $type->( ["Hello"] );                # ok
     $type->( ["Hello", 1, 2, 3] );       # ok
     $type->( ["Hello", [1, 2, 3]] );     # not ok

  Or into a hashref:

     my $type2 = Tuple[Str, slurpy Map[Int, RegexpRef]];

     $type2->( ["Hello"] );                               # ok
     $type2->( ["Hello", 1, qr/one/i, 2, qr/two/] );      # ok

  It can cause additional values in a C<Dict> to be slurped into a
  hashref and validated:

     my $type3 = Dict[ values => ArrayRef, slurpy HashRef[Str] ];

     $type3->( { values => [] } );                        # ok
     $type3->( { values => [], name => "Foo" } );         # ok
     $type3->( { values => [], name => [] } );            # not ok

  In either C<Tuple> or C<Dict>, C<< slurpy Any >> can be used to indicate
  that additional values are acceptable, but should not be constrained in
  any way. (C<< slurpy Any >> is an optimized code path.)

  =begin trustme

  =item slurpy

  =end trustme

  =head2 Objects

  OK, so I stole some ideas from L<MooX::Types::MooseLike::Base>.

  =over

  =item C<< InstanceOf[`a] >>

  Shortcut for a union of L<Type::Tiny::Class> constraints.

  C<< InstanceOf["Foo", "Bar"] >> allows objects blessed into the C<Foo>
  or C<Bar> classes, or subclasses of those.

  Given no parameters, just equivalent to C<Object>.

  =item C<< ConsumerOf[`a] >>

  Shortcut for an intersection of L<Type::Tiny::Role> constraints.

  C<< ConsumerOf["Foo", "Bar"] >> allows objects where C<< $o->DOES("Foo") >>
  and C<< $o->DOES("Bar") >> both return true.

  Given no parameters, just equivalent to C<Object>.

  =item C<< HasMethods[`a] >>

  Shortcut for a L<Type::Tiny::Duck> constraint.

  C<< HasMethods["foo", "bar"] >> allows objects where C<< $o->can("foo") >>
  and C<< $o->can("bar") >> both return true.

  Given no parameters, just equivalent to C<Object>.

  =back

  =head2 More

  There are a few other types exported by this function:

  =over

  =item C<< Overload[`a] >>

  With no parameters, checks that the value is an overloaded object. Can
  be given one or more string parameters, which are specific operations
  to check are overloaded. For example, the following checks for objects
  which overload addition and subtraction.

     Overload["+", "-"]

  =item C<< Tied[`a] >>

  A reference to a tied scalar, array or hash.

  Can be parameterized with a type constraint which will be applied to
  the object returned by the C<< tied() >> function. As a convenience,
  can also be parameterized with a string, which will be inflated to a
  L<Type::Tiny::Class>.

     use Types::Standard qw(Tied);
     use Type::Utils qw(class_type);

     my $My_Package = class_type { class => "My::Package" };

     tie my %h, "My::Package";
     \%h ~~ Tied;                   # true
     \%h ~~ Tied[ $My_Package ];    # true
     \%h ~~ Tied["My::Package"];    # true

     tie my $s, "Other::Package";
     \$s ~~ Tied;                   # true
     $s  ~~ Tied;                   # false !!

  If you need to check that something is specifically a reference to
  a tied hash, use an intersection:

     use Types::Standard qw( Tied HashRef );

     my $TiedHash = (Tied) & (HashRef);

     tie my %h, "My::Package";
     tie my $s, "Other::Package";

     \%h ~~ $TiedHash;     # true
     \$s ~~ $TiedHash;     # false

  =item C<< StrMatch[`a] >>

  A string that matches a regular expression:

     declare "Distance",
        as StrMatch[ qr{^([0-9]+)\s*(mm|cm|m|km)$} ];

  You can optionally provide a type constraint for the array of subexpressions:

     declare "Distance",
        as StrMatch[
           qr{^([0-9]+)\s*(.+)$},
           Tuple[
              Int,
              enum(DistanceUnit => [qw/ mm cm m km /]),
           ],
        ];

  =item C<< Enum[`a] >>

  As per MooX::Types::MooseLike::Base:

     has size => (is => "ro", isa => Enum[qw( S M L XL XXL )]);

  =item C<< OptList >>

  An arrayref of arrayrefs in the style of L<Data::OptList> output.

  =item C<< LaxNum >>, C<< StrictNum >>

  In Moose 2.09, the C<Num> type constraint implementation was changed from
  being a wrapper around L<Scalar::Util>'s C<looks_like_number> function to
  a stricter regexp (which disallows things like "-Inf" and "Nan").

  Types::Standard provides I<both> implementations. C<LaxNum> is measurably
  faster.

  The C<Num> type constraint is currently an alias for C<LaxNum> unless you
  set the C<PERL_TYPES_STANDARD_STRICTNUM> environment variable to true before
  loading Types::Standard, in which case it becomes an alias for C<StrictNum>.
  The constant C<< Types::Standard::STRICTNUM >> can be used to check if
  C<Num> is being strict.

  Most people should probably use C<Num> or C<StrictNum>. Don't explicitly
  use C<LaxNum> unless you specifically need an attribute which will accept
  things like "Inf".

  =back

  =head2 Coercions

  None of the types in this type library have any coercions by default.
  However some standalone coercions may be exported. These can be combined
  with type constraints using the C<< plus_coercions >> method.

  =over

  =item C<< MkOpt >>

  A coercion from C<ArrayRef>, C<HashRef> or C<Undef> to C<OptList>. Example
  usage in a Moose attribute:

     use Types::Standard qw( OptList MkOpt );

     has options => (
        is     => "ro",
        isa    => OptList->plus_coercions( MkOpt ),
        coerce => 1,
     );

  =item C<< Split[`a] >>

  Split a string on a regexp.

     use Types::Standard qw( ArrayRef Str Split );

     has name => (
        is     => "ro",
        isa    => (ArrayRef[Str])->plus_coercions(Split[qr/\s/]),
        coerce => 1,
     );

  =item C<< Join[`a] >>

  Join an array of strings with a delimiter.

     use Types::Standard qw( Str Join );

     my $FileLines = Str->plus_coercions(Join["\n"]);

     has file_contents => (
        is     => "ro",
        isa    => $FileLines,
        coerce => 1,
     );

  =back

  =head2 Constants

  =over

  =item C<< Types::Standard::STRICTNUM >>

  Indicates whether C<Num> is an alias for C<StrictNum>. (It is usually an
  alias for C<LaxNum>.)

  =back

  =begin private

  =item Stringable

  =item LazyLoad

  =end private

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny::Manual>.

  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Type::Coercion>.

  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>,
  L<MooseX::Types::Structured>.

  L<Types::XSD> provides some type constraints based on XML Schema's data
  types; this includes constraints for ISO8601-formatted datetimes, integer
  ranges (e.g. C<< PositiveInteger[maxInclusive=>10] >> and so on.

  L<Types::Encodings> provides C<Bytes> and C<Chars> type constraints that
  were formerly found in Types::Standard.

  L<Types::Common::Numeric> and L<Types::Common::String> provide replacements
  for L<MooseX::Types::Common>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_STANDARD

$fatpacked{"Types/Standard/ArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_ARRAYREF';
  package Types::Standard::ArrayRef;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Types::Standard::ArrayRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ArrayRef::VERSION   = '1.000005';
  }

  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  no warnings;

  sub __constraint_generator
  {
  	return Types::Standard::ArrayRef unless @_;

  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ArrayRef[`a] expected to be a type constraint; got $param");

  	my $param_compiled_check = $param->compiled_check;
  	my $xsub;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  		$xsub = Type::Tiny::XS::get_coderef_for("ArrayRef[$paramname]")
  			if $paramname;
  	}
  	elsif (Type::Tiny::_USE_MOUSE and $param->_has_xsub)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("_parameterize_ArrayRef_for");
  		$xsub = $maker->($param) if $maker;
  	}

  	return (
  		sub
  		{
  			my $array = shift;
  			$param->check($_) || return for @$array;
  			return !!1;
  		},
  		$xsub,
  	);
  }

  sub __inline_generator
  {
  	my $param = shift;

  	my $param_compiled_check = $param->compiled_check;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  		my $xsubname  = Type::Tiny::XS::get_subname_for("ArrayRef[$paramname]");
  		return sub { "$xsubname\($_[1]\)" } if $xsubname;
  	}

  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'ARRAY' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (\@{$v}) { "
  		.    "(\$ok = 0, last) unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }

  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];

  	for my $i (0 .. $#$value)
  	{
  		my $item = $value->[$i];
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the array with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->[%d]', $varname, $i)) },
  		]
  	}

  	# This should never happen...
  	return;  # uncoverable statement
  }

  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;

  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);

  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, @new) = ($_, 0);';
  			push @code,    'for (@$orig) {';
  			push @code, sprintf('++$return_orig && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('push @new, (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my @new;
  				for my $item (@$value)
  				{
  					return $value unless $coercable_item->check($item);
  					push @new, $param->coerce($item);
  				}
  				return \@new;
  			},
  		);
  	}

  	return $C;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Types::Standard::ArrayRef - internals for the Types::Standard ArrayRef type constraint

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Types::Standard>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_STANDARD_ARRAYREF

$fatpacked{"Types/Standard/Dict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_DICT';
  package Types::Standard::Dict;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Types::Standard::Dict::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Dict::VERSION   = '1.000005';
  }

  use Types::Standard ();
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  my $_optional = Types::Standard::Optional;
  my $_hash     = Types::Standard::HashRef;
  my $_map      = Types::Standard::Map;
  my $_any      = Types::Standard::Any;

  no warnings;

  sub __constraint_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my %constraints = @_;
  	my %is_optional;

  	while (my ($k, $v) = each %constraints)
  	{
  		$constraints{$k} = Types::TypeTiny::to_TypeTiny($v);
  		$is_optional{$k} = !!$constraints{$k}->is_strictly_a_type_of($_optional);
  		Types::TypeTiny::TypeTiny->check($v)
  			or _croak("Parameter to Dict[`a] for key '$k' expected to be a type constraint; got $v");
  	}

  	return sub
  	{
  		my $value = $_[0];
  		if ($slurpy)
  		{
  			my %tmp = map {
  				exists($constraints{$_}) ? () : ($_ => $value->{$_})
  			} keys %$value;
  			return unless $slurpy->check(\%tmp);
  		}
  		else
  		{
  			exists($constraints{$_}) || return for sort keys %$value;
  		}
  		for my $k (sort keys %constraints) {
  			exists($value->{$k}) or ($is_optional{$k} ? next : return);
  			$constraints{$k}->check($value->{$k}) or return;
  		}
  		return !!1;
  	};
  }

  sub __inline_generator
  {
  	# We can only inline a parameterized Dict if all the
  	# constraints inside can be inlined.

  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	return if $slurpy && !$slurpy->can_be_inlined;

  	# Is slurpy a very loose type constraint?
  	# i.e. Any, Item, Defined, Ref, or HashRef
  	my $slurpy_is_any = $slurpy && $_hash->is_a_type_of( $slurpy );

  	# Is slurpy a parameterized Map, or expressable as a parameterized Map?
  	my $slurpy_is_map = $slurpy
  		&& $slurpy->is_parameterized
  		&& ((
  			$slurpy->parent->strictly_equals($_map)
  			&& $slurpy->parameters
  		)||(
  			$slurpy->parent->strictly_equals($_hash)
  			&& [ $_any, $slurpy->parameters->[0] ]
  		));

  	my %constraints = @_;
  	for my $c (values %constraints)
  	{
  		next if $c->can_be_inlined;
  		return;
  	}

  	my $regexp = join "|", map quotemeta, sort keys %constraints;
  	return sub
  	{
  		require B;
  		my $h = $_[1];
  		join " and ",
  			"ref($h) eq 'HASH'",
  			( $slurpy_is_any ? ()
  			: $slurpy_is_map ? do {
  				'(not grep {'
  				."my \$v = ($h)->{\$_};"
  				.sprintf(
  					'not((/\\A(?:%s)\\z/) or ((%s) and (%s)))',
  					$regexp,
  					$slurpy_is_map->[0]->inline_check('$_'),
  					$slurpy_is_map->[1]->inline_check('$v'),
  				) ."} keys \%{$h})"
  			}
  			: $slurpy ? do {
  				'do {'
  				. "my \$slurpy_tmp = +{ map /\\A(?:$regexp)\\z/ ? () : (\$_ => ($h)->{\$_}), keys \%{$h} };"
  				. $slurpy->inline_check('$slurpy_tmp')
  				. '}'
  			}
  			: "not(grep !/\\A(?:$regexp)\\z/, keys \%{$h})" ),
  			( map {
  				my $k = B::perlstring($_);
  				$constraints{$_}->is_strictly_a_type_of( $_optional )
  					? sprintf('(!exists %s->{%s} or %s)', $h, $k, $constraints{$_}->inline_check("$h\->{$k}"))
  					: ( "exists($h\->{$k})", $constraints{$_}->inline_check("$h\->{$k}") )
  			} sort keys %constraints ),
  	}
  }

  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my @params = @{ $type->parameters };

  	my $slurpy = ref($params[-1]) eq q(HASH) ? pop(@params)->{slurpy} : undef;
  	my %constraints = @params;

  	for my $k (sort keys %constraints)
  	{
  		next if $constraints{$k}->parent == Types::Standard::Optional && !exists $value->{$k};
  		next if $constraints{$k}->check($value->{$k});

  		return [
  			sprintf('"%s" requires key %s to appear in hash', $type, B::perlstring($k))
  		] unless exists $value->{$k};

  		return [
  			sprintf('"%s" constrains value at key %s of hash with "%s"', $type, B::perlstring($k), $constraints{$k}),
  			@{ $constraints{$k}->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}

  	if ($slurpy)
  	{
  		my %tmp = map {
  			exists($constraints{$_}) ? () : ($_ => $value->{$_})
  		} keys %$value;

  		my $explain = $slurpy->validate_explain(\%tmp, '$slurpy');
  		return [
  			sprintf('"%s" requires the hashref of additional key/value pairs to conform to "%s"', $type, $slurpy),
  			@$explain,
  		] if $explain;
  	}
  	else
  	{
  		for my $k (sort keys %$value)
  		{
  			return [
  				sprintf('"%s" does not allow key %s to appear in hash', $type, B::perlstring($k))
  			] unless exists $constraints{$k};
  		}
  	}

  	# This should never happen...
  	return;  # uncoverable statement
  }

  my $label_counter = 0;
  our ($keycheck_counter, @KEYCHECK) = -1;
  sub __coercion_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my ($parent, $child, %dict) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);

  	my $all_inlinable = 1;
  	for my $tc (values %dict)
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}
  	$all_inlinable = 0 if $slurpy && !$slurpy->can_be_inlined;
  	$all_inlinable = 0 if $slurpy && $slurpy->has_coercion && !$slurpy->coercion->can_be_inlined;

  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			require B;

  			my $keycheck = join "|", map quotemeta, sort { length($b) <=> length($a) or $a cmp $b } keys %dict;
  			$keycheck = $KEYCHECK[++$keycheck_counter] = qr{^($keycheck)$}ms; # regexp for legal keys

  			my $label = sprintf("DICTLABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $tmp, %new) = ($_, 0);';
  			push @code,       "$label: {";
  			if ($slurpy)
  			{
  				push @code, sprintf('my $slurped = +{ map +($_=~$%s::KEYCHECK[%d])?():($_=>$orig->{$_}), keys %%$orig };', __PACKAGE__, $keycheck_counter);
  				if ($slurpy->has_coercion)
  				{
  					push @code, sprintf('my $coerced = %s;', $slurpy->coercion->inline_coercion('$slurped'));
  					push @code, sprintf('((%s)&&(%s))?(%%new=%%$coerced):(($return_orig = 1), last %s);', $_hash->inline_check('$coerced'), $slurpy->inline_check('$coerced'), $label);
  				}
  				else
  				{
  					push @code, sprintf('(%s)?(%%new=%%$slurped):(($return_orig = 1), last %s);', $slurpy->inline_check('$slurped'), $label);
  				}
  			}
  			else
  			{
  				push @code, sprintf('($_ =~ $%s::KEYCHECK[%d])||(($return_orig = 1), last %s) for sort keys %%$orig;', __PACKAGE__, $keycheck_counter, $label);
  			}
  			for my $k (keys %dict)
  			{
  				my $ct = $dict{$k};
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of($_optional);
  				my $K = B::perlstring($k);

  				push @code, sprintf(
  					'if (exists $orig->{%s}) { $tmp = %s; (%s) ? ($new{%s}=$tmp) : ($return_orig=1 and last %s) }',
  					$K,
  					$ct_coerce
  						? $ct->coercion->inline_coercion("\$orig->{$K}")
  						: "\$orig->{$K}",
  					$ct->inline_check('$tmp'),
  					$K,
  					$label,
  				);
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			#warn "CODE:: @code";
  			"@code";
  		});
  	}

  	else
  	{
  		my %is_optional = map {
  			; $_ => !!$dict{$_}->is_strictly_a_type_of($_optional)
  		} sort keys %dict;
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;

  				if ($slurpy)
  				{
  					my %slurped = map exists($dict{$_}) ? () : ($_ => $value->{$_}), keys %$value;

  					if ($slurpy->check(\%slurped))
  					{
  						%new = %slurped;
  					}
  					elsif ($slurpy->has_coercion)
  					{
  						my $coerced = $slurpy->coerce(\%slurped);
  						$slurpy->check($coerced) ? (%new = %$coerced) : (return $value);
  					}
  					else
  					{
  						return $value;
  					}
  				}
  				else
  				{
  					for my $k (keys %$value)
  					{
  						return $value unless exists $dict{$k};
  					}
  				}

  				for my $k (keys %dict)
  				{
  					next if $is_optional{$k} and not exists $value->{$k};

  					my $ct = $dict{$k};
  					my $x  = $ct->has_coercion ? $ct->coerce($value->{$k}) : $value->{$k};

  					return $value unless $ct->check($x);

  					$new{$k} = $x;
  				}

  				return \%new;
  			},
  		);
  	}

  	return $C;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Types::Standard::Dict - internals for the Types::Standard Dict type constraint

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Types::Standard>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_STANDARD_DICT

$fatpacked{"Types/Standard/HashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_HASHREF';
  package Types::Standard::HashRef;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Types::Standard::HashRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::HashRef::VERSION   = '1.000005';
  }

  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  no warnings;

  sub __constraint_generator
  {
  	return Types::Standard::HashRef unless @_;

  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to HashRef[`a] expected to be a type constraint; got $param");

  	my $param_compiled_check = $param->compiled_check;
  	my $xsub;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  		$xsub = Type::Tiny::XS::get_coderef_for("HashRef[$paramname]")
  			if $paramname;
  	}
  	elsif (Type::Tiny::_USE_MOUSE and $param->_has_xsub)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("_parameterize_HashRef_for");
  		$xsub = $maker->($param) if $maker;
  	}

  	return (
  		sub
  		{
  			my $hash = shift;
  			$param->check($_) || return for values %$hash;
  			return !!1;
  		},
  		$xsub,
  	);
  }

  sub __inline_generator
  {
  	my $param = shift;

  	my $compiled = $param->compiled_check;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($compiled);
  		my $xsubname  = Type::Tiny::XS::get_subname_for("HashRef[$paramname]");
  		return sub { "$xsubname\($_[1]\)" } if $xsubname;
  	}

  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (values \%{$v}) { "
  		.    "(\$ok = 0, last) unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }

  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];

  	for my $k (sort keys %$value)
  	{
  		my $item = $value->{$k};
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the hash with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}

  	# This should never happen...
  	return;  # uncoverable statement
  }

  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;

  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);

  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{$_} = (%s);', $param->coercion->inline_coercion('$orig->{$_}'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $coercable_item->check($value->{$k});
  					$new{$k} = $param->coerce($value->{$k});
  				}
  				return \%new;
  			},
  		);
  	}

  	return $C;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Types::Standard::HashRef - internals for the Types::Standard HashRef type constraint

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Types::Standard>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_STANDARD_HASHREF

$fatpacked{"Types/Standard/Map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_MAP';
  package Types::Standard::Map;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Types::Standard::Map::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Map::VERSION   = '1.000005';
  }

  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  my $meta = Types::Standard->meta;

  no warnings;

  sub __constraint_generator
  {
  	return $meta->get_type('Map') unless @_;

  	my ($keys, $values) = map Types::TypeTiny::to_TypeTiny($_), @_;
  	Types::TypeTiny::TypeTiny->check($keys)
  		or _croak("First parameter to Map[`k,`v] expected to be a type constraint; got $keys");
  	Types::TypeTiny::TypeTiny->check($values)
  		or _croak("Second parameter to Map[`k,`v] expected to be a type constraint; got $values");

  	my @xsub;
  	if (Type::Tiny::_USE_XS)
  	{
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} ($keys, $values);

  		if (@known == 2)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "Map[%s,%s]", @known
  			);
  			push @xsub, $xsub if $xsub;
  		}
  	}

  	sub
  	{
  		my $hash = shift;
  		$keys->check($_)   || return for keys %$hash;
  		$values->check($_) || return for values %$hash;
  		return !!1;
  	}, @xsub;
  }

  sub __inline_generator
  {
  	my ($k, $v) = @_;
  	return unless $k->can_be_inlined && $v->can_be_inlined;

  	if (Type::Tiny::_USE_XS)
  	{
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} ($k, $v);

  		if (@known == 2)
  		{
  			my $xsub = Type::Tiny::XS::get_subname_for(
  				sprintf "Map[%s,%s]", @known
  			);
  			return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  		}
  	}

  	my $k_check = $k->inline_check('$k');
  	my $v_check = $v->inline_check('$v');
  	return sub {
  		my $h = $_[1];
  		"ref($h) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$v (values \%{$h}) { "
  		.    "(\$ok = 0, last) unless $v_check "
  		.  "}; "
  		.  "for my \$k (keys \%{$h}) { "
  		.    "(\$ok = 0, last) unless $k_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }

  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my ($kparam, $vparam) = @{ $type->parameters };

  	for my $k (sort keys %$value)
  	{
  		unless ($kparam->check($k))
  		{
  			return [
  				sprintf('"%s" constrains each key in the hash with "%s"', $type, $kparam),
  				@{ $kparam->validate_explain($k, sprintf('key %s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}

  		unless ($vparam->check($value->{$k}))
  		{
  			return [
  				sprintf('"%s" constrains each value in the hash with "%s"', $type, $vparam),
  				@{ $vparam->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  	}

  	# This should never happen...
  	return;  # uncoverable statement
  }

  sub __coercion_generator
  {
  	my ($parent, $child, $kparam, $vparam) = @_;
  	return unless $kparam->has_coercion || $vparam->has_coercion;

  	my $kcoercable_item = $kparam->has_coercion ? $kparam->coercion->_source_type_union : $kparam;
  	my $vcoercable_item = $vparam->has_coercion ? $vparam->coercion->_source_type_union : $vparam;
  	my $C = "Type::Coercion"->new(type_constraint => $child);

  	if ((!$kparam->has_coercion or $kparam->coercion->can_be_inlined)
  	and (!$vparam->has_coercion or $vparam->coercion->can_be_inlined)
  	and $kcoercable_item->can_be_inlined
  	and $vcoercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('++$return_orig && last unless (%s);', $kcoercable_item->inline_check('$_'));
  			push @code, sprintf('++$return_orig && last unless (%s);', $vcoercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{(%s)} = (%s);',
  				$kparam->has_coercion ? $kparam->coercion->inline_coercion('$_') : '$_',
  				$vparam->has_coercion ? $vparam->coercion->inline_coercion('$orig->{$_}') : '$orig->{$_}',
  			);
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $kcoercable_item->check($k) && $vcoercable_item->check($value->{$k});
  					$new{$kparam->has_coercion ? $kparam->coerce($k) : $k} =
  						$vparam->has_coercion ? $vparam->coerce($value->{$k}) : $value->{$k};
  				}
  				return \%new;
  			},
  		);
  	}

  	return $C;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Types::Standard::Map - internals for the Types::Standard Map type constraint

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Types::Standard>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_STANDARD_MAP

$fatpacked{"Types/Standard/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_SCALARREF';
  package Types::Standard::ScalarRef;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Types::Standard::ScalarRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ScalarRef::VERSION   = '1.000005';
  }

  use Types::Standard ();
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  no warnings;

  sub __constraint_generator
  {
  	return Types::Standard::ScalarRef unless @_;

  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ScalarRef[`a] expected to be a type constraint; got $param");

  	return sub
  	{
  		my $ref = shift;
  		$param->check($$ref) || return;
  		return !!1;
  	};
  }

  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	return sub {
  		my $v = $_[1];
  		my $param_check = $param->inline_check("\${$v}");
  		"(ref($v) eq 'SCALAR' or ref($v) eq 'REF') and $param_check";
  	};
  }

  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];

  	for my $item ($$value)
  	{
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains the referenced scalar value with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('${%s}', $varname)) },
  		];
  	}

  	# This should never happen...
  	return;  # uncoverable statement
  }

  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;

  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);

  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $new) = ($_, 0);';
  			push @code,    'for ($$orig) {';
  			push @code, sprintf('++$return_orig && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('$new = (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\$new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my $new;
  				for my $item ($$value)
  				{
  					return $value unless $coercable_item->check($item);
  					$new = $param->coerce($item);
  				}
  				return \$new;
  			},
  		);
  	}

  	return $C;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Types::Standard::ScalarRef - internals for the Types::Standard ScalarRef type constraint

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Types::Standard>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_STANDARD_SCALARREF

$fatpacked{"Types/Standard/Tuple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_TUPLE';
  package Types::Standard::Tuple;

  use 5.006001;
  use strict;
  use warnings;

  BEGIN {
  	$Types::Standard::Tuple::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Tuple::VERSION   = '1.000005';
  }

  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();

  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }

  my $_Optional = Types::Standard::Optional;

  no warnings;

  sub __constraint_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  		Types::TypeTiny::TypeTiny->check($slurpy)
  			or _croak("Slurpy parameter to Tuple[...] expected to be a type constraint; got $slurpy");
  	}

  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	for (@constraints)
  	{
  		Types::TypeTiny::TypeTiny->check($_)
  			or _croak("Parameters to Tuple[...] expected to be type constraints; got $_");
  	}

  	# By god, the Type::Tiny::XS API is currently horrible
  	my @xsub;
  	if (Type::Tiny::_USE_XS and !$slurpy)
  	{
  		my @known = map {
  			my $known;
  			$known = Type::Tiny::XS::is_known($_->compiled_check)
  				unless $_->is_strictly_a_type_of($_Optional);
  			defined($known) ? $known : ();
  		} @constraints;

  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "Tuple[%s]", join(',', @known)
  			);
  			push @xsub, $xsub if $xsub;
  		}
  	}

  	my @is_optional = map !!$_->is_strictly_a_type_of($_Optional), @constraints;
  	my $slurp_hash  = $slurpy && $slurpy->is_a_type_of(Types::Standard::HashRef);
  	my $slurp_any   = $slurpy && $slurpy->equals(Types::Standard::Any);

  	sub
  	{
  		my $value = $_[0];
  		if ($#constraints < $#$value)
  		{
  			return !!0 unless $slurpy;
  			my $tmp;
  			if ($slurp_hash)
  			{
  				($#$value - $#constraints+1) % 2 or return;
  				$tmp = +{@$value[$#constraints+1 .. $#$value]};
  				$slurpy->check($tmp) or return;
  			}
  			elsif (not $slurp_any)
  			{
  				$tmp = +[@$value[$#constraints+1 .. $#$value]];
  				$slurpy->check($tmp) or return;
  			}
  		}
  		for my $i (0 .. $#constraints)
  		{
  			($i > $#$value)
  				and return !!$is_optional[$i];

  			$constraints[$i]->check($value->[$i])
  				or return !!0;
  		}
  		return !!1;
  	}, @xsub;
  }

  sub __inline_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = pop(@constraints)->{slurpy};
  	}

  	return if grep { not $_->can_be_inlined } @constraints;
  	return if defined $slurpy && !$slurpy->can_be_inlined;

  	if (Type::Tiny::_USE_XS and !$slurpy)
  	{
  		my @known = map {
  			my $known;
  			$known = Type::Tiny::XS::is_known($_->compiled_check)
  				unless $_->is_strictly_a_type_of($_Optional);
  			defined($known) ? $known : ();
  		} @constraints;

  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_subname_for(
  				sprintf "Tuple[%s]", join(',', @known)
  			);
  			return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  		}
  	}

  	my $tmpl = "do { my \$tmp = +[\@{%s}[%d..\$#{%s}]]; %s }";
  	my $slurpy_any;
  	if (defined $slurpy)
  	{
  		$tmpl = 'do { my ($orig, $from, $to) = (%s, %d, $#{%s});'
  			.    '($to-$from % 2) and do { my $tmp = +{@{$orig}[$from..$to]}; %s }'
  			.    '}'
  			if $slurpy->is_a_type_of(Types::Standard::HashRef);
  		$slurpy_any = 1
  			if $slurpy->equals(Types::Standard::Any);
  	}

  	my @is_optional = map !!$_->is_strictly_a_type_of($_Optional), @constraints;
  	my $min         = 0 + grep !$_, @is_optional;

  	return sub
  	{
  		my $v = $_[1];
  		join " and ",
  			"ref($v) eq 'ARRAY'",
  			"scalar(\@{$v}) >= $min",
  			(
  				$slurpy_any
  					? ()
  					: (
  						$slurpy
  							? sprintf($tmpl, $v, $#constraints+1, $v, $slurpy->inline_check('$tmp'))
  							: sprintf("\@{$v} <= %d", scalar @constraints)
  					)
  			),
  			map {
  				my $inline = $constraints[$_]->inline_check("$v\->[$_]");
  				$is_optional[$_]
  					? sprintf('(@{%s} <= %d or %s)', $v, $_, $inline)
  					: $inline;
  			} 0 .. $#constraints;
  	};
  }

  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;

  	my @constraints = @{ $type->parameters };
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  	}
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;

  	if (@constraints < @$value and not $slurpy)
  	{
  		return [
  			sprintf('"%s" expects at most %d values in the array', $type, scalar(@constraints)),
  			sprintf('%d values found; too many', scalar(@$value)),
  		];
  	}

  	for my $i (0 .. $#constraints)
  	{
  		next if $constraints[$i]->is_strictly_a_type_of( Types::Standard::Optional ) && $i > $#$value;
  		next if $constraints[$i]->check($value->[$i]);

  		return [
  			sprintf('"%s" constrains value at index %d of array with "%s"', $type, $i, $constraints[$i]),
  			@{ $constraints[$i]->validate_explain($value->[$i], sprintf('%s->[%s]', $varname, $i)) },
  		];
  	}

  	if (defined($slurpy))
  	{
  		my $tmp = $slurpy->is_a_type_of(Types::Standard::HashRef)
  			? +{@$value[$#constraints+1 .. $#$value]}
  			: +[@$value[$#constraints+1 .. $#$value]];
  		$slurpy->check($tmp) or return [
  			sprintf(
  				'Array elements from index %d are slurped into a %s which is constrained with "%s"',
  				$#constraints+1,
  				$slurpy->is_a_type_of(Types::Standard::HashRef) ? 'hashref' : 'arrayref',
  				$slurpy,
  			),
  			@{ $slurpy->validate_explain($tmp, '$SLURPY') },
  		];
  	}

  	# This should never happen...
  	return;  # uncoverable statement
  }

  my $label_counter = 0;
  sub __coercion_generator
  {
  	my ($parent, $child, @tuple) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);

  	my $slurpy;
  	if (exists $tuple[-1] and ref $tuple[-1] eq "HASH")
  	{
  		$slurpy = pop(@tuple)->{slurpy};
  	}

  	my $all_inlinable = 1;
  	for my $tc (@tuple, ($slurpy ? $slurpy : ()))
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}

  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my $label = sprintf("TUPLELABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $tmp, @new) = ($_, 0);';
  			push @code,       "$label: {";
  			push @code,       sprintf('(($return_orig = 1), last %s) if @$orig > %d;', $label, scalar @tuple) unless $slurpy;
  			for my $i (0 .. $#tuple)
  			{
  				my $ct = $tuple[$i];
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of(Types::Standard::Optional);

  				push @code, sprintf(
  					'if (@$orig > %d) { $tmp = %s; (%s) ? ($new[%d]=$tmp) : ($return_orig=1 and last %s) }',
  					$i,
  					$ct_coerce
  						? $ct->coercion->inline_coercion("\$orig->[$i]")
  						: "\$orig->[$i]",
  					$ct->inline_check('$tmp'),
  					$i,
  					$label,
  				);
  			}
  			if ($slurpy)
  			{
  				my $size = @tuple;
  				push @code, sprintf('if (@$orig > %d) {', $size);
  				push @code, sprintf('my $tail = [ @{$orig}[%d .. $#$orig] ];', $size);
  				push @code, $slurpy->has_coercion
  					? sprintf('$tail = %s;', $slurpy->coercion->inline_coercion('$tail'))
  					: q();
  				push @code, sprintf(
  					'(%s) ? push(@new, @$tail) : ($return_orig++);',
  					$slurpy->inline_check('$tail'),
  				);
  				push @code, '}';
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}

  	else
  	{
  		my @is_optional = map !!$_->is_strictly_a_type_of($_Optional), @tuple;

  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;

  				if (!$slurpy and @$value > @tuple)
  				{
  					return $value;
  				}

  				my @new;
  				for my $i (0 .. $#tuple)
  				{
  					return \@new if $i > $#$value and $is_optional[$i];

  					my $ct = $tuple[$i];
  					my $x  = $ct->has_coercion ? $ct->coerce($value->[$i]) : $value->[$i];

  					return $value unless $ct->check($x);

  					$new[$i] = $x;
  				}

  				if ($slurpy and @$value > @tuple)
  				{
  					my $tmp = $slurpy->has_coercion
  						? $slurpy->coerce([ @{$value}[@tuple .. $#$value] ])
  						: [ @{$value}[@tuple .. $#$value] ];
  					$slurpy->check($tmp) ? push(@new, @$tmp) : return($value);
  				}

  				return \@new;
  			},
  		);
  	};

  	return $C;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =head1 NAME

  Types::Standard::Tuple - internals for the Types::Standard Tuple type constraint

  =head1 STATUS

  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Types::Standard>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_STANDARD_TUPLE

$fatpacked{"Types/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_TYPETINY';
  package Types::TypeTiny;

  use strict;
  use warnings;

  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';

  use Scalar::Util qw< blessed refaddr weaken >;

  our @EXPORT_OK = ( __PACKAGE__->type_names, qw/to_TypeTiny/ );

  my %cache;

  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }

  sub meta
  {
  	return $_[0];
  }

  sub type_names
  {
  	qw( CodeLike StringLike TypeTiny HashLike ArrayLike );
  }

  sub has_type
  {
  	my %has = map +($_ => 1), shift->type_names;
  	!!$has{ $_[0] };
  }

  sub get_type
  {
  	my $self = shift;
  	return unless $self->has_type(@_);
  	no strict qw(refs);
  	&{$_[0]}();
  }

  sub coercion_names
  {
  	qw();
  }

  sub has_coercion
  {
  	my %has = map +($_ => 1), shift->coercion_names;
  	!!$has{ $_[0] };
  }

  sub get_coercion
  {
  	my $self = shift;
  	return unless $self->has_coercion(@_);
  	no strict qw(refs);
  	&{$_[0]}();  # uncoverable statement
  }

  sub StringLike ()
  {
  	require Type::Tiny;
  	$cache{StringLike} ||= "Type::Tiny"->new(
  		name       => "StringLike",
  		constraint => sub {    defined($_   ) && !ref($_   ) or Scalar::Util::blessed($_   ) && overload::Method($_   , q[""])  },
  		inlined    => sub { qq/defined($_[1]) && !ref($_[1]) or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[""])/ },
  		library    => __PACKAGE__,
  	);
  }

  sub HashLike ()
  {
  	require Type::Tiny;
  	$cache{HashLike} ||= "Type::Tiny"->new(
  		name       => "HashLike",
  		constraint => sub {    ref($_   ) eq q[HASH] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[%{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[HASH] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\%{}])/ },
  		library    => __PACKAGE__,
  	);
  }

  sub ArrayLike ()
  {
  	require Type::Tiny;
  	$cache{ArrayLike} ||= "Type::Tiny"->new(
  		name       => "ArrayLike",
  		constraint => sub {    ref($_   ) eq q[ARRAY] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[@{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[ARRAY] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\@{}])/ },
  		library    => __PACKAGE__,
  	);
  }

  sub CodeLike ()
  {
  	require Type::Tiny;
  	$cache{CodeLike} ||= "Type::Tiny"->new(
  		name       => "CodeLike",
  		constraint => sub {    ref($_   ) eq q[CODE] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[&{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[CODE] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\&{}])/ },
  		library    => __PACKAGE__,
  	);
  }

  sub TypeTiny ()
  {
  	require Type::Tiny;
  	$cache{TypeTiny} ||= "Type::Tiny"->new(
  		name       => "TypeTiny",
  		constraint => sub {  Scalar::Util::blessed($_   ) && $_   ->isa(q[Type::Tiny])  },
  		inlined    => sub { my $var = $_[1]; "Scalar::Util::blessed($var) && $var\->isa(q[Type::Tiny])" },
  		library    => __PACKAGE__,
  	);
  }

  my %ttt_cache;

  sub to_TypeTiny
  {
  	my $t = $_[0];

  	return $t unless (my $ref = ref $t);
  	return $t if $ref =~ /^Type::Tiny\b/;

  	return $ttt_cache{ refaddr($t) } if $ttt_cache{ refaddr($t) };

  	if (my $class = blessed $t)
  	{
  		return $t                               if $class->isa("Type::Tiny");
  		return _TypeTinyFromMoose($t)           if $class->isa("Moose::Meta::TypeConstraint");
  		return _TypeTinyFromMoose($t)           if $class->isa("MooseX::Types::TypeDecorator");
  		return _TypeTinyFromValidationClass($t) if $class->isa("Validation::Class::Simple");
  		return _TypeTinyFromValidationClass($t) if $class->isa("Validation::Class");
  		return _TypeTinyFromGeneric($t)         if $t->can("check") && $t->can("get_message"); # i.e. Type::API::Constraint
  	}

  	return _TypeTinyFromCodeRef($t) if $ref eq q(CODE);

  	$t;
  }

  sub _TypeTinyFromMoose
  {
  	my $t = $_[0];

  	if (ref $t->{"Types::TypeTiny::to_TypeTiny"})
  	{
  		return $t->{"Types::TypeTiny::to_TypeTiny"};
  	}

  	if ($t->name ne '__ANON__')
  	{
  		require Types::Standard;
  		my $ts = 'Types::Standard'->get_type($t->name);
  		return $ts if $ts->{_is_core};
  	}

  	my %opts;
  	$opts{display_name} = $t->name;
  	$opts{constraint}   = $t->constraint;
  	$opts{parent}       = to_TypeTiny($t->parent)              if $t->has_parent;
  	$opts{inlined}      = sub { shift; $t->_inline_check(@_) } if $t->can_be_inlined;
  	$opts{message}      = sub { $t->get_message($_) }          if $t->has_message;
  	$opts{moose_type}   = $t;

  	require Type::Tiny;
  	my $new = 'Type::Tiny'->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });

  	$new->{coercion} = do {
  		require Type::Coercion::FromMoose;
  		'Type::Coercion::FromMoose'->new(
  			type_constraint => $new,
  			moose_coercion  => $t->coercion,
  		);
  	} if $t->has_coercion;

  	return $new;
  }

  sub _TypeTinyFromValidationClass
  {
  	my $t = $_[0];

  	require Type::Tiny;
  	require Types::Standard;

  	my %opts = (
  		parent            => Types::Standard::HashRef(),
  		_validation_class => $t,
  	);

  	if ($t->VERSION >= "7.900048")
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = eval { $t->validate };
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = (eval { $t->validate } ? "OK" : $t->errors_to_string);
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  	}
  	else  # need to use hackish method
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate };
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate } ? "OK" : $t->errors_to_string;
  		};
  	}

  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);

  	$new->coercion->add_type_coercions(
  		Types::Standard::HashRef() => sub {
  			my %params = %$_;
  			for my $k (keys %params)
  				{ delete $params{$_} unless $t->get_fields($k) };
  			$t->params->clear;
  			$t->params->add(%params);
  			eval { $t->validate };
  			$t->get_hash;
  		},
  	);

  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }

  sub _TypeTinyFromGeneric
  {
  	my $t = $_[0];

  	# XXX - handle inlining??

  	my %opts = (
  		constraint => sub { $t->check(@_ ? @_ : $_) },
  		message    => sub { $t->get_message(@_ ? @_ : $_) },
  	);

  	$opts{display_name} = $t->name if $t->can("name");

  	$opts{coercion} = sub { $t->coerce(@_ ? @_ : $_) }
  		if $t->can("has_coercion") && $t->has_coercion && $t->can("coerce");

  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }

  my $QFS;
  sub _TypeTinyFromCodeRef
  {
  	my $t = $_[0];

  	my %opts = (
  		constraint => sub {
  			return !!eval { $t->($_) };
  		},
  		message => sub {
  			local $@;
  			eval { $t->($_); 1 } or do { chomp $@; return $@ if $@ };
  			return sprintf('%s did not pass type constraint', Type::Tiny::_dd($_));
  		},
  	);

  	if ($QFS ||= "Sub::Quote"->can("quoted_from_sub"))
  	{
  		my (undef, $perlstring, $captures) = @{ $QFS->($t) || [] };
  		if ($perlstring)
  		{
  			$perlstring = "!!eval{ $perlstring }";
  			$opts{inlined} = sub
  			{
  				my $var = $_[1];
  				Sub::Quote::inlinify(
  					$perlstring,
  					$var,
  					$var eq q($_) ? '' : "local \$_ = $var;",
  					1,
  				);
  			} if $perlstring && !$captures;
  		}
  	}

  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }

  1;

  __END__

  =pod

  =encoding utf-8

  =for stopwords arrayfication hashification

  =head1 NAME

  Types::TypeTiny - type constraints used internally by Type::Tiny

  =head1 STATUS

  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.

  =head1 DESCRIPTION

  Dogfooding.

  This isn't a real Type::Library-based type library; that would involve
  too much circularity. But it exports some type constraints which, while
  designed for use within Type::Tiny, may be more generally useful.

  =head2 Types

  =over

  =item C<< StringLike >>

  Accepts strings and objects overloading stringification.

  =item C<< HashLike >>

  Accepts hashrefs and objects overloading hashification.

  =item C<< ArrayLike >>

  Accepts arrayrefs and objects overloading arrayfication.

  =item C<< CodeLike >>

  Accepts coderefs and objects overloading codification.

  =item C<< TypeTiny >>

  Accepts blessed L<Type::Tiny> objects.

  =back

  =head2 Coercion Functions

  =over

  =item C<< to_TypeTiny($constraint) >>

  Promotes (or "demotes" if you prefer) a Moose::Meta::TypeConstraint object
  to a Type::Tiny object.

  Can also handle L<Validation::Class> objects. Type constraints built from
  Validation::Class objects deliberately I<ignore> field filters when they
  do constraint checking (and go to great lengths to do so); using filters for
  coercion only. (The behaviour of C<coerce> if we don't do that is just too
  weird!)

  Can also handle any object providing C<check> and C<get_message> methods.
  (This includes L<Mouse::Meta::TypeConstraint> objects.) If the object also
  provides C<has_coercion> and C<coerce> methods, these will be used too.

  Can also handle coderefs (but not blessed coderefs or objects overloading
  C<< &{} >>). Coderefs are expected to return true iff C<< $_ >> passes the
  constraint. If C<< $_ >> fails the type constraint, they may either return
  false, or die with a helpful error message.

  =back

  =head2 Methods

  These are implemented so that C<< Types::TypeTiny->meta->get_type($foo) >>
  works, for rough compatibility with a real L<Type::Library> type library.

  =over

  =item C<< meta >>

  =item C<< type_names >>

  =item C<< get_type($name) >>

  =item C<< has_type($name) >>

  =item C<< coercion_names >>

  =item C<< get_coercion($name) >>

  =item C<< has_coercion($name) >>

  =back

  =head1 BUGS

  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.

  =head1 SEE ALSO

  L<Type::Tiny>.

  =head1 AUTHOR

  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

  =head1 COPYRIGHT AND LICENCE

  This software is copyright (c) 2013-2014 by Toby Inkster.

  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.

  =head1 DISCLAIMER OF WARRANTIES

  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

TYPES_TYPETINY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use warnings;
use strict;
use Getopt::Std;
use Bio::Cigar;  # Cpan this if you want to run this script !!
use List::Util qw(max);

use vars qw/ %opt /;

# this program is subsequently packed via App::FatPacker
# see http://perltricks.com/article/58/2014/1/5/The-easy-way-to-build-stand-alone-Perl-apps/
# install fatpack via cpan App::FatPacker
# fatpack pack hapture.pl > hapture
# either perl hapture or -run as executable by chmod 755


sub init(){
	getopts( "hv:s:i:g:", \%opt ) or usage();
	usage() if $opt{h};
	print STDERR "Require path specification for VCF file: -v\n" and exit if not defined $opt{v};
	print STDERR "Require path specification for SAM file: -s\n" and exit if not defined $opt{s};
	print STDERR "Require individual ID: -i\n" and exit if not defined $opt{i};
	print STDERR "Require group ID: -g \n" and exit if not defined $opt{g};
}


sub usage(){
print STDERR << "EOF";
    This program gathers variant haplotype sites from SAM alignment file, and reports a summary file for those variant sites

    usage: $0 [-h] -v vcf_file -s sam_file -i int

     -h        : this (help) message
     -v file   : variant caller file - VCF format (!! assumed the position is sorted)
     -s file   : sequence alignment file - SAM format
     -i int    : individual ID (integer value or unbroken string)
     -g str    : group ID (unbroken string)

    example: $0 -v s1.vcf -s s1.sam -i 0 -g sebastes

EOF
        exit;
}

#----- get user's input parameters ------

init();

#---------------------------------------


#----- read vcf file -------------

# Objective: keeps variants' info into memory so that
# I can tell whether there are any variant sites for
# the alignment read entry from the SAM file

my $vcf; # a hash reference that keeps track of essential vcf info: reference variant, derived variants, pos
my $hap;

open VCF, $opt{v};
while (<VCF>) {
	next if /^#/;
	my @line = split "\t";
	# for now, we only concern SNP site, (exclude indel and any other complex events)

	# reference allele
	next if length($line[3]) > 1;
	# derived allele
	my $max_len = 0;
	my @snp = split ",", $line[4];
	for my $deriv (@snp) {
		$max_len = length($deriv) if length($deriv) > $max_len;
	}
	next if $max_len > 1;

	#print $line[0], "\t", $line[3], "\t", $line[4], "\n";
	push @{$vcf->{$line[0]}}, $line[1];
	push @{$vcf->{"ref_".$line[0]}}, $line[3];
	push @{$vcf->{"der_".$line[0]}}, $snp[0];
}
close VCF;

#----------------------------------------


open SAM, $opt{s};
while(<SAM>) {
	next if /^\@/;
	my @lines = split "\t";
    next if $lines[1] >= 256; # skip entries that are secondary alignment or to multiple sites
	my $id = $lines[2];
	my $st_qpos = $lines[3]; # starting query position
	#my $mapq = $lines[4]; # mapping quality score
	#skip if the alignment id is not found in the vcf hash ref
	next if not defined $vcf->{$id};

  next if $lines[5] eq "*";

	my $cigar = Bio::Cigar->new($lines[5]);
	my @qseq = split "", $lines[9];
	my @qseq_qual = split "", $lines[10];

	next if $#qseq < 1;
	#print "Query length is ", $cigar->query_length, "\n";
	#print "Reference length is ", $cigar->reference_length, "\n";
	my $hapRead={};
	$hapRead->{"seq"} = "";
	my $ct=0;
	for my $rpos (@{$vcf->{$id}}) {
		my $rpos_adj = $rpos - $st_qpos +1;
		$ct++;

		if ($cigar->reference_length < $rpos_adj || $rpos_adj < 1) {
			$hapRead->{"seq"} .= "N"; # marked as unknown
			push @{$hapRead->{"qual"}}, "_";
			next;
		}
		my ($qpos, $op) = $cigar->rpos_to_qpos($rpos_adj);

		if (not defined $qpos) {
			$hapRead->{"seq"} .= "X"; # marked as deletion site
			push @{$hapRead->{"qual"}}, "_";
 		}
		else {
			$hapRead->{"seq"} .= $qseq[$qpos-1];
			push @{$hapRead->{"qual"}}, $qseq_qual[$qpos-1];
		}

		#print $qpos-1, "\t", $#qseq, "\t", $lines[0], "\t", $id, "\n";
		#print join "\t", $id, $rpos, $qseq[$qpos-1], $qseq_qual[$qpos-1], "\n" if $qpos != -1;
	}

	$hap->{$id}->{$hapRead->{"seq"}}->{"ct"}++;
	for my $i (0..$#{$vcf->{$id}}) {
		my $q = 10**(-(ord(${$hapRead->{"qual"}}[$i])-33)/10);

		if(! defined ${$hap->{$id}->{$hapRead->{"seq"}}->{"maxC"}}[$i]) {
	 	${$hap->{$id}->{$hapRead->{"seq"}}->{"maxC"}}[$i] = 0;
	 	${$hap->{$id}->{$hapRead->{"seq"}}->{"sC"}}[$i] = 0;
	 	}

		#${$hap->{$id}->{$hapRead->{"seq"}}->{"logC"}}[$i]+= log(1-$q) ;
	 	#${$hap->{$id}->{$hapRead->{"seq"}}->{"logW"}}[$i]+= log($q);
	 	${$hap->{$id}->{$hapRead->{"seq"}}->{"sC"}}[$i]+= 1-$q; # collecting the sum of prob phred site score for future use

	 	${$hap->{$id}->{$hapRead->{"seq"}}->{"maxC"}}[$i] = max(1-$q, ${$hap->{$id}->{$hapRead->{"seq"}}->{"maxC"}}[$i]);

	}
	#${$hap->{$id}->{$hapRead->{"seq"}}->{"mapq"}->{$mapq}}++; # collecting the MapQ alignment score

}


#--- output a haplotype summary file -----

for my $id (keys %{$hap}){
	for my $h (keys %{$hap->{$id}}){

		print join "\t", $opt{g}, # group label
				 $opt{i}, # individual id label
				$id, #locus id
				$h, # haplotype sequence
				$hap->{$id}->{$h}->{"ct"},  # number of occurence observed for this haplotype or read depth
				#(join ",", @{$hap->{$id}->{$h}->{"logC"}}), # log scale phred stat for being a correct base
				#(join ",", @{$hap->{$id}->{$h}->{"logW"}}), # log scale phred stat for being a miscalled base
				#(join ",", @{$vcf->{$id}}); # variant position
				(join ",", @{$hap->{$id}->{$h}->{"sC"}}), # sum of prob for calling correct base
				(join ",", @{$hap->{$id}->{$h}->{"maxC"}}), # max phred score
				"\n";

		#print "\t";

    #print join ",", map {$_, ${$hap->{$id}->{$h}->{"mapq"}->{$_}}} (keys %{$hap->{$id}->{$h}->{"mapq"}});
	  #print "\n";
	}
}

#----------------------------------------
